<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[这一年，想法指向行动]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%BF%99%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%83%B3%E6%B3%95%E6%8C%87%E5%90%91%E8%A1%8C%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[16年，17年2018年12月31日，天津，一个人，心情很复杂，负能量爆棚。又是一年末尾，新的一年开始，这是在上大学过的第三个元旦，前俩年到元旦都会非常的兴奋，朋友相聚，新环境的感触。可是今年的我却怎样也开心不起来，变得焦虑，急躁。16年上大学开始，每年这时候总会控制不住自己，总想出去看一看。当时自己还想着每年元旦假期换地过（天津，北京，上海…），16年，17年很顺利，没有任何阻碍，完成了计划，每个地方都有收获，同样也有好友相伴。16年在天津，三个人的聚会（文盲，旺旺），话题总是离不开这半年换一个城市生活的感受，毕竟都是第一次长时间的在一个陌生的城市生活。17年北京，这次的北京之旅，由16年的三位，变成了俩位（旺旺）。这次的相聚，了解到我的准备18年去当兵，去磨练自己。老实说我之前的我也有当兵的想法，但是没有去实现，比较佩服他，支持他。而当时的我对自己也有新的要求，经过一年的时间，所立要求完成了90%，带来更大困惑，未知。（18年9月份他正式参军入伍，知道消息后，准备去火车站送他上车（不容许），只能在入伍前几天见一次，期待俩年后的再聚，有成长，有改变） 在成长的路上，每一年意义非凡。未来是未知的，任何事都是不确定的，也许现在做的事会对以后产生影响，也许不值一提。希望在若干年后回想现在每天完成的事，会是有意义的。 快乐，焦虑，丧气。这三个词可以概括我在敲这些字时候对这一年中经历的总结。有时候我也在问自己，这样的状态是怎样造成的，并没有好的答案，反而更加严重。或许转移这方面的注意力，能够使这些负能量减少。 18年元旦假期结束，与好友乘坐高铁回天津，等车过程中看着北京南站的人来来往往，不知道下次来这里是否还会像当时一样有着轻松的状态。 这一年，想法指向行动之前所做的事没有明确的目标，总是在走一步看一步，以至于没有完成一件完整的事，只是有些小的收获。所以必须的作出改变，给自己重新规划，定一个目标，去实现它。最重要的事付出行动，没有这个其他的都是扯淡。开启新的进程，第一步就是去找学习资源，当时身边没有认识学长，老师，可以指引一些方法。比较幸运的是现在网络的发展，资源的获取非常方便，只要肯去查找，筛选。之前也有关注一些大牛的公众号，没事时就去看看他们之前分享的文章，也有学习路径推荐，最先关注的是公众号码农翻身，逐步的学习过程中，也有关注许多大牛（Hollis,纯洁的微笑，zhisheng等等）,里面有刚参加工作的，也有从业几年的技术大佬，总结的经验值得我去学习，找到介绍 Java 主要后端编程，网站开发，这个挺有兴趣。 刚开始就从语言出发,Java 开始学习，18年的上半年，也就是大二的下学期，开始看视频学习，找到的是毕向东教 Java 的视频，只要是没课，就开始看视频学习，也有书做参考，有些内容需要书的辅助。 一套系列结束后，那时候大概是四月份。打开各种招聘网站还有牛客网（这个我之前我不认识，公众号里文章看到，或许上面的面经有些帮助吧），并不是去找工作了，再说了就这破水平，也没地方需要。上去看的目的就是了解一下，这方面工作需要掌握什么样的技术，才能够参加工作。打开 Java 搜索，大多都是属于网站，后端方面，当时看好多技术，不认识。接着学习，先得认识它，会使用它。开始找方法，看书，刷大牛的博客。开始先看书是怎样一个过程，然后去创建工程去实现它。最后学习完成后，自己还写了一个小项目，把学习到技术合在一起。差不多到放假七月份时候，暑假得做些事，利用暑假学习了框架的知识（Spring,Spring MVC,MyBatis），总算假期做些事，没有荒废掉。使用框架完善了之前的那个小项目，算是一个简单的实践。 假期将要结束时，五个人组织了一次自驾游（司机：铭），第一次和小伙伴自驾游，不知道以后还能不能有像现在一样说走就走的旅行。这次去的地方有高中同学，解决了我们住的地方，非常感谢沙沙安排。就是他家的那个锁，是真的差。 九月份来学校后，开始了学校的实训，我觉着没有一点含金量，不值得参加，没办法这都是之前不认真学习的结果，得认。没有参加学校安排的校外，选择校内，跟着老师。那三个星期是最颓废的时候，使用了 c# 来编写，这次的实训让我彻底认识到语言是相通的，编程是思想。国庆小长假和大多数同学都一样，利用假期去一些之前没有去过地方，七天三地，天津—大同-呼和浩特，（三哥，沙沙，胖妹妹）。 假期结束，热闹过后的安静，会有一些孤独感。调整状态，心静下来做自己的事。每年在这时候有很多参加完面试的大佬在牛客网上分享他们的经历与建议，空闲时间会上去刷一些面经。受到了很大打击，发现之前的学习积累的知识太片面，基本是停留在会用这个基础上，没有自己对一个知识点的理解与分析，太多的漏洞需要弥补。同时也为明年的实习有所担忧，只想着早点出去参加工作（没有考研准备），积累经验，觉着学校里没有很好的技术提升，需要做一些对自己有挑战性的项目，用实际项目来积累经验。目前的能力还不够应对工作岗位，只有不断的学习，关注行业动态。 我会有这样的一种状态，每天都在按着计划进行。感觉自己会一点技术，更多的是什么也不会，刚开始认识 Java，网站后端，开始学习 JavaSE, JavaEE，开始网站搭建，进行增删改查。这些刚刚达到入门级别，自己的不足越发明显。各种负能量造成焦虑，丧气状态，一切都源于自己技能过于薄弱。 2019“好记性不如烂笔头” 多写，多做，少说话，说重点，争取在上半年能够找到实习公司。在日常生活中希望自己可以拿起相机，记录生活，用视频记录美好的回忆。 在没什么说的，再说其他的就更迷茫了。零散的记录。时间不等人，接下来继续努力，加油，共勉！ 2018/12/31 天津]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式及案例]]></title>
    <url>%2F2018%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[工厂模式学习工厂设计模式之前需要掌握两种设计原则： 依赖倒置原则：依赖抽象，不依赖具体类 开闭原则：两个主要特征，对于扩展是开放的和对于修改是关闭的。对于扩展是开放的：模块的行为是可扩展的，当应用需求改变时，可对模块进行扩展，使其具有新行为，可以改变模块的功能。对于修改是关闭的：当模块进行扩展时，不必改动源代码或二进制代码，不破坏原有系统结构。 工厂模式定义为：把可能会有所改变的代码（创建新对象的代码）放到另一个新对象中。称这个新对象为 “工厂”，处理创建对象的细节，用来封装对象的创建，让类决定创建的对象时什么。通过创建模式绕开 “new” ，避免对象创建过程中所导致的紧耦合（依赖具体类）. 工厂模式主要分为三大模式： 简单工厂模式（Simple Factory） 工厂方法模式 (Factory Method) 抽象工厂模式 (Abstract Factory) 以上三种模式从上到一逐步抽象 简单工厂模式（Simple Factory）简单工厂模式定义简单工厂模式又称静态工厂模式，简单工厂模式是一个工厂对象决定创建出哪一种产品类的实例，根据参数不同，返回不同的实例对象。属于创建型模式，不属于23种GOF设计模式之一。 案例创建抽象产品类 public abstract class MakeCar { public abstract void produce(); } 创建具体类，实现抽象产品类中方法 public class SaloonCar extends MakeCar { @Override public void produce() { System.out.println(&quot;创造轿车&quot;); } } public class Truck extends MakeCar { @Override public void produce() { System.out.println(&quot;创造卡车&quot;); } } 创建工厂类，使用 if-else 逻辑判断实例化对象 public class CarFactory { public MakeCar createCar(String type){ if (type.equals(&quot;轿车&quot;)){ return new SaloonCar(); } else if (type.equals(&quot;卡车&quot;)) { return new Truck(); }else { return null; } } } 编写测试类 public class Test { public static void main(String[] args){ CarFactory carFactory = new CarFactory(); MakeCar makeCar = carFactory.createCar(&quot;卡车&quot;); if (makeCar == null) { System.out.println(&quot;不在业务范围&quot;); return; } makeCar.produce(); } } 优点和缺点优点：用户无需写实例化类名，只需要传入相应参数即可，通过参数进行逻辑判断可以找到需要实例化的对象缺点：当添加新类时，需要对工厂整体进行改动，不利于系统的维护和扩展。例如：当我们想要在以上工厂中添加一个公交车，我们先需要定义一个类继承 MakeCar 类，然后再去 CarPactory 中修改逻辑代码，添加我们的公交车信息。这样操作是违反了开闭原则，不适用。 工厂方法模式 (Factory Method)工厂方法模式定义定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类实例化延迟（目的L：解耦）到子类。核心共产个类不再负责所有产品的创建，将具体创建交给子类。核心工厂类成为一个抽象工厂角色，仅负责给出子类实现的接口。 角色 Product (抽象产品): 所有产品必须实现的公共接口 ConcreteFactory (具体产品): 实现抽象产品的接口，具体工厂和具体产品一一对应 Factory (抽象工厂): 声明工厂方法 ConcreteFactory (具体工厂): 实现抽象工厂中定义的工厂方法，返回一个具体产品类的实例 案例创建抽象产品类 public abstract class Car { public abstract void creat(); } 创建具体产品类，继承 Car 类 public class SaloonCar extends Car { @Override public void creat() { System.out.println(&quot;轿车&quot;); } } public class Truck extends Car { @Override public void creat() { System.out.println(&quot;卡车&quot;); } } 创建抽象工厂类 public abstract class CarFactory { public abstract Car CreatCar(); } 创建具体工厂类 public class SaloonFactory extends CarFactory { @Override public Car CreatCar() { return new SaloonCar(); } } public class TruckFactory extends CarFactory { @Override public Car CreatCar() { return new Truck(); } } 编写测试代码 public class Test { public static void main(String[] args){ SaloonFactory saloonFactory = new SaloonFactory(); TruckFactory truckFactory = new TruckFactory(); Car car = saloonFactory.CreatCar(); car.creat(); Car car_1 = truckFactory.CreatCar(); car_1.creat(); } } 优点和缺点优点：工厂方法用来创建用户所需要的产品，同时向用户隐藏实例化细节，用户只需要关心产品对应的工厂，无须关注创建细节，当需要添加新类时，不需要改变逻辑判断，只需要添加工厂类即可，符合开闭原则，缺点：在添加新类时，需要编写新的具体产品类和对应的具体工厂，在一定程度上增加了系统的复杂度， 抽象工厂模式 (Abstract Factory)抽象工厂模式定义提供一个接口，创建相关或依赖对象的家族，不需要明确指定具体类，在抽象工厂模式中，每一个具体工厂提供多个工厂方法用于生产多种不同类型的产品。 角色 AbstractFactory (抽象工厂): 声明抽象产品的方法，每一个方法对应一个产品 ConcreteFactory (具体工厂): 实现在抽象工厂中声明创建产品的方法，生产一组具体的产品 AbstractProduct (抽象产品): 为每种产品声明接口，在抽象产品中声明业务方法 ConcreteProduct (具体产品): 定义具体工厂生产的具体产品的对象，实现抽象产品的接口中声明的业务方法 案例定义抽象产品 public abstract class Glass { public abstract void creat(); } public abstract class Tire { public abstract void creat(); } 定义具体产品 public class SaloonGlass extends Glass { @Override public void creat() { System.out.println(&quot;轿车的玻璃&quot;); } } public class TruckGlass extends Glass{ @Override public void creat() { System.out.println(&quot;卡车的玻璃&quot;); } } 定义抽象工厂 public interface CarFactory { Glass creatGlass(); Tire creatTire(); } 定义具体工厂 public class SaloonFactory implements CarFactory { @Override public Glass creatGlass() { return new SaloonGlass(); } @Override public Tire creatTire() { return new SaloonTire(); } } public class TruckFactory implements CarFactory{ @Override public Glass creatGlass() { return new TruckGlass(); } @Override public Tire creatTire() { return new TruckTire(); } } 编写测试方法 public class Test { public static void main(String[] args){ CarFactory carFactory = new SaloonFactory(); Glass glass = carFactory.creatGlass(); Tire tire = carFactory.creatTire(); glass.creat(); tire.creat(); } } 优点与缺点在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以是一个类，或者一个接口。具体工厂类实现了抽象工厂每一个方法，返回一个对象，同一个具体工厂所创建的产品对象构成一个产品族。 优点：可以通过具体工厂类创建一个产品族中的多个对象缺点：需要增加新产品等级结构复杂，需要修改抽象工厂和所有具体工厂类，对 “开闭原则” 呈现倾斜性]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(-):基础搭建、整合应用]]></title>
    <url>%2F2018%2F12%2F21%2FSpring%20Boot-%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E3%80%81%E6%95%B4%E5%90%88%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring BootSpring Boot 是由 Pivotal 团队开发的全新框架，简化 Spring 初始搭建以及开发过程。易上手，开箱即用，推荐使用 Maven 构建，访问 http://start.spring.io/, 选择 Maven Project 下载 demo 项目，开启 Spring Boot 学习之旅。 目录结构为 程序开发及主程序入口：/src/main/java/ 配置文件：/src/main/resources 测试程序：/src/test/java application.java 该文件存放根目录下：/src/java/com/example/application.java 实体类：/src/java/com/example/domain/ 业务代码：/src/java/com/example/service/ 控制代码：/src/java/com/example/controller/ Maven 资源目录：/src/java/resources/ Spring Boot 项目静态文件目录：/src/main/resources/static Spring Boot 项目模版文件目录：/src/main/resources/templates Spring Boot 项目配置文件目录：/src/main/resources/application.properties Spring Boot MyBatis 映射目录：/src/main/resources/application.priperties applicarion.java: 带有 main() 方法的类，用于启动程序，程序的入口以上是使用官方示例，整合 Spring Boot + Mybatis + Thymeleaf 基础目录结构。相比 SSM 框架整合，Spring Boot 配置简单，不需要先配置 web.xml ，Spring, Mybatis，然后进行整合，简化我们的配置过程。 特性 能够快速创建基于Spring的应用程序 能够直接使用 Java 的 main 方法启动内嵌的Tomcat，Jetty服务器运行Spring Boot程序，不需要部署war包文件 提供约定的 starter POM 来简化来简化 Maven 配置，让 Maven 配置变得简单 根据项目的maven依赖配置，Spring boot自动配置 Spring, SpringMVC 等其它开源框架 提供程序的健康检查等功能。（检查内部的运行状态等） 基本可以完全不使用xml配置文件，采用注解配置 Spring Boot 整合 MyBatisSpring Boot 整合 MyBatis 与 SSM 整合类似，Spring Boot 配置简单，在 pom.xml 中引入依赖，还需要在 application.properties 文件中添加一下代码就可使用 // mapper 映射文件目录 mybatis.mapper-locations=classpath:mapper/*.xml // 实体类文件目录 mybatis.type-aliases-package=com.example.domain ThymeleafThymeleaf 事一款用于渲染 XML/XHTML/HTML 内容的模版引擎。类似 JSP， Velocity, FreeMaker等（目前只接触过 JSP），可以与 Spring MVC 等 Web 框架集成作为 Web 应用的模版你引擎。Thymeleaf 特点是能够直接在浏览器中打开并正确显示模版页面，不需要启动整个 Web 应用。 模版引擎：用于 Web 开发的模版引擎，为了使用户界面业务数据分离而产生，可以生成特定格式的文档，用于网站的模版引擎就会生成一个标准的 HTML 文档。 Spring MVC 中 @Controller 中的方法可以直接返回模版名称，接下来 Thymeleaf 模版引擎会自动进行渲染 模版中的表达式支持 Spring 表达式语言（Spring EL） Spring Boot 中使用，在 maven 中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 还需要在 application.properties 中进行 thymeleaf 配置 # thymeleaf 配置 spring.thymeleaf.prefix=classpath:/templates/ // 模版加载位置 spring.thymeleaf.suffix=.html // 指定后缀 spring.thymeleaf.mode=HTML spring.thymeleaf.encoding=UTF-8 // 指定编码 # 热部署文件，页面不产生缓存，及时更新 spring.thymeleaf.cache=false spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** 初识 Thymeleaf 通过 HTML 的标签属性渲染标签内容 &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;#{home.welcome}&quot;&gt;Welcome to our grocery store!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 语法使用表达式支持语法字面 文本文字（Text literals）:one text, Another one!,... 数字文本 (Number Literals) :0, 34 ,0.4... 布尔文本 (Boolean Literals) : true false 空 (Null Literal): null 文字标记 (Literal Tolers): one, sometext, main... #####文本操作 字符串连接 (String Concatenation): + 文本替换 (Literal Substitutions): |The name is ${name}| 算术运算 二元运算符 (Binary Operators): +, -, *, /, % 减号（单目运算符）Minus sign (Unary Operator): - 布尔操作 二元运算符 (Binary Operators): and, or 布尔否定（一元运算符）Boolean Negation(Unary Operator): !, not 比较和等价 比较 (Comparators): &gt;, &lt;, &gt;=, &lt;=, (gt, lt, ge, le) 等值运算符 (Equality Operators): ==, !=, (eq, ne) 条件运算符 if-then: (if) ? (then) if-then-else: (if) ? (then) : (else) Default:(value)?: defaultvalue 以上所有特征可以被组合，嵌套使用 th: 常用标签 关键字 功能介绍 案例 th:id 替换 id &lt;input th:id=&#39;xxx&#39; + ${collect.id}/&gt; th:text 文本替换 &lt;p th:text=&quot;${user.id}&quot;&gt;id&lt;/p&gt; th:utext 支持 html 的文本替换 &lt;p th:utext=${user.id}&gt;id&lt;/p&gt; th:object 替换对象 &lt;div th:object=&quot;${session.user}&quot;&gt; th:value 属性赋值 &lt;input th:value=&quot;${user.id}&quot;&gt; th:with 变量赋值 &lt;div th:with=&quot;isEven=${user.count}%2==0&quot;&gt;&lt;/div&gt; th:style 设置样式 th:style=&quot;&#39;display:&#39; + @{(${sitrue} ? &#39;none&#39; : &#39;inline-block&#39;)} + &#39;&#39;&quot; th:onclick 点击事件 th:onclick=&quot;&#39;getCollect()&#39;&quot; th:each 属性赋值 tr th:each=&quot;user,userStat:${users}&quot;&gt; th:if 判断条件 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:unless 与 if 判断相反 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:href 链接地址 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt; th:switch 多路选择，配合 th:case 使用 &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case th:switch 的一个分支 &lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt; th:fragment 布局标签，定义一个代码段，方便其他地方引用 &lt;div th:fragment=&quot;alert&quot;&gt; th:include 布局标签，替换内容到引入的文件 &lt;headth:include=&quot;layout ::htmlhead&quot;th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt; th:replace 布局标签，替换整个标签到引入的文件 &lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt; th:selected selected 选择框 th:selected=&quot;(${xxx.id} == ${configObj.dd})&quot; th:src 图片类地址引入 &lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:inline 定义 js 脚本可以使用变量 &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; th:action 表单提交地址 &lt;form action=&quot;subscribe.html&quot; th:action=&quot;@{/subscribe}&quot;&gt; th:remove 删除某个属性 &lt;tr th:remove=&quot;all&quot;&gt; th:attr 设置标签属性，多个属性可以用逗号分隔 比如 th:attr=&quot;src=@{/image/aa.jpg},title=#{logo}&quot;，此标签不太优雅，一般用的比较少。 变量&lt;p&gt;Hello World! &lt;span th:text=&quot;${today}&quot;&gt;&lt;/span&gt;&lt;/p&gt; 假设 today 是变量，使用 ${...} 来表示获取变量的值 URLThymeleaf 对 URL 的处理语法是通过 @{URL} 进行处理。使用 th:href , th:src 等属性进行 URL 渲染。 循环使用较多的对 &lt;table&gt; 进行渲染，可以使用 th:each ，相当于 Java 中 foreach 循环。 条件求值th:if 和 th:unless 属性进行条件判断， th:unless 于 th:if 恰好相反，只有表达式不成立才会执行Swith 结构使用 th:swich，默认属性 default 使用 * 来表示 Utilties为了提高可用性，Thymeleaf 提供了一系列的 Utilty 对象（内置于 Context 中），通过 # 直接访问常用有： #dates, #strings, #lists 等]]></content>
      <categories>
        <category>框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-异常处理机制]]></title>
    <url>%2F2018%2F11%2F22%2FJava-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[异常处理每个程序在运行时，都会出现不被期望的事，它的出现组织了程序正常执行，这种情况被称为异常。在 Java 语言中提供了解决方法：异常处理机制。 异常处理机制Java 中异常可以是函数运行时引发的，也可是通过 throw 语句抛出。Throwable 类是异常处理的顶级父类。一个对象只有一个 Throable 类，或者说一个对象只有是 Throwable 类的直接或间接实例，他才是一个异常对象，才能被异常处理识别。 Throwable 图中可以可以认识到异常处理类之间关系。Error 和 Exception 继承自 Throwable 类，这俩个类又在对不同的异常做处理， Error: JVM 本身的错误,编译时系统错误Exception: 程序运行时发生的异常 Exception 又被分为 RuntiomeException （运行时异常）和 IOException （IO异常）。 异常处理在 Java 中还被分为检查异常和非检查异常 检查异常 除去 Error 和 RuntiomeException 与其子类，其他的都是检查异常； 什么是检查异常？在代码编译运行之前，编译器要求你对某段代码必须加 try…catch，或者 throws exception。出现这类情况的异常就属于检查异常。解决方式： throws exception ，一直抛出，一直抛到虚拟机处理。2. 使用 try…catch 捕获非检查异常与检查异常相反，编译器不强制处理的异常，包括 Errow 和 RuntimeException 及其子类。处理方式：1. 捕获 2. 继续抛出 3. 不处理Error多数由 Java 虚拟机生成并抛出，大多数错误与代码编写者无关。当错误发生在这里，程序是无法控制和处理，所以程序中无法对异常进行捕获。Exception程序自身可以进行控制和处理。在编写程序过程中，最常见的错误都在这里，比如 RuntimeException 及其子类异常，这些属于非检查异常，一般不需要处理，通常出现错误是程序逻辑错误引发异常。异常处理异常处理关键字 关键字 作用 try 用于监听，将要监听的代码放在 try 语句块之内，当该语句块发生异常，异常抛出 catch 用于捕获异常，捕获 try 语句块之内的异常 finally 不论异常是否发生，该语句块都会被执行，通常用来做资源释放，关闭文件，关闭数据库连接等，不做异常处理。如果在该语句块内使用 return 或 throw 等种植方法语句，直接结束，不会执行 try 或 catch 语句块 throw 用于抛出异常 throws 用在方法签名中，用于声明该方法可能抛出异常 抛出异常定义：一个方法不处理该异常，向上传递。谁调用该方法，谁来处理。关键字 throw 和 throws 区别：throw: 用于方法体内。throw 后接的是异常对象，或者异常对象的引用。throws: 用于方法名后，多个异常使用逗号分隔，检查异常处理时使用该关键字。异常不一定发生。注意：如果在 main 方法使用该关键字，会导致程序终断。 捕获异常使用 try…catch 来捕获异常，try 后可以有多个 catch 可以针对不同的异常进行处理。需要注意的是捕获异常的大小区分，当进行捕获异常时，先要捕获小的异常，再捕获大的异常。 自定义异常已经被封装好的异常处理是通常在写程序中较多出现的错误，而在写程序过程中，会出现某个程序中特有的问题，我们想要进行异常处理，但是这些异常却没有被 Java 封装成对象。所以这时候我们就需要自己来完成所要解决的异常处理。创建自定义异常必须要继承 Throwable 或者它的子类 Excepeiton。 class 自定义异常 extends 异常类型（Exception）{ // 在这里重写有参和无参构造方法 }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC 源码解读]]></title>
    <url>%2F2018%2F11%2F20%2FSpring-IoC-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Spring IoCIoC(Inversion of Control):Spring 框架中重要的一种理念，之前有过这方面的介绍。这篇主要记录 IoC 实现过程，如何完成控制反转。我们在使用 Spring 时，需要一种描述让 IoC 容器知道创建的对象与对象的关系，这个描述就是我们的可配置文件。（xml, properties）。 BeanFactory可以理解为生产 bean 的工厂，负责管理各个 bean 实例。它是 IoC 容器最基本的接口，提供最基本的 IoC 容器的功能，下面是 BeanFactory 源代码。 public interface BeanFactory { String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; // 根据 bean 的名字，获取容器中 bean 实例 Object getBean(String name) throws BeansException; // 根据 bean 的名字和 Class 类型的到 bean 实例，增加类型安全验证机制 &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; // bean 的索引，检查容器中是否有相同名字的 bean boolean containsBean(String name); // 根据 bean 的名字，得到 bean 的实例，并且判断这个 bean 是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; // 查询制定名字的 bean 是否是 prototyoe 类型，属性可以由用户在 BeanDefinition 中制定 boolean isPrototype(String name) throws NoSuchBeanDefinitionException; // 指定 bean 名字的 Class 类型是否是特定 Class 类型 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; // 得到 bean 实例的 Class 类型 Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; // 得到 bean 的别名 String[] getAliases(String name); } BeanFactory想要分析源码，首先对接口，类的继承关系有一个初步的认识，先要对整体有个宏观概念，为接下来细分代码做准备，从大到小的顺序进行分析源码。BeanFactory 是一个接口，与其他接口关系如下图：实现该接口有三个子接口，ListableBeanFactory,HierarchicalBeanFactory,AutowireCapableBeanFactory。上图可以看出最后默认实现类为 DefaultListableBeanFactory，这是 BeanFactory 重要实现类。图中 ApplicationContext 在 IoC 容器扮演者重要的角色，ApplicationContext 启动过程中，负责创建实例 Bean，往各个 Bean 中注入依赖等。 ApplicationContextSpring 提供了许多 IoC 容器的实现，如上图所示: ClassPathXmlApplication, FileSystemXmlApplication, AnnotationConfigApplicationContext.在这三个类中，都有一个重要的方法 refresh() 。该方法作为初始化 IoC 容器的入口，这一方法属于核心方法，重点分析。在这里我们使用 ClassPathXmlApplicationContext 继续解读 Spring IoC 整个过程。 public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext { private Resource[] configResources; // 如果已经存在 ApplicationContext 需要调用此方法配置成父子关系 public ClassPathXmlApplicationContext(ApplicationContext parent) { super(parent); } ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException { super(parent); // 根据提供路径，解析配置文件 this.setConfigLocations(configLocations); if (refresh) { this.refresh(); // 核心方法 } ... } } IoC 容器初始化过程当执行 refresh(()。标志着 IoC 容器正式启动，会经历三个基本的过程，包括定位，载入，注册。执行 refresh() 方法会将原来的 ApplicationContext 销毁，然后重新执行一次初始化操作。 public void refresh() throws BeansException, IllegalStateException { Object var1 = this.startupShutdownMonitor; // 防止 refresh（）还没有结束，又来一个启动或者执行操作 synchronized(this.startupShutdownMonitor) { // 准备工作，记录容器启动时间 this.prepareRefresh(); // 执行完这步后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，但是这步还没有将 Bean 初始化，只是将配置文件中信息解析出来。 ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); // 设置 BeanFactory 类加载器， this.prepareBeanFactory(beanFactory); try { this.postProcessBeanFactory(beanFactory); this.invokeBeanFactoryPostProcessors(beanFactory); this.registerBeanPostProcessors(beanFactory); this.initMessageSource(); this.initApplicationEventMulticaster(); this.onRefresh(); this.registerListeners(); // 初始化所有 singleton beans （lazy-init 的除外） this.finishBeanFactoryInitialization(beanFactory); // ApplicationContext 初始化完成，结束 refresh() 过程 this.finishRefresh(); } catch (BeansException var9) { if (this.logger.isWarnEnabled()) { this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9); } // 销毁已经初始化的 singleton beans ，防止资源占用 this.destroyBeans(); this.cancelRefresh(var9); throw var9; } finally { this.resetCommonCaches(); } } } 看过 refresh() 方法整体内容后，开始逐步分解代码。prepareRefresh() 该方法是穿件 Bean 容器前的准备工作，比如 记录容器启动时间就在该方法里设置。 Resource定位准备工作结束后，代码执行到 obtainFreshBeanFactory() 方法，该方法非常重要，初始化 BeanFactory，加载 Bean， 注册 Bean，都会在该方法内进行完成。（Bean 实例并不在这里完成）。 protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { this.refreshBeanFactory(); // 返回刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = this.getBeanFactory(); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Bean factory for &quot; + this.getDisplayName() + &quot;: &quot; + beanFactory); } return beanFactory; } 这里最重要的过程在 refreshBeanFactory() 中，Spring IoC 容器启动从这里开始。该方法是 AbstractApplicationContext 中的抽象方法。具体实现不在这里，而是在它的子类中实现， protected final void refreshBeanFactory() throws BeansException { // 如果之前加载过 BeanFactory ，销毁所有 Bean ，关闭 BeanFactory,这里不是只全局 BeanFactory ,只是指当前 ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); } } 先执行refreshBeanfactory()判断完是否有工厂后，开始载入 Bean 的定义，先经过方法customizeBeanFactory(beanFactory);该方法的作用是是否容许 BeanDefinition 覆盖,是否容许循环应用。这里就可以帮助我们解答在刚学习 Spring 时遇到的在配置文件中定义 bean 时使用了相同的 id 或 name 的问题，如果同意配置文件中重复，会抛错，不是同一个配置文件中，会覆盖。 接着是 loadBeanDefinitions(beanFactory)。此方法根据配置，加载各个 Bean ,然后放到 BeanFactory 中。接着我们到 AbstractRefreshableApplicationContext 类下找到 loadBeanDefinitions方法，在 AbstractXmlApplicationContext 类下找到该方法 protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); initBeanDefinitionReader(beanDefinitionReader); // 从这里出发继续分析源码 loadBeanDefinitions(beanDefinitionReader); } 按照 loadBeanDefinitions(beanDefinitionReader) 继续查找，接着来到 AbstractXmlApplicationContext 类下。 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); } } 这里有俩个分支，先选择第一个分支。接着到 BeanDefinitionReader 接口下。找到 loadBeanDefinitions 方法 public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, &quot;Resource array must not be null&quot;); int counter = 0; for (Resource resource : resources) { counter += loadBeanDefinitions(resource); } return counter; } 来到 BeanDefinitionReader 接口，在 XmlBeanDefinitionReader 类中找到 loadBeanDefinitions 方法 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) { logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); } // 存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { // 将资源文件转换为 IO 输入流 InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } // 从这里继续查找，这里是具体读取过程的方法 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 将 XML 文件转换为 DOM 对象 Document doc = doLoadDocument(inputSource, resource); // 启动时 Bean 定义解析详细过程， return registerBeanDefinitions(doc, resource); } ...... } 接着 registerBeanDefinitions 继续分析 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 对 XML 格式的 BeanDefinition 解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 获得容器中注册的 Bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // 解析过程入口， documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 统计解析 Bean 数量 return getRegistry().getBeanDefinitionCount() - countBefore; } BeanDefinitionDocumentReader 是一个接口，具体实现类在 DefaultBeanDefinitionDocumentReader public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); // 获取根元素 Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root); } 真正开始解析配置文件里内容是由 doRegisterBeanDefinitions(root); 方法开始解析 protected void doRegisterBeanDefinitions(Element root) { // 该类负责解析 Bean 定义 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; } parseBeanDefinitions(root, this.delegate); 核心方法，负责解析 标签 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { // 遍历根元素所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); // 如果节点是 XML 元素节点 if (node instanceof Element) { Element ele = (Element) node; // 如果节点使用的是 Spring 默认 XML 命名空间 if (delegate.isDefaultNamespace(ele)) { // 使用 Spring 的 Bean 规则解析元素节点 parseDefaultElement(ele, delegate); } else { // 如果没有使用 Spring 默认的 Bean 命名空间，使用用户自定义的解析规则解析元素（自定义的 xsd） delegate.parseCustomElement(ele); } } } } else { // 根节点没有使用 Spring 默认命名空间，使用用户自定义规则解析 delegate.parseCustomElement(root); } } 以上方法主要是判断是否为 Spring 默认命名空间，接着我们看使用 Spring 默认命名空间后，执行 parseDefaultElement(ele, delegate); 方法。 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // 如果节点是 import 导入元素，进行解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // 如果元素节点是 Alias 别名元素，进行别名解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // 如果是普通 Bean 元素，进行 Spring 的 Bean 规则解析 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 如果碰到嵌套 beans 标签，需要递归 doRegisterBeanDefinitions(ele); } } 直接来到 Bean 规则解析，这里的 DeanDefinitionHolder 是对 BeanDefinition 的封装，包括 BeanDefinition, beanName, aliases protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // 向 Spring IoC 容器注册解析得到的 Bean 定义 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 在进行标签解析之前，先回顾 标签里可以定义的属性 Property - calss 类的全限定名 name 可指定 id, name (用逗号，分号，空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autoworting mode no(默认值),byName,byType,constructor lazy-initialization mode 是否类加载 initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 将 name 属性的定义按照 逗号 分号 空格 切分，形成一个别名列表组 List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; // 如果没有指定 id，那么用别名列表的第一个名字作为 beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;); } } // 检查 &lt;bean&gt; id 和 name 的唯一性。 if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } // 从这里对 &lt;bean&gt; 元素详细解析 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { // 如果 &lt;bean&gt; 没有配置 id, name, 或者别名，为解析的 bean 生成一个唯一 beanName 并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { // beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } parseBeanDefinitionElement中放着具体参数配置 public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) { // 记录解析 Bean this.parseState.push(new BeanEntry(beanName)); // 读取配置的 class 名字，然后记录到 BeanDefinition 中，并不做实例化 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { // 如果配置了 parent 属性，获取 parent 属性的值 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析 &lt;bean /&gt; 内部的子元素，解析的星系放到 bd 中 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null; } 以上的代码内容就可解释在使用 Spring 是，配置文件中 标签中的属性是如何解析到 Bean 中。在上述解析过程中并没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类 BeanDefinition, 将 中配置信息设置到 BeanDefinition 中作为记录。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC]]></title>
    <url>%2F2018%2F10%2F20%2FSpring-IoC%2F</url>
    <content type="text"><![CDATA[认识Spring IoC DI 依赖注入 Dependency Injection IoC 控制反转 Inversion of Control IOC Container 容器 Inversion of Control Container 理解 IoC DIIoC (Inversion of Control) 控制反转，是由软件专家 Michael Mattson 提出的一个理论，用于解决复杂系统中的耦合关系。后来这个理论被逐渐应用到实践中，例如 J2EE 中的 Spring 框架中，IoC 就成为核心功能实现。 IoC(Inversion of Control)Spring IoC(Inversion of Control) 别名 DI(Dependency Injection) 依赖注入，而事实上二者并非相同。IoC(Inversion of Control)是面向对象的一种思想，DI(Dependency Injection)是实现这一思想的方法。 控制反转是目的，依赖注入是实现控制反转的手段。控制反转是将某个类对其内部状态权交给其他机制去完成，为降低类与类之间的耦合度。这个时候就出现了一个新的概念 IoC Container 称为 IoC 容器，在这里面从放着所有类与类依赖关系的方法，这时候 IoC 容器就充当着一个第三方角色，想要解决某个问题直接告诉 IoC 容器，它为我们找到解决问题的方式。 DI(Dependency Injection)DI(Dependency Injection)依赖注入 就是在 IoC 容器运行期间动态的将某种依赖关系注入到对象中，实现 IoC 的方法。利用依赖关系的注入的方式，实现对象之间的结耦。IoC 容器就是一个对象的制造工厂，当你使用某个功能时，你只要调用其方法就可以实现。你的关注点只在如何使用，至于其方法是如何创建，何时销毁等不需要关心，这一切都是由 IoC 容器进行实现。 实例当我们打开机械手表后，会看到上图所示的场景，各个齿轮带动时针，分针，秒针的转动，相互依赖，从而在表盘上产生正确的时间。但是当其中某个齿轮损坏后，整个系统可能将停止运转，之间存在这复杂的耦合关系。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。为了有效的避免出现这样的问题，我们对其引入 IoC(Inversion of Control)来解决。 当我们引入 IoC 容器后，我们可以发现其中 A,B,C,D这四个齿轮不再是相互依赖的关系，而是共同依赖于 IoC 容器这个第三方的，IoC 容器成为整个系统的一个核心，A,B,C,D四个齿轮的转动都依赖于 IoC 容器。 ##文档参考： Dependency Injection Inversion of Control Containers and the Dependency Injection pattern]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2018%2F07%2F31%2FJDBC-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[介绍JDBC (java database connectivity):Java数据库连接，就是用Java语言来操作数据库。主要由接口组成， 四大参数 driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql:/localhost:3306/数据库名 username: 用户名 password: 密码 连接数据库配置参数完成后，使用 DriverManager.getConnection() 方法建立连接，加载驱动。加载驱动除了上述方法，还可以使用 DriverManager.registerDriver(new Driver()) 不推荐使用该方法，原因有俩个： 采用此方法会导致驱动程序注册俩次，内存中会有俩个 Driver 对象。 程序依赖 mysql 的 api ,脱离 mysql 的 jar 包，程序无法编译，将来程序切换底层数据库会非常麻烦。 ConnectionDriverManager.getConnection() 该方法通过 Connection 类实现。该类用于数据库的连接操作。常用方法有： createStatement():向数据库发送 sql 的 statement 对象 prepareStatement(sql):向数据库发送预编译 sql 的 PrepareSatement 对象 prepareCall(sql):创建执行存储过程的 callableStatement 对象 setAutoConmmit(boolean autoCommit):设置事务是否提交 commit():在链接上提交事务 rollback():在此链接上回滚事务 数据交互通过 Connection 与数据库建立连接以后，可以通过 Statement PreparedStatement CallableStatement。这三个接口用于与数据库交互的实现。 Statement用于对数据库进行访问，主要用于向数据库发送 sql 语句。常用方法有： executeQuery(String sql):向数据库发送查询语句 executeUpdate(String sql):向数据库发送 insert, update, delete 语句 execute(String sql):向数据库发送任意 sql 语句 addBatch(String sql)：把多条 sql 语句放到一批处理 executeBatch():向数据去发送一批 sql 语句执行 在使用 Statement 执行 sql 语句之前需要使用 Connection 对象的 createSatement() 方法进行建立一个 Statement 对象。 PreparedStatement该接口扩展了 Statement 接口，可以动态提供\接受参数。该接口下有 setXXX() 方法，该方法将值绑定到参数，其中 XXX 表示要绑定到输入参数的值的 Java 数据类型。 例：setString(1, *.getName()); 1 表示索引位置（从 1 开始计数）。代表 JDBC 中第一个占位符 （?）。在 sql 语句中表示一个占位符。 ResultSetResulSet 是一个接口，在 JDBC 中 ResultSet 用于返回一个 sql 执行后的结果集。 关闭资源在完成一次增，删，改，查操作后，每次执行完成都需要调用 .close() 关闭资源。如果数据库连接代码在 try/catch 代码块中完成，关闭操作代码放在 finally 中。需要注意关闭代码顺序：先得到的对象后关，后得到的对象先关。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC 初相识]]></title>
    <url>%2F2018%2F07%2F30%2FSpring-MVC%2F</url>
    <content type="text"><![CDATA[Spring-MVC 认识要学习使用 Sring-MVC 需要了解，掌握一副图，展示了它的工作原理。需要理解并记牢每一步的所要完成的任务。 用户发送一个请求，请求先到达 DispatcherServlet ，它需要知道，应该将请求交给哪一个控制器去处理请求 DispatcherServlet 会去 Hander Mapping （处理器映射）查询下一站应该去何处。Hander Mapping 会将 DispatcherServlet 携带的 URL 进行判断，将结果告诉 DispatcherServlet ，然后将请求送达对应的控制器 控制器进行数据逻辑处理，处理后会产生用户所需要的信息（Model），还需要一个展示模型的页面（JSP）,控制器将处理完的结果进行整理（ModelAndView）,返回给 DispatcherServlet 这时候的虽然得到了 ModelAndView ，但是这里的 View 仅仅是一个逻辑名称，所以接下来需要将信息交给 ViewResolver（视图解析器）进行处理，返回一个相应的页面。 最后将解析完成的 ModelAndView 返回给用户。 到这结束用户的发送的一次请求到响应完成。接下来应该逐步认识需要做的配置 DispatcherServletDispatcherServlet（中央调度器）继承 HttpServlet ,所以我们要对 DispatcherServlet 进行所需要的配置就应该在 web.xml 中进行声明。 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 完成一个处理 “.do” 结尾的请求处理。在初始化 DispatcherServlet 得时候，如果不配置 ，Spring-MVC 默认会去 /WEB-INF 寻找 [servlet-name]-serlvet.xml 文件，例如：如果此 DispatcherServlet 不配置 ，它会在 /WEB-INF/springmvc-servlet.xml ,没有找到该配置文件，出异常报错。建议大家在此配置 contextConfigLocation ,如果不在 WEB-INF 目录下，要用 classpath: 指出该配置文件的路径。 上面说到该配置会处理一个 “.do” 结尾的请求处理，是因为我们在 中配置了 *.do 拦截请求方式，我们还可以进行其他的配置，产生不同的作用。 配置 / ：此工程所有的请求全部由 Spring-MVC 解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由 Spring-MVC 解析 配置 .do 或者 .action , 所有请求的 url 扩展名为 .do 或 .action 由 Spring-MVC 解析（建议使用此方法） 不可以配置 / ,如果配置 / ,返回 JSP 也由 Spring-MVC 解析，这是不对的 ViewResoler（视图解析器）当请求到达 ViewResoler ，需要完成一个任务，就是告诉 DispatcherServlet 该请求应该得到哪一个页面。我们需要配置一个视图解析器完成此操作。根据上述 DispatcherServlet 的配置信息，需要找到 spring 文件夹下的 spring-mvc.xml 进行配置。 &lt;bean id=&quot;resourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 进行该配置后，每次对请求的是图处理都会按照 此方式进行解析。如果我们使用 Spring-MVC 的注解，需要在该配置文件下，引入 mvc 命名空间，用 mvc:annotation-driven/ 进行声明]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring-MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring - AOP]]></title>
    <url>%2F2018%2F07%2F20%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[spring - AOPAOP （aspect object programming） 称为面向切面编程。可以理解为一个拦截框架，类似 Servlet 中的 Filter ，思想相同。 AOP基本概念 连接点（Jointpoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为“在哪里干”； 切入点（Pointcut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为“在哪里干的集合”； 通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为“干什么”； 方面/切面（Aspect）：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为“在哪干和干什么集合”； 引入（inter-type declaration）：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为“干什么（引入什么）”； 目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁干”； AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。 织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。 通知分类 前置通知（Before Advice）：在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）； 环绕通知（Around Advices）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。 后置通知（After Advice）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知： 后置返回通知（After returning Advice）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。 后置异常通知（After throwing Advice）: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。 后置最终通知（After finally Advice）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。 AOP 注解使用编写切入点 execution(* 方法所属类.方法(..)) @Aspect 指定一个类为切面类 @Pointcut(“execution(* com.carlos.pointCut(..))”) 指定切入点表达式 @Before(“pointCut()”) 前置通知: 目标方法之前执行 @After(“pointCut()”) 后置通知：目标方法之后执行（始终执行） @AfterReturning(“pointCut()”) 返回后通知： 执行方法结束前执行(异常不执行) @AfterThrowing(“pointCut()”) 异常通知: 出现异常时候执行 @Around(“pointCut()”) 环绕通知： 环绕目标方法执行 executionexecution是使用的最多的一种Pointcut表达式，表示某个方法的执行，其标准语法如下。execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?) modifiers-pattern表示方法的访问类型，public等；（修饰类型，可以不写） ret-type-pattern表示方法的返回值类型，如String表示返回类型是String，“*”表示所有的返回类型；（方法返回值类型，必写） declaring-type-pattern表示方法的声明类，如“com.elim..*”表示com.elim包及其子包下面的所有类型；（方法声明类型，可以不写） name-pattern表示方法的名称，如“add*”表示所有以add开头的方法名；（要匹配的名称，括号里是方法的参数） param-pattern表示方法参数的类型，name-pattern(param-pattern)其实是一起的表示的方法集对应的参数类型，如“add()”表示不带参数的add方法，“add()”表示带一个任意类型的参数的add方法，“add(,String)”则表示带两个参数，且第二个参数是String类型的add方法； throws-pattern表示异常类型；其中以问号结束的部分都是可以省略的。（方法抛出的异常类型，可以不写） “execution(* add())”匹配所有的不带参数的add()方法。 “execution(public com.elim...add*(..))”匹配所有com.elim包及其子包下所有类的以add开头的所有public方法。 “execution( (..) throws Exception)”匹配所有抛出Exception的方法。 AOP XML文件使用 aop:config 大多数 aop:* 元素都需要在aop:config元素内 aop:before 前置通知 aop:after 后置通知（不论被通知方法是否执行） aop:aspect 定义一个切面 aop:pointcut 定义一个切点 aop:after-returning 返回通知 aop:after-throwing 异常通知 aop:around 环绕通知 aop:declare-parents 以透明方式为被通知的对象引入额外的接口 aop:advisor 定义通知器 aop:aspectj-autoproxy 启用@AspectJ注解驱动的切面 以上我们对于 AOP 的使用有一个初步的认识，接下来通过一个实例，实践 AOP 的功能应用。分别使用注解方式与 XML 文件配置方式实现 AOP 使用实例创建实例接口package com.spring; public interface ISomeService { void doFirst(); String doSecond(); void doThird(); } 使用 XML 文件实现 AOPpackage com.spring; public class SomeServiceImpl implements ISomeService { @Override public void doFirst() { // 执行 doFIrst() 方法 System.out.println(&quot;SomeService first&quot;); } @Override public String doSecond() { // 执行 doSecond() 方法 System.out.println(&quot;SomeService second&quot;); return &quot;Second&quot;; } @Override public void doThird() { // 执行 doThird() 方法 System.out.println(&quot;SomeService third&quot;); } } 编写目标类package com.spring; import org.aspectj.lang.ProceedingJoinPoint; public class MyAspect { // 执行前调用 public void before(){ System.out.println(&quot;before&quot;); } // 执行后调用 public void after(){ System.out.println(&quot;after&quot;); } public void around(ProceedingJoinPoint pj) throws Throwable{ System.out.println(&quot;around before&quot;); pj.proceed(); System.out.println(&quot;around after&quot;); } } 注意：使用环绕通知必须要使用 ProceedingJoinPoint 。使用它来调用被通知的方法，需要调用 proceed() 方法来实现功能。如果忘记调用此方法，会阻塞对被通知的方法的调用。 创建 XML 文件 ApplicationContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.spring.SomeServiceImpl&quot; /&gt; &lt;!-- 注册切面 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.MyAspect&quot;/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 定义切点 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doFirst(..))&quot; id=&quot;first&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doSecond(..))&quot; id=&quot;second&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doThird(..))&quot; id=&quot;third&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;first&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;second&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;third&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 使用注解方法完成 AOP&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt; &lt;!-- 注册切面 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.MyAspect&quot;&gt;&lt;/bean&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.spring.SomeServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 注册Aspect --&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 使用注解方式，必须在 ApplicationContext.xml 文件中添加 &lt;aop:aspectj-autoproxy/&gt; 用于启用 AspectJ 自动代理 编写目标类@Aspect // 表示该类为切面 public class MyAspect { // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doFirst(..))&quot;) public void first(){} // 通知前 @Before(&quot;first()&quot;) private void before(){ System.out.println(&quot;before&quot;); } // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doSecond(..))&quot;) public void second(){} // 通知后 @After(&quot;second()&quot;) public void after(){ System.out.println(&quot;执行 doSecond() after&quot;); } // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doThird(..))&quot;) public void third(){} // 环绕通知 @Around(&quot;third()&quot;) public void around(ProceedingJoinPoint pj) throws Throwable{ System.out.println(&quot;third 执行之前&quot;); pj.proceed(); System.out.println(&quot;third 执行之后&quot;); } } 编写测试类public class MyTest { // 使用注解 调用 Test 测试方法 @Test public void test1(){ String s = &quot;com/spring/ApplicationContext.xml&quot;; ApplicationContext ac = new ClassPathXmlApplicationContext(s); ISomeService service = (ISomeService) ac.getBean(&quot;someService&quot;); service.doFirst(); System.out.println(&quot;=============&quot;); service.doSecond(); System.out.println(&quot;==============&quot;); service.doThird(); } } 以上内容通过一个小实例完成对 AOP 的应用实现，简单的做一个认识了解。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 初相识]]></title>
    <url>%2F2018%2F06%2F20%2FSpring%20%E5%88%9D%E7%9B%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spring 介绍Spring是一个轻量级框架。不依赖于容器就可以运行。Struts，Hibernate 同属于轻量级。Spring以IOC，AOP为主要思想 IOC：Inversion of Control， 控制反转。 AOP：Aspect Oriented Programming， 面向切面编程。通俗意思就是在执行某些代码前执行另一些代码，可以做出添加，删除某些功能。类似于Servlet中的Filter，思想相同。 Spring 属于非侵入式 侵入式：通常需要通过实现特定的接口，继承特定的类才能增强功能 非侵入式：对现有类的结构没有影响，就可以增强 JavaBean 的功能 Spring 三层构架 表现层(Web): Spring MVC 业务逻辑层（Service）：Spring的IOC 数据访问层（DAO）：Spring的jdbc 使用Spring重要的jar包四个必须包 spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-expression：spring表达式语言 aop部分包含4个模块 spring-aop：面向切面编程 spring-aspects：集成AspectJ spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 test部分只有一个模块，我将spring-context-support也放在这吧 spring-test：spring测试，提供junit与mock测试功能 spring-context-support：spring额外支持包，比如邮件服务、视图解析等 commons-logging: 日志（必须包） Spring Bean 三种不同配置方式基于 XML 配置方式导入 jar 包 commons-logging spring-aop spring-beans spring-context spring-core spring-expression spring-test 创建 Bean package com.carlos.spring; public class helloword { private String title; private String name; public helloword(String title, String name){ this.title = title; this.name = name; } public void show(){ System.out.print(title + &quot;:&quot; + name); } } 创建测试类package com.carlos.spring; public class test { public static void main(String[] args) { ApplicationContext hw = new ClassPathXmlApplicationCont(&quot;ApplicationContext.xml&quot;); helloword h = (helloword) hw.getBean(&quot;hello&quot;); h.show(); } } 创建 XML 文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.carlos.spring.helloword&quot;&gt; &lt;constructor-arg name=&quot;title&quot; value=&quot;hello word&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;carlos&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 使用构造器注入 添加xmlns:c=&quot;http://www.springframework.org/schema/c&quot; &lt;constructor-arg name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt; Spring c- 命名空间`&lt;bean id=”hello” class=”com.carlos.spring.helloword”c:name=&quot;carlos&quot; c:title=&quot;hello word!&quot;&gt; ` XML 不容许数字作为属性的第一个字符，想要使用需要加一个 _ 前缀 使用 Set 方法注入 添加xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;property name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt; Spring p- 命名空间`&lt;bean id=”hello” class=”com.carlos.spring.helloword”p:name=&quot;carlos&quot; p:title=&quot;hello word!&quot;&gt; ` 装配集合使用 List 元素申明一个列表 &lt;property name=&quot;num&quot;&gt; &lt;list&gt; &lt;value&gt;第一&lt;/value&gt; &lt;value&gt;第二&lt;/value&gt; &lt;value&gt;第三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 与 性质相同，都可使用。不同的是，set 不可存放重复数据，存放顺序同样不可保证。推荐使用 。不论在哪种情况下俩种集合都可使用。 基于注解的配置方式注解 @Component : 表明该类会作为组件类。 @ComponentScan : 能够在Spring中启用组件扫描。如果没有其他的配置，默认会扫描与配置类相同的包。 @Controller : 用于对 Controller 实现类进行标注，功能与 Component 相同。 @Repository : 用于对 DAO 实现类进行标注。 @Service : 用于对 Service 实现类进行标注，功能与 Component 相同。 创建 BeanDAO 层使用注解 @Repository @Repository public class UserDao { public void save(){ System.out.println(&quot;数据库&quot;); } } 等效于 XML 中 &lt;bean id=&quot;userDao&quot; class=&quot; ... &quot;/&gt; ID 为 userDao 而不是 UserDao,将类名第一个字母变为小写。 Service 层使用注解 @Service @Service public class UserService { public void save(){ System.out.println(&quot;service&quot;); } } Servlet 层使用注解 @Controller @Controller public class UserServlet { public void save(){ System.out.println(&quot;servlet&quot;); } } 创建 XML 启动组件扫描&lt;beans ...&gt; &lt;context:component-scan base-package=&quot; 包名 &quot;&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 创建测试类public class Test { public static void main(String[] args) { ApplicationContext act = new ClassPathXmlApplicationContext (&quot;ApplicationContext.xml&quot;); UserDao ud = (UserDao) act.getBean(&quot;userDao&quot;); ud.save(); UserService user = (UserService) act.getBean(&quot;userService&quot;); user.save(); UserServlet us = (UserServlet) act.getBean(&quot;userServlet&quot;); us.save(); } } 基于 Java 类的配置方式 Bean ： 声明 Bean创建配置类 @Configuration public class User { @Bean public String show(){ return &quot;hello word!&quot;; } } @Configuration public class Student { @Bean public String show1(){ return &quot;student&quot;; } } 创建测试类public class Test { public static void main(String[] args) { AnnotationConfigApplicationContext at = new AnnotationConfigApplicationContext(User.class); System.out.println(at.getBean(&quot;show&quot;)); AnnotationConfigApplicationContext stu = new AnnotationConfigApplicationContext(Student.class); System.out.println(stu.getBean(&quot;show1&quot;)); } }]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F05%2Ffrist-blog%2F</url>
    <content type="text"><![CDATA[Hello World学习遇到不解问题，在网上查找答案的过程中，偶然间点到一个链接，点进去是个人博客，去寻找答案。解决问题后，第一次接触个人博客，带着好奇心开始了解认识个人博客，浏览过一些后。发现博客内容参差不齐，学习，工作，生活。太多吸引到我的内容，这也算是开始个人博客的原因之一。浏览他人的博客后，着手准备做一个关于自己的，丰富它的内容。刚开始比较从基础知识开始学习，写的都是基础内容，菜鸟一个。随着时间的增加，知识的累积。会更多地分享自己的理解和总结，也供他人日后参考。记录这个成长路上的点点滴滴。 链接 Weibo: weibo@CarlosHaoxj Zhihu: Zhihu@CarlosHaoxj]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>CarlosHaoxj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 基础语法]]></title>
    <url>%2F2018%2F06%2F02%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQL 模式数据定义语言(Schema Data Definition Language)DDL 代表指令CREATE,DROP,ALTER 数据操纵语言(Data Manipulation Language)DML 代表指令INSERT,UPDATE,DELETE 数据查询语言(Data Query Language)DQL 代表指令SELECT 数据控制语言(Data Control Language)DCL 代表指令CRANT,REVOKE SQL 语法详解关键字大写,使用 ； 号表示结束。 DDL 数据定义语法对数据库和表的结构操作 对数据库操作 定义数据库：CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8] 显示数据库: SHOW DATABASES 使用数据库: USE 数据库名 修改数据库： ALTER DATABASE 数据库名 CHARACTER SET UTF-8 删除数据库: DROP DATABASE 数据库名 对表操作创建表 CREATE TABLE &lt;表名&gt;( &lt;列名&gt;&lt;数据类型&gt;[列级完整约束条件] &lt;列名&gt;&lt;数据类型&gt;[列级完整约束条件] [,&lt;表级完整约束条件&gt;] ); 删除表 DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; RESTRICT 删除表有限制 若存在约束条件 此表不可被删除 CASCADE 删除表没有限制 所有条件一并被删除 建立索引，索引为加快查询速度 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON&lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]); 次序: ASC(升序) DESC(降序) 默认是升序 修改索引 ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 删除索引 DROP INDEX&lt;索引名&gt;;DML 数据操作语法做更新数据，做增，删，改插入数据 INSERT INTO &lt;表名&gt;(属性列1，属性列2，…) VALUES(常量1，常量2，…)； 属性列可以省略，但是在表定义 NOT NULL 的属性列不可取空值。在写程序时不建议省略。字符串必须使用单引号括起来。 修改数据 UPDATE&lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; WHERE &lt;条件&gt;; 如果省略 WHERE 表示修改表中所有元祖 可以使用 IN(…); 嵌套子查询 删除数据 DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;; 如果省略 WHERE 表示删除表中全部元组，删除是表中的数据，而不是表的定义。使用 IN(…) 嵌套子查询删除数据 DQL 数据查询语法使用 SELECT 语句做查询。只做查询，不做修改。一般格式： SELECT [ALL | DISTINCT] &lt;目标列查询&gt; FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; GROUP BY &lt;列名&gt; HAVING &lt;条件表达式&gt; OPDER BY &lt;列名&gt; [ASC | DESC]; 查询所有列 SELECT * FROM &lt;表名&gt; 查询指定列 SELECT 列1，列2，... FROM &lt;表名&gt; 条件查询 SELECT * FROM &lt;表名&gt; WHERE 列名=指定值 模糊查询 SELECT * FROM 表名 WHERE 列名 LIKE ‘张_’;(_代表匹配任意一个字符，％代表匹配0～n个任意字符)。 ORDER BY: 根据某个字段进行升序或者降序排列 ASC 升序 DESC 降序 OPDER BY: 根据表中的某个字段进行分组，即将含有相同字段值的记录放在一组，不同的放在不同组。 WHERE 与 HAVING 区别：作用对象不同，WHERE作用于基本表或试图,不可使用聚集函数。HAVING作用于组。聚集函数 COUNT(*) 统计元祖个数 COUNT([DISTINCT | ALL] &lt;列名&gt;) 统计一列 值的个数 SUM([DISTINCT | ALL] &lt;列名&gt;) 总和 AVG([DISTINCT | ALL] &lt;列名&gt;) 平均值 MAX([DISTINCT | ALL] &lt;列名&gt;) 最大值 MIN([DISTINCT | ALL] &lt;列名&gt;) 最小值 DCL 数据控制语法该语言用来定义访问权限，理解即可，以后不会多用。需要记住的是，一个项目创建一个用户，一个项目对应的数据库只有一个。这个用户只能对这个数据库有权限，其它数据库该用户就操作不了。 创建用户 CREATE USER [WITH][DBA | RESOURCE | CONNECT]默认权限：CONNECT,该权限不能创建新用户，不能创建模式，不能创建表，只能登陆数据库RESOURCT: 可以创建基本表和视图DBA: 拥有对所有数据库对象的存取权限 给用户授权语法:GRANT 权限1，…，权限n ON 数据库.* TO 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。 撤销授权语法:REVOKE 权限1，…，权限n ON 数据库.* FROM 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1.* form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。 查看权限查看指定用户的权限:SHOW GRANTS FOR 用户名@ip地址； 删除用户DROP USER 用户名@ip地址；]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F04%2F29%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程(Thread) 独立的线程，独立的执行空间，在JAVA中属于类。操作系统中每一个进程至少存在一个进程，当JAVA程序启动时，就会产生一个进程，该进程默认建立一个线程。线程就是进程中的一个单一的顺序控制流， Runnable接口 Runnable是一个接口，只有一个方法 public void run()。 代码实现public class MyRunnable implements Runnable { public void run() { System.out.println(&quot;MyThread!&quot;); } } class Threadstart { public static void main(String[] args) { MyRunnable thread = new MyRunnable(); Thread myThread = new Thread(thread); myThread.start(); System.out.println(&quot;Back!&quot;); } } 一旦线程进入可执行状态，它会在可执行与执行中两种状态中来来去去，也有另一种状态：暂时不可执行（堵塞状态）。 线程启动 要实现Runnable 接口，把Runnable传给Thread的构造函数才能启动新线程，线程初始化后没有调用start()之前一直处于建立状态，有时候线程会因为某些原因被堵塞。 线程调度器 会决定哪个线程从等待状态挑选出来,何时把某个线程送回等待执行状态.它会决定某个线程运行多久。无法去控制调度，它是不确定，不同的JAVA虚拟机上面做法不同。调度不能保证任何执行时间和顺序，不能期待它完全平均分配执行，可以用sleep()来保证时间。 sleep() 确保线程能够有机会执行的最好方式让它周期性去睡一下，调用sleep()这个方法，传入时间单位是毫秒 Thread.sleep(2000);休息两秒醒来进入可执行状态。这个方法可能抛出异常InterruptedException异常，所有对它的调用必须在try/catch块中。 代码实现try { Thread.sleep(2000); }catch(InterruptedException e) { e.printStackTrace(); } 但是线程也不一定在醒来后马上变成执行状态，只能确定它会回到执行状态，何时执行取决于调用器。 线程名字Thread th1 = new Thread(); Thread th2 = new Thread(); th1.setName(&quot;thread1&quot;); th2.setName(&quot;thread2&quot;); Thread.currentThread().getName() //读当前线程名字 线程缺点线程会产生并发性，并发性问题会引发竞争状态，竞争状态会引发数据的损毁。来自可能发生的一种状况：两个或者两个以上线程存取一个对象的数据。两个或者两个以上不同执行空间上的方法对同一个对象进行存取。解决此问题方法是需要给线程上锁。synchronized关键字代表线程需要一个钥匙来存取被同步化的线程。锁的不是数据，是存取数据的方法。一个锁只有一把钥匙，没有完成同步化方法不会释放钥匙，其他线程也进不去。但是在上锁的状态下也会引发其他问题，比如死锁。 死锁 同步化的方法会让你的程序因为要同步并行的问题而慢下来,导致死锁状态。死锁： 线程 A 进入 one 对象同步化方法，线程 A 睡， B 进入 two 对象同步化方法，线程 B 要进入 one 对象，此时正在执行 A ,拿不到钥匙，线程 B 等待，线程 A 醒来要进入 tow 对象，线程 B 正在执行，拿不到钥匙，线程 A 等待。线程 A 等待线程 B 的钥匙，线程 B 等待线程 A 的钥匙，拿着对方的钥匙，死锁。 死锁原因 互斥条件：资源不能被共享，只有一个线程执行。 请求与保持：一个线程持有一个资源并且正在等待获取一个当前正在执行的线程持有的资源。 资源任务不能被抢占：一个线程获取到一个资源，系统不强行收回，只能等线程自己释放。 循环等待：线程形成一个环链，每个都想先得到上一个的任务资源。 四个原因同时存在就会产生死锁，只要破坏其一就会避免死锁。死锁产生前三个是必要条件，解决死锁问题最容易的方法是破坏第四个条件。添加判断条件。 如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程。 如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类]]></title>
    <url>%2F2018%2F04%2F24%2F%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[泛型 jdk1.5出现的安全机制，避免强制转换。&lt;&gt;当操作应用类型不确定时应用，确定应用类型传入即可。确保类型安全（它的出现不单单确保类型安全）。运行时会将泛型去掉生成class文件不带泛型，为兼容运行类的加载器。 集合概述 集合按照其存储方式可分为两大类，单集合Collection，双集合Map. Cokkection: 单列集合用于存储一系列符合某种规则的元素，两个重要子接口，List 和 Set。List特点是元素有序，元素可重复。Set特点是元素无序且不可重复。List 实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet 和 TreeSet。Map： 双列集合用于存储具有键（Key）和值（Value）映射关系元素，每个元素都包含一对键值对。使用时可用一个Key找出其对应的Value。Map主要实现类有HashMap 和 TreeMap。 List 接口 List 接口继承自Collection接口，是单列集合重要分支。容许存储元素重复，通过索引访问集合中指定元素。存储元素有序，元素存入顺序和取出顺序一致。常用方法 void add（int index，Object element） 将元素element插入在集合的index处 boolean addAll（int index，Collection c) 将集合c所包含的元素插入到List集合的index处 Object get(int index) 返回集合索引index处的元素 Object remove(int index) 删除index索引处元素 Object set(int index,Object element) 将索引indext处元素换成element对象，并将替换后的元素返回 int indexOf(Object o) 返回对象o在List集合中出现的位置索引 int lastIndexO(Object o) 返回对象o在List集合中最后一次出现的位置索引 List subList(int fromIndex,int toIndex) 返回从索引fromINdex(包括)到toIndex(不包括)处所有元素集合组成的子集合asList() List asList(数组) 将数组转到集合，可以使用集合方法操作数组，数组长度时固定的，集合的增删方法不可用。ArrayList ArrayList是List接口实现类，内部封装了一个长度可变的数组对象，存入元素超出数组长度时，会在内存中分配一个更大的数组存储这些元素。ArrayList可看做一个长度可变的数组对象。底层是使用数组来保存元素，在进行增加删除时，会导致创建新数组，效率比较低，不适合做大量的增删操作。但是索引做查找元素很便捷。存取操作 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); System.out.println(&quot;长度&quot;+it.size()); System.out.println(&quot;第2个元素&quot;+it.get(1)); it.remove(1); it.set(0,&quot;e&quot;); System.out.println(it.subList(0,2)); }LinkedList 为了解决ArrayList增删的效率低问题，提供了LinkedList实现类，该集合内部维护了一个双向循环链表。可以实现栈的所有功能和方法，可以把LinkedList作为栈使用。常用方法 void add(int index,E element) 在指定位置加入指定元素 void addFirst（Object o) 将指定元素插入到开头 void addLast(Object o) 将指定元素插入到结尾 Object getFirst() 返回此列表的第一个元素 Object getLast() 返回此列表的最后一个元素 Object removeFrist() 移除并返回此列表第一个元素 Object removeLast() 移除并返回此列表最后一个元素方法使用 public static void main(String[] args) {LinkedList it = new LinkedList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); it.add(1,&quot;dd&quot;); it.addFirst(&quot;ee&quot;); it.removeFirst(); }迭代器 接口Iterator与Collection，Map不同，Collection与Map用于存储元素，Iterator主要用于迭代访问（遍历）Collection中元素，迭代器。Iterator代码实现 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); Iterator i = it.Iterator(); //获取Iterator对象 while(i.hasNext) //判断ArrayList是否存在下一个元苏 { Object obj = it.next(); //取ArrayList集合中元素 System.out.println(obj); } } 迭代器获取ArrayList集合中元素，都会将这些元素当做Object类型来看待，如果想得到特定类型，需要进行强制类型转换。使用迭代器进行迭代时， 如果用集合对象调用remove()方法去删除元素，会出现异常。 集合对象remove()解决方法 第一种：添加break,找到删除，跳出循环停止迭代。 if(“aa”.equals(obj)) { it.remove(); break; } 第二种：用迭代器remove()方法，对于迭代器本身是可预知的。 if(&quot;aa&quot;.equals(obj)) { i.remove(); } 调用remove()必须先调用next()。ListIterator 继承于Iterator类，在父类基础上添加逆向迭代，ListIterator迭代器只能用于List集合中。常用方法 void add(Object o) 将元素插入列表 booleadn hasPrevious() 逆向遍历列表，列表有多个元素，返回true Object previous() 返回列表前一个元素 void remove() 从列表中移除由next或previous返回的最后一个元素逆向迭代代码实现 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); ListIterator i = it.listIterator(it.size());//获取Iterator对象 while(i.hasPrevious) //判断ArrayList是否存在下一个元苏 { Object obj = it.previous(); //取ArrayList集合中元素 System.out.println(obj); } }foreach循环代码实现 foreach(容器中元素类型 临时变量 : 容器容量) {...... } jdk5.0新特性，主要应用于数组。相比Iterator遍历，它的写法简单。foreach循环的次数由容器中个数决定。局限是进行foreach循环只能访问元素，不可以对元素进行修改。 Enumeration接口 在JDK1.2以前还没有Iterator接口时候，遍历集合需要使用Enumeration接口，于Iterator方法类似。集合Vector是List接口的一个实现类，用法与ArrayList完全相同。Vector集合是线程安全的，ArrayList是线程不安全的。在Vector提供一个elements()方法用于返回Enumeration对象，通过Enumeration对象来遍历集合中的元素。代码实现 public static void main(String[] args) {Vertor v = new Vector(); v.add(&quot;aa&quot;); v.add(&quot;bb&quot;); Enumeration en = v.elements(); whoile(en.hasMoreElements) { Object obj - en.nextElement(); System.out.println(obj); } }Set 接口 继承于Collection。Set接口存入元素是无序，不可存入重复元素。主要有俩个实现类HashSet和TreeSet。HashSet是根据哈希值确定元素在集合中的存储位置，具有良好的存取和查找功能。TreeSet是根据二叉树的方式来存储元素，可以对元素集合进行排序。HashSet集合 存储元素无序并且不可重复。存元素是先调用hashCode()确定元素位置，再调用equals()来完成对象的唯一性。如果hashCode()值不同，不用判断，直接存到哈希表。如果hashCode()值相同，判断equals(),true视为相同元素，不存。false视为不同元素，存。必须覆盖hashCode()和equals()HashSet代码实现 public static void main(String[] args) {HashSet h = new HashSet(); h.add(&quot;aa&quot;); h.add(&quot;bb&quot;); Iterator it = h.iterator; while(it.hasNext()) { Object obj = it.next(); System.out.println(obj); } }重写覆盖hashCode()和equals() public int hashCode() //重写hashCode {return x.hasCode(); } public boolean equals(Object obj) //重写equals {if(this == obj) //判断是否为同一对象 { return true; } if(!(obj instanceof S)) //判断是否为S类型 { return false; } S s = (S)obj; //将对象强转S boolean b = this.x.equals(s.x); return b; } TreeSet 利用二叉树存储元素，可以排序，保证没有重复元素。TreeSet利用的是自平衡的排序二叉树。 集合中元素进行排序比较时，会调用compareTo()方法，该方法在Comparable接口中定义。要对集合元素排序就必须实现Comparable接口。Student(name,age)类型对象排序比较需要重写compareTo() public int compareTo(Object obj) //重写compareTo() {Student stu = (Student)obj; if(this.age-stu.age&gt;age) //判断年龄 { return 1; //1存 -1不存 } if(this.age-stu.age==0) { return this.name.compareTo(stu.name); //年龄相同再对名字比较 } return -1; }Map 接口 双列集合，存储每个对象都是一个键值对，一个键(key)和一个值(value),存在的关系是映射。访问时只要找到键(key),就可以找到对应的值(value)。必须保持键(key)的唯一性。常用方法 void put(Object key,Object value) 将值与映射关系中的指定键关联（存） Object get(Object key) 返回映射关系的值，如果不包含返回null（取） boolean containsKey(Object key) 判断指定键(key)关系的映射值（判断） boolean containsValue(Object value) 此映射将一个或多个键映射到指定值（判断） Set keySet() 返回此映射中包含键的Set视图 Collectionvalues 返回此映射中包含值得Collection视图 Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet 返回此映射中包含的映射关系的Set视图HashMap Map接口一个实现类，基于哈希表。如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，那么它必须在外部进行同步。如果存入相同的键(key),后存储的值将覆盖原有的值。键相同，值覆盖。最快的查找技术。常用方法TreeMap Map接口一个实现类，基于二叉树。TreeMap所有键是按照某种顺序排列。常用方法 int size() 返回集合中键(key)映射值的数量 void clear() 删除所有键的映射关系 void comparator() 比较器TreeSet迭代 public static void main(Stringp[] args) {TreeSet tm = new TreeSet(); tm.put(&quot;1&quot;,&quot;aa&quot;); tm.put(&quot;2&quot;,&quot;bb&quot;); Set keySet = tm.keySet(); Iterator it = it.iterator(); while(it.hasNext()) { Object key = it.next(); Object value = it.get(key); System.out.println(key+&quot;,&quot;+value); } }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
