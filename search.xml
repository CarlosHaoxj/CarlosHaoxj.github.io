<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[距2020还有200天]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%B7%9D2020%E8%BF%98%E6%9C%89200%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[200时间在一天天的过，如果不用数据来做标注，并不会感到时间流逝，今天早晨起床看到手机一条推送距2020还有200天，本来还睡眼惺忪的我一下子变清醒许多，想到接下来要面对的和最近看到的事。这段时间学长学姐为毕业做各个方面的准备，似乎也能看到一年后的自己是一个什么样的状态，毕业设计，毕业论文，同学朋友各自选择远方，还有许许多多都需要在需要去经历。最重要的是那时候的毕业将不在是学生的身份，换一个身份去迎接挑战。这些是一年后的事情，这时候不是重点。现在的我需要掌握好学生的这样一个身份，最最重要的是接下来的找工作，刚过去不久的春招，去试了试水，被教训的很惨，对 “机会是留给有准备的人” 认识深刻，虽说3月份的找工作是失败的，但在过程中明显发现自己的不足，太多的知识点模糊不清，大多在犹豫中说出，这样的状态，太差劲。还需要更深一步的学习，做到与他人聊到知识点能从一个点，到一条线，一个面。还是那句话，对整个行业技术重要的不是广度，是深度。接下来全身心的投入秋招准备，必须打消春招浑水摸鱼的状态。 没有硬学历，只有变的更强大才有选择工作的权利。比你优秀的人比你还要努力的人比比皆是，总会有这样标题的文章出现在你的眼前，最初还是会点开，看看大佬是如何保持，逐渐的开始忽略。点开看一个远方陌生人的鸡汤文，不如不看，做些自己该去做的事情。 这学期来天津这边，能感受到自己的改变，或许是离开父母身边出来上学，这几年的情感逐渐积累。每个月往家里的电话在增多，更多的与父母和长辈交流，一日三餐，生活点滴的问候，每次通完话都会沉默一阵，梳理自己的情感。相距一千多公里，父母不易，尽自己最大的努力让父母放心。2019年最大任务就是自己有能力解决温饱问题，而不是依靠父母的生活费。 希望接下来遇到的事情，都要返回状态码 200 2019/6/15 天津]]></content>
      <categories>
        <category>长路漫漫</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter_爬虫]]></title>
    <url>%2F2019%2F05%2F10%2FJupyter-%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[安装 miniconda1234mkdir minicodndacd minicodndawget https://repo.continuum.io/archive/Anaconda3-4.4.0-Linux-x86_64.shbash Anaconda3-4.4.0-Linux-x86_64.sh 升级 conda upgrade conda 创建虚拟环境conda create -n jupyter python=3.7 -y 激活 conda activate jupyter 取消 conda deactivate pip install jupyter 查看版本 python –version pip –version jupyter –version通过远程方式访问 jupyter notebook 测试 jupyter生成配置文件 jupyter notebook –generate-config如果出现提示-allow-root，请在之前的命令后面加 –allow-rootjupyter notebook –generate-config –allow-root 打开ipython，创建一个登录jupyter的密码1234567[root@localhost ~]# ipythonIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: Out[2]: 'sha1:5311cd8b9da9:70dd3321fccb5b5d77e66080a5d3d943ab9752b4'In [3]:exit 其中记录下Out[2]里的：sha1:5311cd8b9da9:70dd3321fccb5b5d77e66080a5d3d943ab9752b4 修改jupyper配置文件12345678vi /root/.jupyter/jupyter_notebook_config.py 或者 vi ~/.jupyter/jupyter_notebook_config.py 在文件中添加以下的参数： c.NotebookApp.ip='*' c.NotebookApp.password = u'sha1:5311cd8b9da9:70dd3321fccb5b5d77e66080a5d3d943ab9752b4' c.NotebookApp.open_browser = False c.NotebookApp.port =8888 #随便指定一个端口，使用默认8888也可以 进行后台运行，&amp; 该终端不影响该端口任务nohup jupyter notebook --ip=0.0.0.0 --no-browser --allow-root &amp; 或者 &gt;/dev/null 2&gt;&amp;1 关掉 jupyter 内核 pkill jupyter pip3 install ipython brew install jupyter]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云基本配置]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[阿里云基本配置服务器系统镜像为 CentOS_7.3，安装 MySQL 5.7 安装 yum repo MySQL 官网下载 yum repo 配置文件 wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm repo 安装 rpm -ivh mysql57-community-release-el7-9.noarch.rpm 安装 MySQL; 安装:yum install mysql-server 启动:systemctl start mysqld 查看:systemctl status mysqld 配置 MySQL，使用命令查看安装时的临时密码grep &#39;temporary password&#39; /var/log/mysqld.log;如果没有找到，输入命令 rm -rf /var/lib/mysql，删除 MySQL 残留数据；再次启动 MySQL 输入命令 mysql_secure_installation；设置安全选项，执行命令后的依次完成一下操作 Enter current password for root (enter for none): 输入当前root密码(没有输入) Set root password? [Y/n] 设置root密码?(是/否) New password: 输入新root密码 Re-enter new password: 确认输入root密码 Password updated successfully! 密码更新成功 Remove anonymous users? [Y/n] 删除匿名用户?(是/否) Disallow root login remotely? [Y/n] 不允许root登录远程?(是/否) Reload privilege tables now? [Y/n] 现在重新加载权限表(是/否) 使用 mysql -u root -p，输入上一个操作设置的密码登录 MySQL MySQL 相关设置 systemctl stop mysqld 关闭MySQL systemctl restart mysqld 重启MySQL systemctl status mysqld 查看MySQL运行状态 systemctl enable mysqld 设置开机启动 systemctl disable mysqld 关闭开机启动 配置默认编码 12345vi /etc/my.cnf#添加[mysqld]character_set_server=utf8init_connect='SET NAMES utf8' 相关文件路径 1234配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid 容许用户远程登录 MySQL 12345mysql -u root -pvmwaremysql&gt;use mysql;mysql&gt;update user set host = '%' where user = 'root';mysql&gt;select host, user from user; 安装 NginxNginx (发音为[engine x])专为性能优化而开发，其最知名的优点是它的稳定性和低系统资源消耗，以及对并发连接的高处理能力(单台物理服务器可支持30000～50000个并发连接)， 是一个高性能的 HTTP 和反向代理服务器，也是一个IMAP/POP3/SMTP 代理服。 安装前准备 gcc 安装 yum -y install gcc-c++ pcre 安装 yum -y install pcre pcre-devel PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。 zlib 安装 yum -y install zlib zlib-develzlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 OpenSSL 安装 yum -y install openssl openssl-develOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 Nginx 安装版本链接Nginx 使用 wget 命令下载，如：wget -c https://nginx.org/download/nginx-1.12.2.tar.gz 解压到当前文件夹，路径自己选择 新建 nginx 用户和组 123groupadd nginxuseradd -g nginx -d /home/nginx nginxpasswd nginx 创建安装目录 mkdir -p /usr/local/nginx 创建数据存放目录 mkdir -p /data/web 为用户 nginx 赋权 chown -R nginx:nginx /data/web 编译安装 cd nginx-1.12.1 输入以下参数 123456789./configure \--prefix=/usr/local/nginx \--without-http_memcached_module \--user=nginx \--group=nginx \--with-http_stub_status_module \--with-http_ssl_module \--with-http_gzip_static_module 成功编译打印 123456789101112131415161718Configuration summary + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: "/usr/local/nginx" nginx binary file: "/usr/local/nginx/sbin/nginx" nginx modules path: "/usr/local/nginx/modules" nginx configuration prefix: "/usr/local/nginx/conf" nginx configuration file: "/usr/local/nginx/conf/nginx.conf" nginx pid file: "/usr/local/nginx/logs/nginx.pid" nginx error log file: "/usr/local/nginx/logs/error.log" nginx http access log file: "/usr/local/nginx/logs/access.log" nginx http client request body temporary files: "client_body_temp" nginx http proxy temporary files: "proxy_temp" nginx http fastcgi temporary files: "fastcgi_temp" nginx http uwsgi temporary files: "uwsgi_temp" nginx http scgi temporary files: "scgi_temp" 安装 make &amp;&amp; make install 常用命令 启动： nginx 停止： systemctl stop nginx.service 重启： systemctl restart nginx.service 检查语法： nginx -t 动态加载： nginx -s reload 开机启动： systemctl enable nginx.service 如果提示：Job for nginx.service failed because the control process exited with error code. See “systemctl status nginx.service” and “journalctl -xe” for details. 先使用 netstat -tnlp 找到 nginx 进程，kill -9 nginx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-存储引擎]]></title>
    <url>%2F2019%2F04%2F06%2FMySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[MySQL-存储引擎在关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。在开发中，可以根据不同表的需求来指定对应的存储引擎（例如根据查询，增删的操作次数来区别）；MySQL 可以根据存储环境的不同灵活使用最优的存储引擎 输入 show engines: 查看版本对应的存储引擎 输入 ：CREATE TABLE table_name(...)ENGINE = InnoDB/MyISAM DEFAULT CHARSET=gbk 创建表时可以指定相应的存储引擎 输入 show create table tableName 查看创建表对应的存储引擎 输入 ALTER TABLE tablename engine = (InnoDB) 可以改变表的存储引擎 InnoDB5.5 版本之后的默认存储引擎；为事务存储引擎 提供对数据库的 ACID 事务的支持，实现标准四种隔离级别 具有回滚和奔溃恢复能力的事务安全 提供对数据库 ACID 事务支持，实现四个标准隔离级别 处理大容量的数据库系统，MySQL 运行时，InnoDB 在内存中建立缓冲池，用于缓冲数据和索引 MySQL 中支持外健只有 InnoDB 不支持 FULLTEXT 全文索引 存储格式存储表和索引主要有两种方式：共享空间存储；多表（单独）空间存储 共享空间存储输入show variables like &#39;innodb_data%&#39; 查看存储方式 12345678mysql&gt; show variables like 'innodb_data%';+-----------------------+------------------------+| Variable_name | Value |+-----------------------+------------------------+| innodb_data_file_path | ibdata1:12M:autoextend || innodb_data_home_dir | |+-----------------------+------------------------+2 rows in set 表与表结构保存在 .frm 文件中（与引擎无关），数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 表空间中，可以是多个文件，MySQL 默认存储方式默认表空间为 ibdata1, 初始值为 12M表空间可以有多个文件组成，所以其大小限制不受文件大小的限制，而是受其自身的限制 多表（空间）存储 表与表结构保存在 .frm 文件中，表的数据与索引放在 .ibd 中 多表空间参数数据文件没有大小限制，不需要设置出事大小，也不需要设置文件的最大限制、扩展参数等 可以方便进行单表备份与恢复，直接复制 .ibd 文件不可行，因为没有共享空间的数据字典信息 应用场景 对可靠性要求高（事务） 表更新查询较频繁 有效解决灾难问题 (日志 + 事务回滚) MyISAM5.5 之前版本默认存储引擎；不支持事务、外键 每个 MyISAM 存储三个文件 .frm : 表定义 .myd : 数据 .myi : 索引 可指定索引文件和数据文件的位置，不同 MyISAM 表的索引文件和数据文件可放在不同位置；通过 DAT DIRECTORY 和 INDEX DIRECTORY 提供修复工具，可使用 CHECK TABLE 检查健康；REPAIR TABLE 修复一个损坏的表 只有 MyISAM 支持全文索引 存储格式静态表（默认）每个记录固定长度，不包含可变长度列 优点：存储迅速，容易修复 缺点：比动态表占用空间大；使用空格补足数据，空格访问不可见动态表每个记录不固定长度，包含可变字段 优点：占用空间少 缺点：频繁更新删除产生空间碎片，需要使用 OPTIMIZE TABLE tablename 或 myisamchk -r 改善性能压缩表由myisampack工具创建的，占用非常小的磁盘空间，因为每个记录都会被单独压缩应用场景 无事务 只读类应用（插入不频繁，查询非常频繁） 空间类应用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-索引]]></title>
    <url>%2F2019%2F04%2F05%2FMySQL-%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[MySQL-索引索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据庞大时，索引可以加快查询速度。使用索引后，查询某一行数据不需要扫描全表来定位，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据索引是在存储引擎层实现，不是在服务器层实现，不同存储引擎具有不同索引类型和实现（InnoDB, MyISAM） 使用场景 对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效 对于中到大型的表，索引非常有效 对于特大型的表，建立和维护索引的代价将会随之增长，这种情况下需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录去匹配 索引的使用创建索引创建表时加入索引 12345CREATE TABLE table( ID INT NOT NULL, username VARCHAR(20) NOT NULL, INDEX [indexName] (username(length))); 创建表后加入索引 123ALTER TABLE table ADD [UNIQUE] INDEX index_name(column_name);或CREATE INDEX index_name ON table(column_name); 索引需要占用磁盘空间，创建索引时需要考虑磁盘空间是否足够 床架索引需要对表加锁，实际操作中需要在业务空闲期进行 根据索引查询1234567891011121314151617181920具体查询：SELECT * FROM table_name WHERE column_1=column_2;(为column_1建立了索引) 或者模糊查询SELECT * FROM table_name WHERE column_1 LIKE '%三'SELECT * FROM table_name WHERE column_1 LIKE '三%'SELECT * FROM table_name WHERE column_1 LIKE '%三%' SELECT * FROM table_name WHERE column_1 LIKE '_好_' 如果要表示在字符串中既有A又有B，那么查询语句为：SELECT * FROM table_name WHERE column_1 LIKE '%A%' AND column_1 LIKE '%B%'; SELECT * FROM table_name WHERE column_1 LIKE '[张李王]三'; //表示column_1中有匹配张三、李三、王三的都可以SELECT * FROM table_name WHERE column_1 LIKE '[^张李王]三'; //表示column_1中有匹配除了张三、李三、王三的其他三都可以 //在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示其中的某一个字符；[^]表示除了其中的字符的所有字符 或者在全文索引中模糊查询SELECT * FROM table_name WHERE MATCH(content) AGAINST('word1','word2',...); 删除索引123DROP INDEX my_index ON tablename;或ALTER TABLE table_name DROP INDEX index_name; 检查索引查看表中的索引 1SHOW INDEX FROM tablename 查看查询语句使用索引情况 12// explain 加查询语句explain SELECT * FROM table_name WHERE column_1 = '123'; 索引实现索引能让数据库查询速度上升，而使写入速度下降。原因是平衡树的数据结构一直保持一个正确的状态，增删改都会改变节点中索引数据内容。因此每次改变数据，DBMS 必须重新梳理树的结构，来保证数据的正确性。（索引查询意以外的副作用） 索引是在存储引擎层实现，所以不同存储引擎有不同的索引类型和实现 B Tree平衡多路查找树，命中即返回，有时不需要找到最终的叶子节点。首先在根节点进行二分查找，如果找打则返回对应节点 value ，否则在相应区间的指针指向的节点进行递归查找 插入，修改和删除的操作会破坏 B Tree 的结构，当执行上述操作时，需要对树进行一个分裂，合并，旋转等操作来保持 B Tree 特性 规定： 全部叶子节点在相同高度 每个节点有 m 个孩子 除根节点以外的其他每个节点至少有 Ceil(m / 2) 个孩子 非叶子节点都是 [key, value] 键值对 （key 作为索引的键 value 键值所在行数据） 若根节点不是叶子节点，至少有俩个孩子 B+ TreeIO 稳定，一定会找打叶子节点，非叶子节点不存储数据内容，只存相应键值。InnoDB （MySQL 5.5 之后版本的默认存储引擎） 存储引擎使用 B+ Tree 实现其索引结构 不需要进行全表扫描，只需要对树进行搜索即可 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。 规定： 叶子节点不存储指针 非叶子节点只存储键值信息 兄弟叶子节点，左指向右（范围查询需求） B Tree 与 B+ Tree 区别 存储位置不同，B+ Tree 中数据存储在叶子节点上，B Tree 数据存储在每一个节点中 关键字数量不同，B+ Tree 中有 m 个关键字，其叶子节点也有 m 个；B Tree 中有 m 个关键字，有 m + 1 个节点 查询方式不同，B+ Tree 找到最后的叶子节点；B Tree 找到数据即结束查询 分支节点构造不同，B+ Tree 分支节点仅仅存储着关键字信息和儿子的指针；B Tree 分支节点存储着关键字信息，数据 哈希索引只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。 内部数据结是哈希表，它会为索引中的每一列对应的值计算一个哈希值，存放在哈希表中，用于精确匹配 优点是时间复杂度位 O(1) 基于哈希算法 缺点是只能进行完全匹配，无法做范围查询 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键字，而不是直接比较是否相等。查找条件使用 MATCH AGAINST 为不实普通的 WHERE；仅可用于 MyISAM 和 InnoDB 存储引擎。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类加载器]]></title>
    <url>%2F2019%2F03%2F20%2FJVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载器在加载阶段中，通过一个类的全限定名来获取描述此类的二进制字节流。类加载器只用来实现类的加载动作，对于任意一个类，都需要由加载它的类加载器和这个类的本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间。判断俩个类是否 “相等”，只有这俩个类由同一个类加载器加载的前提下才有意义，即使俩个类来源于同一个 Class 文件，但是由不同的类加载器加载，拿这俩个类必定不相同 相等的判断条件：代表类的 Class 对象的 equals(), isAssignableFrom() 和 isInstance() 方法的返回结果 双亲委派模型从 Java 虚拟机角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 实现，是虚拟机自身的一部分；另一种是所有其他类加载器，由 Java 实现，独立于虚拟机外部，全部继承自抽象类 java.lang.ClassLoader 启动类加载器（Bootstrap ClassLoader）该类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且被虚拟机所识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用。 扩展类加载器（Extension ClassLoader）这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 &lt;JAVA_HOME&gt;\lib\ext 目录中的，或者将被 java.ext.dirs 系统变量所指定的的路径中所有库，开发者可以直接使用扩展类加载器 应用程序类加载器 (Application ClassLoader)这个加载器由 sun.misc.Launcher$App-ClassLoader 实现，由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，一般称为系统类加载器。负责加载用户路径 (ClassPath) 上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器 应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器，相互关系为 图中展现的关系层次称为双亲委派模型 (Parents Delegation Model)，该模型要求除了顶层加载器以外，其他的类加载器都要有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承关系来实现，而是使用组合关系来复用父加载器的代码 工作过程：如果一个类加载器收到一个类加载请求，则该类加载器不会去加载这个类，而是将这个请求委派给父类加载器，每一层加载器都是如此，所有加载请求都应传送给顶层启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求（搜索范围内没有找到所需的类），子类加载器才会尝试自己去加载 重点流程： 子类先委托父类加载 父类加载器有自己的加载范围，范围内没有找到，返回给子类 子类只有收到父类无法加载，才会自己去加载 破坏双亲委派模型(遇到问题，理解后补充) 以上内容参考自 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类加载机制]]></title>
    <url>%2F2019%2F03%2F17%2FJVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类加载机制 概述：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机类加载机制。 类加载的时机类从加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。 主要分为三个阶段，加载、连接和初始化。其中连接包括验证、准备和解析。三个阶段都是在程序运行期间完成。其中加载、验证、准备、初始化和卸载，这五个阶段的顺序是可确定的。解析不确定，某些情况下解析会在初始化之后进行。 五种情况虚拟机规范严格规定有且只有以下五种情况必须对类进行初始化。（加载、验证、准备需在此之前开始） 遇到 new, getstatic, putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行初始化，需要先触发其初始化。生成 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（被 final 修饰，在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包进行反射调用的时候，如果类没有进行初始化，需要先触发初始化。 当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当模拟器启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机先会初始化这个类。 当时用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invole.MethodHandle 实例最后解析结果 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。 这五种情况的行为称为对一个类进行主动引用，除此之外，所有引用类的方法都不会触发初始化，称为被动引用。 五个阶段整个类加载过程分为五个阶段，加载、验证、准备、解析和初始化。 加载是类加载的一个阶段，在此阶段虚拟机需要完成三件事： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口 非数组该阶段开发人员可控。非数组类的加载阶段（加载阶段获取类的二进制字节流的动作），该阶段既可以使用系统提供的引导类加载来完成，也可以由用户自定义的类加载器去完成（重写一个类加载器的 loadClass() 方法）。 数组数组类本身不通过类加载器来创建，它是由 Java 虚拟机直接创建。与类加载器还有一定关系，数组类的元素类型还是要由类加载器最终去创建。数组类创建过程遵循以下规则： 如果数组的组件类型（Component Type, 指数组去掉一个维度的类型）为引用类型，那就递归采用加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识 如果数组的组件类型不是引用类型（如 int[] 数组），Java 虚拟机将会把数组标记为与引导类加载器关联 数组类的可见性与它的组件类型可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为 public 加载阶段完成后，虚拟机外部的二进制字节流将按照虚拟机所需要的格式存储在方法区内 验证 目的： 为了确保 Class 文件的字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身的安全。 如果虚拟机不检查输入的字节流，对其完全信任，很可能会因为载入了有害的字节流而导致系统奔溃，所以验证时虚拟机对自身保护的一项重要工作 文件格式验证验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚拟机进行处理。该阶段主要目的是保证输入的字节流能够被正确的解析并存储到方法区之内，格式上符合描述一个 Java 类型信息的要求。该阶段验证是基于二进制字节流进行，只有通过这个阶段的验证，字节流才会进入内存方法区内存储，所以后面三个验证都是基于方法区的存储结构进行的，不会直接操作字节流。 元数据验证对字节码描述信息进行语义分析，以保证所描述的信息符合 Java 语言规范的要求。 字节码验证通过对数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二个阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如: java.lang.IllegalAccessErrot, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等 对虚拟机类加载机制来说，验证阶段是一个非常重要的，但不是一定必要的（对程序运行期没有影响）的阶段，如果所运行的全部代码都已经被反复使用和验证过，那么实施阶段就可考虑使用 -Xverify:none 参数来关闭大部分的验证措施，以缩短虚拟机类加载的时间 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存将在方法区中进行分配。 这里进行内存分配的仅包括类变量（被 static 所修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到 Java 堆中 准备阶段的初始值是指数据类型的零值 例如 public static int value = 123， 该条语句在准备阶段不会对 value 赋值为 123，而是赋值为 0。赋值为 123 的动作将会在初始化阶段执行。 基本数据类型零值 数据类型 零值 数据类型 零值 int 0 short (short)0 long 0L char ‘/u0000’ byte (byte)0 boolean false float 0.0f double 0.0d reference null 通常情况下在该阶段会将变量值赋值为零，但是在一些特殊情况下，会将变量值赋值为指定大小。如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 将会被初始化为 ConstantVlaue 属性所指定的值，例： public static final int value = 123; 在编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段将会更具 ConstantValue 的设置将 value 赋值为 123 解析该阶段是将虚拟机常量池中符号引用替换为直接引用的过程 符号引用：以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现内存布局可以各不相同，但是他们能接受的符号引用必须都是一致，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中 直接引用：可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中 七种解析类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 类或接口假设当前代码处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，虚拟机要完成整个解析过程需要三个步骤： 如果 C 不是一个数组类型，虚拟机将会把代表 N 的全限定名床底给 D 的类加载器区加载这个类 C 。在加载过程中，由于原数据验证，字节码验证的需要，又有可能触发其他相关类的加载动作，例如加载这个类的父类或实现接口。一旦这个加载过程中出现任何异常，解析过程失败 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会类似 “Ljava/lang/Integer” 的形式，将会按照低一点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型是 “java.lang.Integer”， 接着由虚拟机生成一个代表此数组维度和元素的数组对象 如果上面的步骤没有出现异常，那么 C 在虚拟机中实际上已经成为了一个有效的类或接口了，但在解析完成之前还需要进行符号引用验证，确认 D 是否具备对 C 的访问权限，如果发现不具备访问权限，抛出 “java.lang.IllegalAccessError” 异常 字段在类或接口的解析过程中无发现异常，进行下一个过程，字段解析。这个字段所属类或接口使用 C 来表示。第一步需要对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口解析 如果 C 本身就包含了简单名称和字段描述符都与目标相匹配字段，则返回这个字段的直接引用，查找结束 否则，如果 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，返回这个字段的直接引用，查找结束 否则，如果 C 不是 java.lang.Object，将会按照继承关系从下往上递归搜索其父类，如果类中包含了简单名称和字段描述符都与目标相匹配字段，返回这个字段的直接引用，查找结束 否则，查找失败，抛出 java.lang.NoSuchFieldError 异常 如果在查找过程中返回引用，将会对这个字段进行权限验证，如果不具备对这个字段的访问权限，抛出 java.lang.IllegalAccessError 异常 类方法需要先解析出类方法表的 class_index 项中索引的方法所属的类或接口的符号引用，如果解析成功，使用 C 表示这个类 类方法或接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index 中索引 C 是一个接口，直接抛出 java.lang.IncompatibleClassChangeError 异常 如果通过第一步，在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有直接返回这个方法的直接引用，查找结束 否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有直接返回这个方法的直接引用，查找结束 否则，在类 C 实现的接口列表以及他们的父接口之中递归查找是否有简单名称和描述符与目标相匹配的方法，如果存在相匹配的方法，说明类 C 是一个抽象方法，查找结束，抛出 java.lang.AbstractMethodError 异常 否则，查找失败，抛出 java.lang.NoSuchMethodError 异常 如果查找过程中成功返回直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的权限，抛出 java.lang.IllegalAccessError 异常 接口方法需要先解析出接口方法表的 class_index 项中索引的方法所属类或接口的符号引用，如果解析成功，使用 C 表示接口 如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口，抛出 java.lang.IncompatibleClasssChangeError 异常 否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有直接返回这个方法的直接引用，查找结束 否则，在接口 C 的父接口中递归查找，直到 java.lang.Object（查找范围包括 Object 类） 类为止，是否有简单名称和描述符与目标相匹配的方法，如果有直接返回这个方法的直接引用，查找结束 否则，查找失败，抛出 java.lang.NoSuchMethodError 异常 由于接口中所有方法默认权限为 public ，所以不存在访问权限问题，接口方法的符号解析不会抛出 java.lang.IllegalAccessError异常 初始化该阶段是类加载过程的最后一步，除了在类加载阶段可以由用户自定义加载器之外，其余所有动作都是由虚拟机主导和控制，初始化阶段才是真正执行类中定义的 Java 程序代码 (字节码) 准备阶段系统为变量已经赋一个初始值，并不是开发人员所要求的值，自定义变量的值将会在初始阶段进行赋值。该阶段是执行类构造器 &lt;clinit&gt;() 方法的过程 &lt;clinit&gt;() 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问 &lt;clinit&gt;() 方法与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前，父类的 &lt;clinit&gt;() 已经执行完毕。在虚拟机中第一个被执行的 &lt;clinit&gt;() 方法的类肯定是 java.lang.Object 因为父类的 &lt;clinit&gt;() 先执行，所以父类中定义的静态语句块要有优先于子类的静态语句块变量赋值操作 &lt;clinit&gt;() 该方法不是必须执行，如果一个类中没有静态语句块和变量赋值操作，那么编译器不会为这个类生成 &lt;clinit&gt;() 方法 接口中不能使用静态语句块，但是在接口中能有赋值操作，所以类和接口都会生成 &lt;clinit&gt;() 方法。接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行其父接口的 &lt;clinit&gt;() ，只有当父接口中定义的变量使用时才会被初始化，接口的实现类初始化也一样不会执行接口的 &lt;clinit&gt;() 方法 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确加锁、同步，如果多线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;() 方法，其他的线程需要等待，直到活动 线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时很长的操作，就可能造成多个进程阻塞 以上内容参考自 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-垃圾处理机制]]></title>
    <url>%2F2019%2F02%2F28%2FJVM-%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾处理机制辨别对象状态Java 堆中存放着大多是对象（Class 对象存放在方法区中），对象两种状态：存活或者死亡，对于已经死亡的对象，就需要 Java 虚拟机通过垃圾处理机制移除，一直存放无用内存会占用没有必要的内存空间，判断对象状态的方式有：引用计数算法和可达性算法。 判定一个对象是存活还是死亡需要通过两次标记才可实现，通过可达性算法，发现没有与 GC Roots 相连接的引用链，将会进行第一次标记；第二次标记需要判断是否有必要执行 finalize() 方法，有必要执行，在执行过程中重新赋值回到 GC Roots 引用链中，可以实现复活；当没有必要执行，可能是没有覆盖 finalize() 或者 finalize() 已经被其他线程调用，就会进行垃圾回收。总结是：第二次标记可执行 finalize() 能有机会实现自救，不可执行，进行垃圾回收任何一个对象的 finalize() 方法只会被调用一次，也就是说只有一次自救机会 引用计数算法为对象添加一个引用计数起，当有一个对象引用时，计数器就加 1，引用失效，计数器就减 1，当引用计数器为 0 时，该对象是不可能再被利用就可移除内存。引用计数器的缺点是：无法解决循环引用问题 1234Test test_1 = new Test();Test test_2 = new Test();test_1.instance = test_2;test_2.instance = test_1; JDK 1.2 之后四种引用 强引用(Strong Reference)：Object object = new Object() 属于强引用，只要是强引用存在，垃圾回收器永远不会回收被引用对象 软引用(Soft Reference)：用来描述一些有用但非必需对象，在系统发生内存泄露之前，会将这些对象列进回收范围之中进行第二次回收，如果第二次回收还是没有足够内存，才会抛出内存泄露 弱引用(Weak Reference)：描述非必需对象，被弱引用关联的对象只能存活到下次垃圾回收之前，无论内存是否足够，都会回收被弱引用关联的对象 虚引用(Phantom Reference)：为一个对象设置虚引用唯一一个目的就是能在这个对象垃圾回收之前收到一个系统通知 可达性算法该算法通过 GC Roots 作为对象的起始点，开始向下搜索每一个节点，，所通过的路径称之为引用链，当一个对象没有与任何引用链相连接，就说明该对象不可用，被判定为可回收对象 GC Roots 对象包括： 虚拟机栈中引用对象 方法区中类静态属性引用对象 方法区中常量引用对象 本地方法栈中 JNI 回收方法区回收的内容主要是：废弃常量和无用类 判断一个常量是否为废弃常量方法是当常量池中没有对象引用到这个常量就被判定为废弃常量，发生垃圾回收时，就会将该常量清理出常量池 判断一个类为无用类需要以下条件满足： 该类所有实例被回收，Java 堆中不存在该类任何实例 加载该类的 ClassLoader 已经被回收 该类对应 java.lang.Class 对象没有在任何地方引用，无法在任何地方通过反射方法来访问该类 垃圾收集算法标记-清除分为两个阶段，先标记后清除。标记过程通过判断对象头 Mark World 标志位，将被标记的对象清除内存。该算法缺点是效率问题和空间问题，清除后会产生大量不连续的内存碎片。 复制算法在标记-清除算法上做改进，将整块内存一分为二，各占百分之五十，执行过程中只使用一半的内存空间，将存活的对象复制到另一块中，每次清理都是将整个半区内存进行清理，这也造成了该算法的空间浪费严重问题，可以解决内存碎片化的问题。不适用于存活率较高的对象内存区域 标记-整理同样是基于标记清除算法做的改进，先进行标记，让后将所有存活的对象将一端移动，然后清楚掉边界以外的对象。 分代收集通常根据对象存活是将将内存分为新生代和老年代，根据不同区域选择不同算法，提高整体执行效率。例如在新生代中对象存活率一般较低，有少量的对象，选择复制算法，一般在老年代中对象的存活率较高，选择标记-清除或者是标记-整理 新生代：存活率低，使用复制算法 老年代：存活率高，使用“标记-整理”或“标记-清除”算法 HotSpot 算法可达性算法判断对象状态，该项工作为了保证一致性，不容许在分析过程中对象的引用关系还在不断变化，所以就会使 GC 进行时必须暂停所有 Java 进程老保证该项工作安全运行。（Stop The World）如果堆内存过大，每次进行全盘扫描开销很大，添加 OopMap 的数据结构来解决此类问题，将必要的位置记录在该数据结构中，使用时就不需要再进行全盘扫描。这些特殊位置被称之为安全点 Safepoint，也就是说程序执行时不是在所有点都产生停顿来执行 GC，只在安全点位置才能停顿。具有例如 方法调用，循环跳转，异常条状等指令信息才会产生 Safepoint。 安全点GC 过程中如何让所有线程找到最近安全点停顿 抢先式中断: GC 过程中首先将所有线程全部中断，如发现有线程中断的地方不在安全点上，恢复线程到安全点上() 主动式中断: 不直接对线程操作，设置一个标志，让每个线程执行时主动访问这个标志，发现中断标志为真就主动挂起 安全区域安全区域是指在一端代码片段中，引用关系不会发生变化。当线程进入阻塞状态就需要安全区域来解决。当线程进入安全区域先进行标记，执行过程中就不需要再次标识为 Safe Region 状态的线程，在离开安全区域时，需要检查是否完成跟节点枚举（或整个 GC 过程）如果完成，线程继续执行，否则必须等待知道收到可以安全离开安全区域为止 垃圾收集器 并行（Parallel）：多条垃圾收集线程 并发（Concurrent）：用户线程与垃圾收集线程同时执行 新生代 Serial: 只开启一个线程执行 GC，必须暂停其他工作线程 ParNew: 多线程并行 GC Parallel Scavenge: 通过控制吞吐量，吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间） 老年代 Serial Old: 只开启一个线程执行 GC，需要暂停工作线程，采用复制算法 Parallel Old: 吞吐量优先，采用标记-整理，GC 多线程，如果新生代选择 Parallel Scavenge 收集器，老年代必须选择 Parallel Old CMS当老年代使用 CMS 收集器，新生代必须使用 ParNew 或者 Serial 收集器中的一个 执行过程： 初始标记：GC Roots 直接关联到对象，需要 STP 并行标记：GC Roots 间接关联到对象，不需要 STP 重新标记：修正并发期间因用户程序继续运行导致标记产生变动的那一部分对象的标记记录，需要 STP 并发清除：不需要 STP 优点：并发，低停顿，标记，清除采用并发减少整体 GC 停顿 缺点： 对 CPU 资源敏感，CPU 数量过少时，GC 占用过多 CPU ，影响用户线程执行速度 无法处理浮动垃圾：并发清除过程中整个程序还在运行，只会不断产生垃圾，而这一部分新产生的垃圾没有被标记过，不会在此次清除过程中清除，会保留到下一次执行 GC 标记-清除会产生大量的空间碎片，到老年代会存较大的剩余空间，无法找到足够的连续空间分配当前对象，解决方法： CMS 提供 -XX:+UseCMSCompactAtFull 开关参数，默认开启，用于须执行 Full GC 时对内存碎片进行合并整理，无法并发，停顿时间变长 G1将堆内存分为多个独立区域，并发执行 特点： 并行并发：多 CPU 缩短 STP 时间 分代收集：采用不同方式对新创建对象和已经存活一段时间对象进行处理 空间整合：使用标记-整理，运行期间不会产生大量空间碎片 可预测停顿：可对垃圾收集时间进行配置，根据各个堆积，避免全局垃圾回收，按照大小优先级，大的优先回收 使用 Remembered Set 来避免全盘扫描，每个 Degion 都有一个 Remembered Set 与之对应，当对 reference 类型的数据进行写操作会发生 Writer Barrier 暂时中断写操作，如果 reference 引用的对象处于不同 Degion ，使用 CardTable 将引用信息记录到所属的 Degion 的 Remembered Set 中 执行过程 初始标记 并发标记：工作线程可能会改变引用，将改变的引用记录到 Remembered Set Logs 中 最终标记：将 Remembered Set Logs 的数据合并到 Remembered Set 中 筛选回收：先对各个 Degion 的回收价值和成本进行排序，价值大优先被回收 优点：可预测停顿时间，不会产生大量空间碎片 内存分配与回收策略 新生代 GC (Minor GC): 发生在新生代垃圾收集动作，回收速度快 老年代 GC (Major GC / Full GC): 发生在老年代的垃圾收集动作，出现 Major GC 经常会伴随至少一次的 Minor GC ，Major GC 速度一般比 Minor 慢 10 倍以上 内存分配对象在新生代 Eden 区中分配，当没有足够空间进行分配，虚拟机将发一次 Minor GC 大对象进入老年代:虚拟机通过一个参数 -XX:PretenureSizeThreshold 来进行判断，大于该值对象直接进入老年代（大对象：需要有大量连续的内存空间的对象） 长期存活的对象将进入老年代：虚拟机为每一个对象定义了一个对象年龄计数器（Age），如果对象在 Eden 出生并经过第一次 Minor GC 后任存活，并且能被 Survivor 容纳的话，移动到 Survivor 空间中，并且对象年龄设为 1，对象在 Survivor 区中每经过一次 Minor GC 年龄就加一，当增加到默认值(15) 就会被晋升到老年代中。参数 -XX:MaxTenuringThreshold 设置阈值 动态对象年龄判定：如果新生代中某个年龄对象之和占新生代内存一半，直接进入老年代，无需判断阈值 分配担保 在 Minor GC 之前，虚拟机先判断安全老年代最大可用连续内存空间是否大于新生代所有对象总空间，如果不大于，判断是否容许担保失败，是：2 否：4 进行检查老年代最大连续内存空间是否大于历次晋升到老年代对象的平均大小，是：3 否：4 Minor GC 冒险 Full GC 以上内容参考自 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-内存区域]]></title>
    <url>%2F2019%2F02%2F25%2FJVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JVM-内存区域线程私有程序计数器当前线程执行的字节码行号指示器，每个线程都有独立的程序计数器，线程间互不影响，独立存储。当执行 Java 方法时指向下个要执行的字节码行号；当执行该计数器值为空（Undefined） Java 虚拟机栈每一个线程都有自己的虚拟机栈，方法调用到返回的过程对应虚拟机中入栈到出栈的过程。 基本数据类型：byte,char,int,float,short,double,boolen,long 对象引用：非对象本身，指向对象地址的引用指针或者是指向一个代表对象的句柄或与此对象相关的位置 returnAddress类型：指向一条字节码指令的地址 栈溢出两种异常： StackOverflowError: 线程请求栈的深度大于虚拟机容许深度 OutOfMemoryError: 虚拟机动态扩展无法申请到足够内存空间 当单线程情况下只会出现 StackOverflowError 异常， 本地栈区别于 Java 虚拟机栈，虚拟机执行 Java 方法服务，本地方法栈为虚拟机使用到的 Native 方法服务 线程共享Java 堆堆的存在是为实现存放对象实例，不是所有对象实例都存放在堆中（例如：Class 对象存在方法区中），在虚拟机启动时创建。Java 堆大小使用 -Xms(初始化大小) 和 -Xmx(最大扩展) 控制，不可无限制的创建对象，当对象数量达到最大堆容量限制就会产生内存溢出异常 方法区该区域存放已被虚拟机加载的类信息，常量，静态变量；运行时常量池属于方法区中一部分，Class 文件常量池在累加载后进入该区域，常量池用于存放编译器生成的各种字面量和符号引用； String.intern() 是一个 Native 方法，作用是：如果字符串常量池中包含此 String 对象的字符串，返回代表池中字符串的 String 对象，否则将次 String 字符串添加到常量池中，返回此 String 对象的引用。不断向常量池中添加对象，会产生 OutOfMemeoryError 异常 直接内存JDK 1.4 中加入 NIO，通过 DirectByteBuffer 对象为该块内存的引用进行操作 对象创建当虚拟机收到一条 new 指令，先检查这个指令的参数能否在常量池中找到一个类的符号引用，并且检查这个类是否被已被类加载，解析和初始化过。如果没有，必须先去执行类加载过程 分配内存 指针碰撞：用于 Java 堆内存是规整的，已使用内存和未使用的内存区分开，中间分界点放一个指针，另一个指针指向空闲 的内存区域 空闲列表：用于 Java 堆内存是不规整的， 在分配内存后，虚拟机会将分配到的内存空间都初始化为零（不包扩对象头），这也是在 Java 中变量不赋值就可以使用 内存布局对象头对象头由对象自身运行时数据与类型指针两部分组成；类型指针指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例 实例数据该区域存储对象真正有效的信息，记录对象实现的所有过程，该区域设定父类变量会出现在子类之前，常常使用的子类会覆盖父类定义的变量 对齐填充自动内存管理系统要求对象的起始地址必须是 8 字节的整数倍，对象大小必须是 8 的整数倍，当对象的实例数据大小不够时就需要对齐填充 对象的访问定位使用对象需要通过栈上的引用指针来操作堆上的具体对象，两种对象的访问定位 句柄：Java 堆中会分配出一块内存来作为句柄池，来存放对象的句柄地址，包含对象的实例数据和对象的类型数据，需要俩个指针定位；优势，引用指针存放稳定的句柄地址，对象被移动的时候，只会更改句柄中实例对象的指针，引用指针本身保持不变 直接访问：直接指向对象，对象本身包含类型指针；优势是访问速度快，因为它减少了一次指针定位开销 以上内容参考自 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-关键字synchronized]]></title>
    <url>%2F2019%2F02%2F17%2FJava-%E5%9F%BA%E7%A1%80-%E5%85%B3%E9%94%AE%E5%AD%97synchronized%2F</url>
    <content type="text"><![CDATA[线程安全为什么出现线程不安全？ 在多线程状态下，对共享数据（临界资源）的读写操作不同步导致线程不安全 书中定义 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。《Java Concurrency In Practice》Brian Goetz 代码本身已经封装好必要的解决线程安全问题保障手段，使用者无需关注线程安全问题，直接使用即可。 线程安全等级不可变只要是不可变的对象被正确构建出来，外部可见状态永远不会被改变，一定是线程安全的，最简单的实现线程安全的方法，例如用 final 来保证不可变，从而实现线程安全 绝对线程安全学习集合框架知识我们知道 java.util.Vector 该类是线程安全的，是一个线程安全容器，主要方法都被关键字 synchronized 所修饰，但不保证绝对线程安全，需要在关键位置加入同步措施来实现线程安全 使用 Vector 类中常用方法做测试，是否绝对线程安全 相对线程安全相对线程安全就是我们通常意义上的线程安全，单独调用操作是线程安全的，调用过程中不需要加入额外的保障措施，特殊连续调用需要加入同步保障措施来保证正确性 线程兼容对象本事不是线程安全的，可以通过同步手段实现线程安全，例如加入关键字 synchronized 线程对立无论采取如何同步措施，无论怎么加锁，都无法同步运行（死锁）如果两个线程同时持有一个线程对象，一个线程尝试去中断线程，一个线程尝试去恢复线程。无论是否进行同步，目标线程都存在死锁 实现线程安全互斥同步多个线程访问共享数据，共享数据在同一时刻只被一个线程使用。又称之为阻塞同步，悲观并发策略，采用这样方法实现线程安全，必须加入锁才可解决。在这里通过关键字 synchronized 的使用来解决线程安全的问题；还可以选择 java.util.concurrent 包中的重入锁来实现同步。1.6 版本之后性能角度上不建议采用此方法 互斥是手段，同步是目的 非阻塞同步属于乐观并发策略，不需要强制加锁来解决线程安全，只在需要时出现锁的应用。主要是实现是基于冲突检测，通俗理解为当共享数据无争用，正常执行，当产生冲突，进行补救。 非阻塞同步属于乐观锁实现线程安全，实现乐观锁主要原理就是使用 Java 中关键指令 CAS 来实现。该指令中包含三个重要操作数 V : 内存位置，也就是对象的内存地址 A : 旧的预期值 B : 新值 指令执行过程：当前仅当 V 符合 A 时，处理器更新 V 使用 B 的值，否则不执行更新，返回 V 。不论是否更新，都会返回 V 的旧值。整个过程是一个原子操作。CAS 操作实现是由 sun.misc.Unsafe 类里 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供，Unsafe 类不提供给用户程序调用的类，只有启动类加载器加载 Class 才能访问它，如果不使用反射方法，只能使用 Java API 间接使用 CAS 缺点： 循环时间长开销大；获取失败，继续尝试，长时间不成功，开销大 只能保证一个共享变量的原子操作 ABA问题 无同步方案不涉及共享数据，无需同步保证线程安全。可以大致概括为两类：可重入代码，线程本地存储 可重入代码可重入代码又称为纯代码，可以在代码执行的任何时候中断它，转而去执行另一段代码，控制权返回后，不会出现任何错误。可以保证线程安全，所有可重入代码都是线程安全的，但是不是所有线程安全的都是可重入代码。判断是否是可重入代码方法：如果一个方法，他的返回结果可以预测，只要输入相同数据，就能返回相同结果，它就满足可重入性要求，也是线程安全的 线程本地存储将被多个线程使用的共享数据尽量集中在一个线程中执行，这样即使不同步，也能实现线程安全，实现线程本地存储。在 Java 中可以使用 java.lang.ThreadLocal 来实现本地存储功能。每一个线程都有一个 ThreadLocalMap 对象，这个对象存储了一组 ThreadLocal.threadLocalHashCode 为健，本地线程变量为值的 K - V 对。ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个对象都包含了一个 threadLocalHashCode 值，通过该值可以在 K - V 中找到本地线程变量 锁优化为并发过程中线程之间高效的共享数据 自旋锁与自适应自旋线程 A 正在执行，线程 B 等待线程 A 释放锁。此时线程 B 等待，执行忙循环（自旋）一直等待线程 A 释放锁。这样的过程称为自旋锁。在 Java 1.6 版本以后不是让它永久等待自旋，这样长时间消耗处理器资源过大，默认自旋参数为 10 ，也可以使用 -XX:PreBlockSpin 来更改参数。自适应自旋是依照同一个锁前一个自旋时间以及锁的拥有者状态来决定，自旋次数，提高执行效率。特殊情况，如果一个锁，自旋很少成功，之后的线程就会自动放弃自旋过程，避免浪费处理器资源 锁消除虚拟机在编译器运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。根据逃逸分析的数据支持 锁粗化如果虚拟机检测到一串零碎的操作都对同一个对象进行加锁，将会把锁的范围扩大，从第一个操作到最后一个操作，使用同一个锁 轻量级锁相对于使用操作系统互斥量来实现，在没有多线程竞争前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗（线程切换）主要是通过 CAS 操作来实现轻量级锁；在锁无竞争情况下，减少线程切换的性能开销，但在竞争情况下，轻量级比重量级更慢（互斥量和 CAS 操作） 对象头对象头是指 HotSpot 虚拟机的对象内存布局，主要分为两部分 存储对象运行时数据，如 HashCode, GC 分代年龄等，官方称之为 “Marl Word” 存储对象方法区对象类型数据的指针 如果是数组，额外加一部分，用于存储数组长度 对象头信息时与对象自身定义的数据无关的额外存储成本，Mark Word 是一个非固定的数据结构，可以根据对象的状态复用自己的存储空降，在 32 位虚拟机中存储状态为 锁状态 25bit 4bit 2bit 标志位 1bit 无锁状态 存放对象哈希码 对象分代年龄 01 0 Mark Word 对象头 锁状态 存储内容 标志位 无锁状态 对象哈希吗对象分代年龄 01 轻量级锁 指向锁记录指针 00 重量级锁 指向重量级锁的指针 10 可偏向锁 偏向线程 ID ，偏向时间戳，对象分代年龄 01 加锁 先判断标志位，未被锁定标志位 “01”，建立一个锁记录（LockRecord）空间存储对象，拷贝 Mark Word ，将拷贝后加一个前缀 （Displaced Mark Word） 利用 CAS 将对象 Mark Word 更新指向 Lock Record;如果更新成功，标志位 “00”，轻量级锁，拥有该对象锁，执行同步操作； 否则检查对象的 Mark Word 是否指向当前线程，已经拥有对象锁，执行同步，否则锁对象被其他线程占用，轻量级线程变为重量级线程，标志位 “10” 等待的线程进入阻塞状态解锁 如果对象的 Mark Word 仍指向线程锁记录，使用 CAS 将当前 Mark Word 与线程中 Displaced Mark Word 替换 替换成功：同步过程完成 替换失败：其他线程尝试获得该锁，释放锁同时唤起挂起线程 偏向锁目的是消除数据在无竞争情况下同步，没必要使用轻量级锁，减少 CAS 操作；不适用于一个锁被多个线程访问 加锁 检测和是否为偏向锁，判断标志位是否 ”01“ 如果不是标志位改为 “01” 否则检查是否为当前线程 ID，如果相等，执行同步代码，否则执行轻量级锁过程 解锁偏向锁会在竞争情况下解锁 synchronized作用在多线程状态下，保证只有一个线程可以执行某个方法或某个代码块（对共享数据的操作）。对共享数据修改其他线程及时可见，实现可见性；同时也可以保证线程之间的操作是有序的。具备原子性，可见性，有序性。 原子性：一个操作不可中断，要么全部执行通过，要么全部执行失败 可见性：一个线程对某一个共享数据的修改，其他线程立即获得更新 有序性：本线程内看指令执行是有序的，另一个线程观察到的是无序的 实现方法 对实例方法 对静态方法 对代码块（括号里方法可以是实例对象也可以是类的 Class 对象） 实例方法123456789101112131415161718192021222324public class test01 implements Runnable&#123; static int i = 0; public static void main(String[] args) throws InterruptedException &#123; test01 test01 = new test01(); Thread thread1 = new Thread(test01); Thread thread2 = new Thread(test01); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(i); &#125; public void run()&#123; for (int i = 0;i &lt; 10000;i++)&#123; test(); &#125; &#125; public static synchronized void test()&#123; i++; &#125;&#125; 静态方法12345678910111213141516171819202122232425public class test01 implements Runnable&#123; static int i = 0; public static void main(String[] args) throws InterruptedException &#123; test01 test01 = new test01(); Thread thread1 = new Thread(test01); Thread thread2 = new Thread(test01); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(i); &#125; public void run()&#123; for (int i = 0;i &lt; 10000;i++)&#123; test(); &#125; &#125; // 静态方法 public static synchronized void test()&#123; i++; &#125;&#125; 代码块123456789101112131415161718192021222324252627public class test01 implements Runnable&#123; static test01 test01 = new test01(); static int i = 0; public static void main(String[] args) throws InterruptedException &#123; test01 test01 = new test01(); Thread thread1 = new Thread(test01); Thread thread2 = new Thread(test01); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(i); &#125; public void run()&#123; synchronized (test01)&#123; for (int i = 0; i &lt; 10000; i++) &#123; test(); &#125; &#125; &#125; public void test()&#123; i++; &#125;&#125; 以上代码测试在多线程状态下，对静态方法加关键字 synchronized 与不加的区别。经过多次执行，在不加关键字的情况下，对共享变量 i 的值是不相同，并且多数是小于 20000。当使用 synchronized 修饰后，变量的值都是恒定不变 20000 实现原理虚拟机在对 Java 代码编译之后，在被关键字 synchronized 修饰之后的代码块的前后分别形成 monitorenter 和 monitrorexit 这两个字节码需要一个参数 reference 类型来指明锁定和解锁对象。如果 synchronized 指定了对象参数，就是这个对象的 reference 否则根据修饰实例方法或者是类方法，取对应的对象实例或 Class 对象作为锁对象。 monitorenter:同步代码块开始位置，执行该指令首先获取对象锁，如果获取失败，阻塞等待，或当前对象已经拥有对象的锁，锁的计数器加1 monitorexit:同步代码块结束位置，锁的计数器减1，当计数器为 0，锁被释放 以上内容参考自 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-序列化与反序列化]]></title>
    <url>%2F2019%2F01%2F27%2FJava-%E5%9F%BA%E7%A1%80-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化与反序列化 序列化： 把对象转为字节 反序列化： 把字节转为对象 序列化用途： 把对象的字节保存到硬盘上，在网络上传送对象的字节序列 通过序列化进行进程间传递对象 序列化一个对象： ObjectOutputStream 输出流 writerObject(Object obj) 将对象 obj 进行序列化 反序列化一个对象： ObjectInputStream 输入流 readObject() 从输入流中读取字节序列 Serializable ， Externalizable 序列化反序列化所需要实现的接口Externalizable 继承自 Serializable demo: import java.io.*; public class test_1 { public static void main(String [] args) throws IOException, ClassNotFoundException { SerialieUser(); // 进行序列化 User user = desSerialieUser(); // 进行反序列化，返回 User 对象 System.out.println(user); } private static User desSerialieUser() throws IOException, ClassNotFoundException { // 读取 path 路径文件 ObjectInputStream ob = new ObjectInputStream(new FileInputStream(new File(&quot;path&quot;))); // 从输入流中读取字节序列 User user = (User) ob.readObject(); System.out.println(&quot;反序列化成功&quot;); ob.close(); return user; } private static void SerialieUser() throws IOException { User user = new User(); user.setName(&quot;张三&quot;); user.setPassword(&quot;li123&quot;); // 将序列化对象写入到 path 路径下 ObjectOutputStream ob = new ObjectOutputStream(new FileOutputStream(new File(&quot;/Users/carlos/Documents/a.txt&quot;))); ob.writeObject(user); System.out.println(&quot;序列化成功&quot;); ob.close(); } } class User implements Serializable{ private static final long serialVersionUID = -5809782578272943999L; String name; String password; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } serialVersionUID 序列化版本号，实现 Serializable 接口都有表示序列化版本的标志符的静态变量 private static final long serialVersionUID = -5809782578272943999L; 序列化只对对象状态保存，不管对象方法 当父类实现序列化，子类不需要实现接口 Serializable 自动实现序列化 当一个对象的实例变量引用其他对象，序列化该对象时会同时序列化引用对象 当一个对像有 private public 修饰时，在序列化过程中，private 将不受保护 声明为 static 或者 transient 类型的成员数据不能被序列化（static 类的状态。 transient 对象临时数据） 各别基础类事项 Serializable 接口(String, Vector 等)]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-反射]]></title>
    <url>%2F2019%2F01%2F04%2FJava-%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射 定义：反射机制能够动态的操纵 Java 代码的程序，能够分析类能力的程序。 通过编译之后的字节码文件获取类中对象，可以得到类中的所有属性，方法，并且可以动态的操作该类。反射的关键源于 Class 类发挥的作用，该类在 java.lang.Class包下。 Class 类java.lang.Class 类的实例对象，任何一个类都是 Classs 实例对象，获取 Class 对象的三种方式 我们先定义一个 Student 类，在该类中定义变量和方法 123456class Student&#123; private String name; public void show()&#123; System.out.println("show"); &#125;&#125; 然后编写一个测试类，分别测试三种获取 Class 对象的方式 第一种方式 Class c_0 = Student.class;，我们知道当运行一段代码第一步是进行编译，Java 程序文件后缀在编译之前 .java 文件，编译之后为 .class 文件，只要编译通过就会生成，第一种方式直接调用 Student 类的字节码文件，获取所需要的对象 第二种方式 Class c_1 = student.getClass();，当我已经实例化一个 Student 对象，学习 Object 类知道所有类默认继承 Object 类，在 Object 类下有一个方法可以获取类信息，直接调用即可。 第三种方式 12Class c_2 = null;c_2 = Class.forName("这里写类的全称");// 比如 demo.Student 测试程序主要代码 123456789101112131415161718public class test &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Student student = new Student(); Class c_0 = Student.class; Class c_1 = student.getClass(); Class c_2 = null; c_2 = Class.forName("demo.Student"); System.out.println(c_0); System.out.println(c_1); System.out.println(c_2); System.out.println(c_0 == c_1); System.out.println(c_0 == c_2); &#125;&#125; 打印结果为 12345class demo.Studentclass demo.Studentclass demo.Studenttruetrue 先查看 Class 类的三个对象，然后进行比较发现不论属于哪一种方式创建 Class 类创建的对象，他们都属于同一个对象，并没有重新编译生成。 获取程序在运行时刻的内部结构只是第一步，我们可以继续挖掘内部结构信息，比如声明定义的方法，变量等，常用的 Class 类下的方法主要有 getConstructor, getField 和 getMethod 分别获取构造方法，获取域还有方法，这里三个方法除了会获取 public 的函数对象，还会获取继承父类的所有元素。相比对应的 getDeclaredConstructor, getDeclaredField, getDeclareMethod这三个方法同样获取构造方法，域还有方法，但是这三个方法只会获取对象本身的方法，不问访问权限。每个方法都有自己的所属类。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式及案例]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[单例模式 单例模式：用来创建独一无二的，只能有一个实例对象，确保一个类只有一个实例，并提供一个全局访问点。 通俗说单例模式只将对象 new 一次，与工厂模式区别，工厂模式像是与单例模式相同，其实差距很大，工厂模式并不是实现将对象只 new 一次，它是主要避免对象的紧耦合，实现最终的解耦，或者是说单例模式是类的设计者要考虑的问题，工厂模式是类的使用者需要考虑的问题，不要混淆两个设计模式者 单例模式实现12345678910111213public class Singleton&#123; // 记录唯一实例对象 private static Singleton uniqueInstance; private Singleton()&#123;&#125; // 线程非安全 返回 uniqueInstance 对象 public static Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 编写测试类 12345678910class Test&#123; public static void main(String[] args)&#123; Singleton singleton = new Singleton(); singleton.getInstance(); System.out.println(singleton.getInstance()); System.out.println(singleton.getInstance()); System.out.println(singleton.getInstance()); &#125;&#125; 显示打印结果 123Thread.Singleton@610455d6Thread.Singleton@610455d6Thread.Singleton@610455d6 可以看出只创建一次对象每次调用返回同一个对象 此方法在单线程环境下可行，没有任何问题。但是如果两个线程，访问这段代码就会出现问题，当开启线程 A 和线程 B 。线程 A 第一次执行判断 uniqueInstace 为空，进入实例化一个对象，这时候线程 B 在判断 uniqueInstance 同样为空，同样实例化一个对象，这时候就不符合单例模式的定义，会出现两个或多个实例化对象，在 Java 中解决此类问题方式是添加关键字 synchroized 加锁 多线程单例模式我们先测试不加锁情况下会发生什么，单例模式类不改变，改动测试类的代码加入线程 123456789101112class Test extends Thread&#123; public static void main(String[] args)&#123; Thread thread_1 = new Test(); Thread thread_2 = new Test(); thread_1.start(); thread_2.start(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "=" + Singleton.getInstance()); &#125;&#125; 显示打印结果 12Thread-1=Thread.Singleton@470bc213Thread-0=Thread.Singleton@5eca2b42 明显发现，两个线程会去实例化俩个不同的对象（有时会返回相同对象，这是电脑本身计算问题，不妨多运行几次，会发现不同），如果这样的话我们的单例模式就没有存在的意义，不符合单例模式的定义：用来创建独一无二的，只能有一个实例对象，确保一个类只有一个实例，并提供一个全局访问点。需要做出更改，给 getInstance() 方法加锁看会不会有所改变，能否解决此类问题 更改单例模式类 123456789101112public class Singleton &#123; private static Singleton uniqueInstance; Singleton() &#123; &#125; // 加入关键字 synchronized 上锁 public synchronized static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 显示打印结果 12Thread-0=Thread.Singleton@79d62897Thread-1=Thread.Singleton@79d62897 经过多组测试，发现每次都只是返回同一个对象，感兴趣不妨可以自己测试，多添加几个线程。可以解决在多线程情况下的单例模式问题。 但是仔细想这样是会很好解决问题吗？其实并不是，学习线程我们知道，加锁代价高，如果是单纯的读操作是不需要加锁的，涉及写操作才需要加锁，使用 synchronized 需要仔细考虑，优化锁。仔细看一下代码，这段代码我们将 synchronized 关键字放在了方法上。这样的话不论哪个一个线程访问都会进行上锁解锁，其实这一步只有第一次访问时需要，其他时候访问已经有了实例化对象，就不需要再加锁，这时候的锁就造成浪费，优势变成了累赘。 更改多线程解决方式，为其添加双重锁 12345678910111213141516public class Singleton &#123; private volatile static Singleton uniqueInstance; Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 分析双重锁之前，会发现增加了新的关键字 volatile ，这方面知识需要我们恶补 JVM 的知识，我有关于该关键字介绍，附链接方式 更改 getInstance() 方法，判断 uniqueInstance 是否为空，改为锁前判断一次，锁后判断一次。不要以为锁前锁后都进行判断空是多余的操作，每一步都有存在的必要性。 首先锁前检查，如果需要的对象为空，进行加锁，去实例化一个对象，相反如果不为空，检查到已经存在一个需要的对象，就不要再进行加锁了，直接返回需要的对象。省掉了代价过高的加锁操作。锁前检查为了判断读写操作。 锁后检查，很多小伙伴会这想之前已经为空了，再加锁判断为空是否多余。并不是你们想的那样，这两次的判断存在的性质不同，第一次判断读写，第二次是检查线程问题。可以编写一个测试类查看运行结果是不是自己想要的。 不使用第二个判断的运行结果 1234Thread-1=Thread.Singleton@352ebfc0Thread-2=Thread.Singleton@352ebfc0Thread-0=Thread.Singleton@3c03e5f5Thread-3=Thread.Singleton@352ebfc0 开启四个线程，发现其中一个线程实例化了一个新对象，这时不符合单例模式的定义。当我们调整代码，加上第二次判断执行多次后，每次执行结果，不论哪个线程都是使用的同一个对象，这时才是真正的实现多线程的单例模式 总结单例模式的实现相比之前学习的工厂模式较为简单，在学习之前我们先要对线程知识有一定了解，从而解决多线程中的单例问题。在单线程环境下我们不用考虑是否会创建多个对象，只有一个住线程，第一次执行方法为空，实例化一个对象，在整个代码运行期间，多次执行实例化方法时，第一次执行已经实例化一个对象，所以在之后调用该方法直接返回一个对象，不需要实例化一个新对象，从而实现单例模式。在多线程环境下，我们需要加锁来实现多线程环境下的单例模式，使用双重检查加锁来实现，避免直接在方法上加锁，造成资源浪费。第一次判断读写操作，第二次判断解决线程问题。 需要注意的是在 Java 语言中双重检查加锁不适用于 1.4 及更早版本，原因是关键字 volatile 发挥的作用，我有学习关键字 volatile 相关的记录，会附链接方式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一年，想法指向行动]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%BF%99%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%83%B3%E6%B3%95%E6%8C%87%E5%90%91%E8%A1%8C%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[16年，17年2018年12月31日，天津，一个人，心情很复杂，负能量爆棚。又是一年末尾，新的一年开始，这是在上大学过的第三个元旦，前俩年到元旦都会非常的兴奋，朋友相聚，新环境的感触。可是今年的我却怎样也开心不起来，变得焦虑，急躁。 16年上大学开始，每年这时候总会控制不住自己，总想出去看一看。当时自己还想着每年元旦假期换地过（天津，北京，上海…），16年，17年很顺利，没有任何阻碍，完成了计划，每个地方都有收获，同样也有好友相伴。 16年在天津，三个人的聚会（文盲，旺旺），话题总是离不开这半年换一个城市生活的感受，毕竟都是第一次长时间的在一个陌生的城市生活。17年北京，这次的北京之旅，由16年的三位，变成了两位（旺旺）。这次的相聚，了解到我的准备18年去当兵，去磨练自己。老实说我之前的我也有当兵的想法，但是没有去实现，比较佩服他，支持他。而当时的我对自己也有新的要求，经过一年的时间，所立要求完成了90%，带来更大困惑，未知。（18年9月份他正式参军入伍，知道消息后，准备去火车站送他上车（不容许），只能在入伍前几天见一次，期待两年后的再聚，有成长，有改变） 在成长的路上，每一年意义非凡。未来是未知的，任何事都是不确定的，也许现在做的事会对以后产生影响，也许不值一提。希望在若干年后回想现在每天完成的事，会是有意义的。 快乐，焦虑，丧气。这三个词可以概括我在敲这些字时候对这一年中经历的总结。有时候我也在问自己，这样的状态是怎样造成的，并没有好的答案，反而更加严重。或许转移这方面的注意力，能够使这些负能量减少。 18年元旦假期结束，与好友乘坐高铁回天津，等车过程中看着北京南站的人来来往往，下次来北京是否还会像当时一样有着轻松的状态。 这一年，想法指向行动​做事付出行动，没有这个其他的都是扯淡。开启新的进程，第一步就是去找学习资源，当时身边很少认识学长，老师，只能是自己去查找。比较幸运的是现在网络的发展，资源的获取非常方便，只要肯去查找，筛选。之前也有关注一些大牛的公众号，没事时就去看看他们之前分享的文章，也有学习路径推荐，最先关注的是公众号码农翻身，逐步的学习过程中，也有关注许多大牛（Hollis, 纯洁的微笑，zhisheng等等）,里面有刚参加工作的，也有从业几年的技术大佬，总结的经验值得我去学习，找到介绍 Java 主要后端编程，网站开发 刚开始就从语言出发,Java 开始学习，18年的上半年，也就是大二的下学期，开始看视频学习，找到的是毕向东 Java 的视频，只要是没课，就开始看视频学习，也有书做参考，有些内容需要书的辅助。 一套系列结束后，那时候大概是四月份。打开各种招聘网站还有牛客网（这个我之前我不认识，公众号里文章看到，或许上面的面经有些帮助吧），并不是去找工作了，再说了就这破水平，也没地方需要。上去看的目的就是了解一下，这方面工作需要掌握什么样的技术，才能够参加工作。打开 Java 搜索，大多都是属于网站，后端方面，当时看好多技术，不认识。接着学习，先得认识它，会使用它。开始找方法，看书，刷大牛的博客。开始先看书是怎样一个过程，然后去创建工程去实现它。最后学习完成后，自己还写了一个小项目，把学习到技术合在一起。差不多到放假七月份时候，暑假得做些事，利用暑假学习了框架的知识（Spring,Spring MVC,MyBatis），总算假期做些事，没有荒废掉。使用框架完善了之前的那个小项目，算是一个简单的实践。 假期将要结束时，五个人组织了一次自驾游（司机：铭），第一次和小伙伴自驾游，不知道以后还能不能有像现在一样说走就走的旅行。这次去的地方有高中同学，解决了我们住的地方，非常感谢沙沙安排。就是他家的那个锁，是真的差。 九月份来学校后，开始了学校的实训，我觉着没有一点含金量，不值得参加，没办法这都是之前不认真学习的结果，得认。没有参加学校安排的校外，选择校内，跟着老师。那三个星期是最颓废的时候，使用了 c# 来编写，这次的实训让我彻底认识到语言是相通的，编程是思想。国庆小长假和大多数同学都一样，利用假期去一些之前没有去过地方，七天三地，天津—大同-呼和浩特，（三哥，沙沙，胖妹妹）。 假期结束，热闹过后的安静，会有一些孤独感。调整状态，心静下来做自己的事。每年在这时候有很多参加完面试的大佬在牛客网上分享他们的经历与建议，空闲时间会上去刷一些面经。受到了很大打击，发现之前的学习积累的知识太片面，基本是停留在会用这个基础上，没有自己对一个知识点的理解与分析，太多的漏洞需要弥补。同时也为明年的实习有所担忧，只想着早点出去参加工作（没有考研准备），积累经验，觉着学校里没有很好的技术提升，需要做一些对自己有挑战性的项目，用实际项目来积累经验。目前的能力还不够应对工作岗位，只有不断的学习，关注行业动态。 我会有这样的一种状态，每天都在按着计划进行。感觉自己会一点技术，更多的是不会，开始认识 Java，网站后端，始学习 JavaSE, JavaEE，开始网站搭建，进行增删改查。这些刚刚达到入门级别，自己的不足越发明显，需要不断武装自己，时间在一天天过去。各种负能量造成焦虑，丧气状态，一切都源于目前的自己技能过于薄弱。 2019“好记性不如烂笔头” 多写，多做，少说话，说重点，争取在上半年能够找到实习公司。在日常生活中希望自己可以拿起相机，记录生活有意义的事情。 零散的记录。时间不等人，接下来继续努力，加油，共勉！ 2018/12/31 天津]]></content>
      <categories>
        <category>长路漫漫</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式及案例]]></title>
    <url>%2F2018%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[工厂模式学习工厂设计模式之前需要掌握两种设计原则： 依赖倒置原则：依赖抽象，不依赖具体类 开闭原则：两个主要特征，对于扩展是开放的和对于修改是关闭的。对于扩展是开放的：模块的行为是可扩展的，当应用需求改变时，可对模块进行扩展，使其具有新行为，可以改变模块的功能。对于修改是关闭的：当模块进行扩展时，不必改动源代码或二进制代码，不破坏原有系统结构。 工厂模式定义为：把可能会有所改变的代码（创建新对象的代码）放到另一个新对象中。称这个新对象为 “工厂”，处理创建对象的细节，用来封装对象的创建，让类决定创建的对象时什么。通过创建模式绕开 “new” ，避免对象创建过程中所导致的紧耦合（依赖具体类）. 工厂模式主要分为三大模式： 简单工厂模式（Simple Factory） 工厂方法模式 (Factory Method) 抽象工厂模式 (Abstract Factory) 以上三种模式从上到一逐步抽象 简单工厂模式（Simple Factory）简单工厂模式定义简单工厂模式又称静态工厂模式，简单工厂模式是一个工厂对象决定创建出哪一种产品类的实例，根据参数不同，返回不同的实例对象。属于创建型模式，不属于23种GOF设计模式之一。 案例创建抽象产品类 123public abstract class MakeCar &#123; public abstract void produce();&#125; 创建具体类，实现抽象产品类中方法 123456789101112public class SaloonCar extends MakeCar &#123; @Override public void produce() &#123; System.out.println("创造轿车"); &#125;&#125;public class Truck extends MakeCar &#123; @Override public void produce() &#123; System.out.println("创造卡车"); &#125;&#125; 创建工厂类，使用 if-else 逻辑判断实例化对象 1234567891011public class CarFactory &#123; public MakeCar createCar(String type)&#123; if (type.equals("轿车"))&#123; return new SaloonCar(); &#125; else if (type.equals("卡车")) &#123; return new Truck(); &#125;else &#123; return null; &#125; &#125;&#125; 编写测试类 1234567891011public class Test &#123; public static void main(String[] args)&#123; CarFactory carFactory = new CarFactory(); MakeCar makeCar = carFactory.createCar("卡车"); if (makeCar == null) &#123; System.out.println("不在业务范围"); return; &#125; makeCar.produce(); &#125;&#125; 优点和缺点优点：用户无需写实例化类名，只需要传入相应参数即可，通过参数进行逻辑判断可以找到需要实例化的对象缺点：当添加新类时，需要对工厂整体进行改动，不利于系统的维护和扩展。例如：当我们想要在以上工厂中添加一个公交车，我们先需要定义一个类继承 MakeCar 类，然后再去 CarPactory 中修改逻辑代码，添加我们的公交车信息。这样操作是违反了开闭原则，不适用。 工厂方法模式 (Factory Method)工厂方法模式定义定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类实例化延迟（目的：解耦）到子类。核心共产个类不再负责所有产品的创建，将具体创建交给子类。核心工厂类成为一个抽象工厂角色，仅负责给出子类实现的接口。 角色 Product (抽象产品): 所有产品必须实现的公共接口 ConcreteFactory (具体产品): 实现抽象产品的接口，具体工厂和具体产品一一对应 Factory (抽象工厂): 声明工厂方法 ConcreteFactory (具体工厂): 实现抽象工厂中定义的工厂方法，返回一个具体产品类的实例 案例创建抽象产品类 123public abstract class Car &#123; public abstract void creat();&#125; 创建具体产品类，继承 Car 类 123456789101112public class SaloonCar extends Car &#123; @Override public void creat() &#123; System.out.println("轿车"); &#125;&#125;public class Truck extends Car &#123; @Override public void creat() &#123; System.out.println("卡车"); &#125;&#125; 创建抽象工厂类 123public abstract class CarFactory &#123; public abstract Car CreatCar();&#125; 创建具体工厂类 123456789101112public class SaloonFactory extends CarFactory &#123; @Override public Car CreatCar() &#123; return new SaloonCar(); &#125;&#125;public class TruckFactory extends CarFactory &#123; @Override public Car CreatCar() &#123; return new Truck(); &#125;&#125; 编写测试代码 123456789101112public class Test &#123; public static void main(String[] args)&#123; SaloonFactory saloonFactory = new SaloonFactory(); TruckFactory truckFactory = new TruckFactory(); Car car = saloonFactory.CreatCar(); car.creat(); Car car_1 = truckFactory.CreatCar(); car_1.creat(); &#125;&#125; 优点和缺点优点：工厂方法用来创建用户所需要的产品，同时向用户隐藏实例化细节，用户只需要关心产品对应的工厂，无须关注创建细节，当需要添加新类时，不需要改变逻辑判断，只需要添加工厂类即可，符合开闭原则，缺点：在添加新类时，需要编写新的具体产品类和对应的具体工厂，在一定程度上增加了系统的复杂度， 抽象工厂模式 (Abstract Factory)抽象工厂模式定义提供一个接口，创建相关或依赖对象的家族，不需要明确指定具体类，在抽象工厂模式中，每一个具体工厂提供多个工厂方法用于生产多种不同类型的产品。 角色 AbstractFactory (抽象工厂): 声明抽象产品的方法，每一个方法对应一个产品 ConcreteFactory (具体工厂): 实现在抽象工厂中声明创建产品的方法，生产一组具体的产品 AbstractProduct (抽象产品): 为每种产品声明接口，在抽象产品中声明业务方法 ConcreteProduct (具体产品): 定义具体工厂生产的具体产品的对象，实现抽象产品的接口中声明的业务方法 案例定义抽象产品 123456public abstract class Glass &#123; public abstract void creat();&#125;public abstract class Tire &#123; public abstract void creat();&#125; 定义具体产品 12345678910111213141516171819202122232425public class SaloonGlass extends Glass &#123; @Override public void creat() &#123; System.out.println("轿车的玻璃"); &#125;&#125;public class TruckGlass extends Glass&#123; @Override public void creat() &#123; System.out.println("卡车的玻璃"); &#125;&#125;public class SaloonTire extends Tire &#123; @Override public void creat() &#123; System.out.println("轿车的轮胎"); &#125;&#125;public class TruckTire extends Tire&#123; @Override public void creat() &#123; System.out.println("卡车的轮胎"); &#125;&#125; 定义抽象工厂 1234public interface CarFactory &#123; Glass creatGlass(); Tire creatTire();&#125; 定义具体工厂 1234567891011121314151617181920public class SaloonFactory implements CarFactory &#123; @Override public Glass creatGlass() &#123; return new SaloonGlass(); &#125; @Override public Tire creatTire() &#123; return new SaloonTire(); &#125;&#125;public class TruckFactory implements CarFactory&#123; @Override public Glass creatGlass() &#123; return new TruckGlass(); &#125; @Override public Tire creatTire() &#123; return new TruckTire(); &#125;&#125; 编写测试方法 123456789public class Test &#123; public static void main(String[] args)&#123; CarFactory carFactory = new SaloonFactory(); Glass glass = carFactory.creatGlass(); Tire tire = carFactory.creatTire(); glass.creat(); tire.creat(); &#125;&#125; 优点与缺点在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以是一个类，或者一个接口。具体工厂类实现了抽象工厂每一个方法，返回一个对象，同一个具体工厂所创建的产品对象构成一个产品族。 优点：可以通过具体工厂类创建一个产品族中的多个对象缺点：需要加入产品族时，几乎要对所有类尽心修改，扩展性差，在创建系统时，对产品的等级结构划分非常重要 总结不论是简单工厂，工厂方法，还是抽象工厂，这些都属于工厂设计模式，实现该模式最终的目的就是在于解耦。例如我们创建汽车，开始不考虑轮胎和玻璃，使用简单工厂完全可以实现我们需求。但是当我们需求增加，增加玻璃和轮胎的适配，这时候就需要添加不同的产品，构成最终的产品族来实现需求，简单工厂模式这时候就改变为抽象工厂模式，来应对需求。当我们设计的产品减去某些方法，不再构成产品族时，这时候的抽象工厂模式就更改为工厂方法模式。三者根据不同的需求可做更改，切记不论使用哪种模式，必须达到解耦的目的，才属于工厂设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(-):基础搭建、整合应用]]></title>
    <url>%2F2018%2F12%2F21%2FSpring%20Boot-%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E3%80%81%E6%95%B4%E5%90%88%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring BootSpring Boot 是由 Pivotal 团队开发的全新框架，简化 Spring 初始搭建以及开发过程。易上手，开箱即用，推荐使用 Maven 构建，访问 http://start.spring.io/, 选择 Maven Project 下载 demo 项目，开启 Spring Boot 学习之旅。 目录结构为 程序开发及主程序入口：/src/main/java/ 配置文件：/src/main/resources 测试程序：/src/test/java application.java 该文件存放根目录下：/src/java/com/example/application.java 实体类：/src/java/com/example/domain/ 业务代码：/src/java/com/example/service/ 控制代码：/src/java/com/example/controller/ Maven 资源目录：/src/java/resources/ Spring Boot 项目静态文件目录：/src/main/resources/static Spring Boot 项目模版文件目录：/src/main/resources/templates Spring Boot 项目配置文件目录：/src/main/resources/application.properties Spring Boot MyBatis 映射目录：/src/main/resources/application.priperties applicarion.java: 带有 main() 方法的类，用于启动程序，程序的入口以上是使用官方示例，整合 Spring Boot + Mybatis + Thymeleaf 基础目录结构。相比 SSM 框架整合，Spring Boot 配置简单，不需要先配置 web.xml ，Spring, Mybatis，然后进行整合，简化我们的配置过程。 特性 能够快速创建基于Spring的应用程序 能够直接使用 Java 的 main 方法启动内嵌的Tomcat，Jetty服务器运行Spring Boot程序，不需要部署war包文件 提供约定的 starter POM 来简化来简化 Maven 配置，让 Maven 配置变得简单 根据项目的maven依赖配置，Spring boot自动配置 Spring, SpringMVC 等其它开源框架 提供程序的健康检查等功能。（检查内部的运行状态等） 基本可以完全不使用xml配置文件，采用注解配置 Spring Boot 整合 MyBatisSpring Boot 整合 MyBatis 与 SSM 整合类似，Spring Boot 配置简单，在 pom.xml 中引入依赖，还需要在 application.properties 文件中添加一下代码就可使用 // mapper 映射文件目录 mybatis.mapper-locations=classpath:mapper/*.xml // 实体类文件目录 mybatis.type-aliases-package=com.example.domain ThymeleafThymeleaf 事一款用于渲染 XML/XHTML/HTML 内容的模版引擎。类似 JSP， Velocity, FreeMaker等（目前只接触过 JSP），可以与 Spring MVC 等 Web 框架集成作为 Web 应用的模版你引擎。Thymeleaf 特点是能够直接在浏览器中打开并正确显示模版页面，不需要启动整个 Web 应用。 模版引擎：用于 Web 开发的模版引擎，为了使用户界面业务数据分离而产生，可以生成特定格式的文档，用于网站的模版引擎就会生成一个标准的 HTML 文档。 Spring MVC 中 @Controller 中的方法可以直接返回模版名称，接下来 Thymeleaf 模版引擎会自动进行渲染 模版中的表达式支持 Spring 表达式语言（Spring EL） Spring Boot 中使用，在 maven 中添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 还需要在 application.properties 中进行 thymeleaf 配置 123456789# thymeleaf 配置spring.thymeleaf.prefix=classpath:/templates/ // 模版加载位置spring.thymeleaf.suffix=.html // 指定后缀spring.thymeleaf.mode=HTML spring.thymeleaf.encoding=UTF-8 // 指定编码# 热部署文件，页面不产生缓存，及时更新spring.thymeleaf.cache=falsespring.resources.chain.strategy.content.enabled=truespring.resources.chain.strategy.content.paths=/** 初识 Thymeleaf 通过 HTML 的标签属性渲染标签内容 1234567891011121314151617 &lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;link rel="stylesheet" type="text/css" media="all" href="../../css/gtvg.css" th:href="@&#123;/css/gtvg.css&#125;" /&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text="#&#123;home.welcome&#125;"&gt;Welcome to our grocery store!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 语法使用表达式支持语法字面 文本文字（Text literals）:one text, Another one!,... 数字文本 (Number Literals) :0, 34 ,0.4... 布尔文本 (Boolean Literals) : true false 空 (Null Literal): null 文字标记 (Literal Tolers): one, sometext, main... #####文本操作 字符串连接 (String Concatenation): + 文本替换 (Literal Substitutions): |The name is ${name}| 算术运算 二元运算符 (Binary Operators): +, -, *, /, % 减号（单目运算符）Minus sign (Unary Operator): - 布尔操作 二元运算符 (Binary Operators): and, or 布尔否定（一元运算符）Boolean Negation(Unary Operator): !, not 比较和等价 比较 (Comparators): &gt;, &lt;, &gt;=, &lt;=, (gt, lt, ge, le) 等值运算符 (Equality Operators): ==, !=, (eq, ne) 条件运算符 if-then: (if) ? (then) if-then-else: (if) ? (then) : (else) Default:(value)?: defaultvalue 以上所有特征可以被组合，嵌套使用 th: 常用标签 关键字 功能介绍 案例 th:id 替换 id &lt;input th:id=&#39;xxx&#39; + ${collect.id}/&gt; th:text 文本替换 &lt;p th:text=&quot;${user.id}&quot;&gt;id&lt;/p&gt; th:utext 支持 html 的文本替换 &lt;p th:utext=${user.id}&gt;id&lt;/p&gt; th:object 替换对象 &lt;div th:object=&quot;${session.user}&quot;&gt; th:value 属性赋值 &lt;input th:value=&quot;${user.id}&quot;&gt; th:with 变量赋值 &lt;div th:with=&quot;isEven=${user.count}%2==0&quot;&gt;&lt;/div&gt; th:style 设置样式 th:style=&quot;&#39;display:&#39; + @{(${sitrue} ? &#39;none&#39; : &#39;inline-block&#39;)} + &#39;&#39;&quot; th:onclick 点击事件 th:onclick=&quot;&#39;getCollect()&#39;&quot; th:each 属性赋值 tr th:each=&quot;user,userStat:${users}&quot;&gt; th:if 判断条件 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:unless 与 if 判断相反 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:href 链接地址 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt; th:switch 多路选择，配合 th:case 使用 &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case th:switch 的一个分支 &lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt; th:fragment 布局标签，定义一个代码段，方便其他地方引用 &lt;div th:fragment=&quot;alert&quot;&gt; th:include 布局标签，替换内容到引入的文件 &lt;headth:include=&quot;layout ::htmlhead&quot;th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt; th:replace 布局标签，替换整个标签到引入的文件 &lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt; th:selected selected 选择框 th:selected=&quot;(${xxx.id} == ${configObj.dd})&quot; th:src 图片类地址引入 &lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:inline 定义 js 脚本可以使用变量 &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; th:action 表单提交地址 &lt;form action=&quot;subscribe.html&quot; th:action=&quot;@{/subscribe}&quot;&gt; th:remove 删除某个属性 &lt;tr th:remove=&quot;all&quot;&gt; th:attr 设置标签属性，多个属性可以用逗号分隔 比如 th:attr=&quot;src=@{/image/aa.jpg},title=#{logo}&quot;，此标签不太优雅，一般用的比较少。 变量&lt;p&gt;Hello World! &lt;span th:text=&quot;${today}&quot;&gt;&lt;/span&gt;&lt;/p&gt; 假设 today 是变量，使用 ${...} 来表示获取变量的值 URLThymeleaf 对 URL 的处理语法是通过 @{URL} 进行处理。使用 th:href , th:src 等属性进行 URL 渲染。 循环使用较多的对 &lt;table&gt; 进行渲染，可以使用 th:each ，相当于 Java 中 foreach 循环。 条件求值th:if 和 th:unless 属性进行条件判断， th:unless 于 th:if 恰好相反，只有表达式不成立才会执行Swith 结构使用 th:swich，默认属性 default 使用 * 来表示 Utilties为了提高可用性，Thymeleaf 提供了一系列的 Utilty 对象（内置于 Context 中），通过 # 直接访问常用有： #dates, #strings, #lists 等]]></content>
      <categories>
        <category>后端生态</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-异常处理机制]]></title>
    <url>%2F2018%2F11%2F22%2FJava-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[异常处理每个程序在运行时，都会出现不被期望的事，它的出现组织了程序正常执行，这种情况被称为异常。在 Java 语言中提供了解决方法：异常处理机制。 异常处理机制Java 中异常可以是函数运行时引发的，也可是通过 throw 语句抛出。Throwable 类是异常处理的顶级父类。一个对象只有一个 Throable 类，或者说一个对象只有是 Throwable 类的直接或间接实例，他才是一个异常对象，才能被异常处理识别。 Throwable 图中可以可以认识到异常处理类之间关系。Error 和 Exception 继承自 Throwable 类，这俩个类又在对不同的异常做处理， Error: JVM 本身的错误,编译时系统错误Exception: 程序运行时发生的异常 Exception 又被分为 RuntiomeException （运行时异常）和 IOException （IO异常）。 异常处理在 Java 中还被分为检查异常和非检查异常 检查异常 除去 Error 和 RuntiomeException 与其子类，其他的都是检查异常； 什么是检查异常？在代码编译运行之前，编译器要求你对某段代码必须加 try…catch，或者 throws exception。出现这类情况的异常就属于检查异常。解决方式： throws exception ，一直抛出，一直抛到虚拟机处理。2. 使用 try…catch 捕获非检查异常与检查异常相反，编译器不强制处理的异常，包括 Errow 和 RuntimeException 及其子类。处理方式：1. 捕获 2. 继续抛出 3. 不处理Error多数由 Java 虚拟机生成并抛出，大多数错误与代码编写者无关。当错误发生在这里，程序是无法控制和处理，所以程序中无法对异常进行捕获。Exception程序自身可以进行控制和处理。在编写程序过程中，最常见的错误都在这里，比如 RuntimeException 及其子类异常，这些属于非检查异常，一般不需要处理，通常出现错误是程序逻辑错误引发异常。异常处理异常处理关键字 关键字 作用 try 用于监听，将要监听的代码放在 try 语句块之内，当该语句块发生异常，异常抛出 catch 用于捕获异常，捕获 try 语句块之内的异常 finally 不论异常是否发生，该语句块都会被执行，通常用来做资源释放，关闭文件，关闭数据库连接等，不做异常处理。如果在该语句块内使用 return 或 throw 等种植方法语句，直接结束，不会执行 try 或 catch 语句块 throw 用于抛出异常 throws 用在方法签名中，用于声明该方法可能抛出异常 抛出异常定义：一个方法不处理该异常，向上传递。谁调用该方法，谁来处理。关键字 throw 和 throws 区别：throw: 用于方法体内。throw 后接的是异常对象，或者异常对象的引用。throws: 用于方法名后，多个异常使用逗号分隔，检查异常处理时使用该关键字。异常不一定发生。注意：如果在 main 方法使用该关键字，会导致程序终断。 捕获异常使用 try…catch 来捕获异常，try 后可以有多个 catch 可以针对不同的异常进行处理。需要注意的是捕获异常的大小区分，当进行捕获异常时，先要捕获小的异常，再捕获大的异常。 自定义异常已经被封装好的异常处理是通常在写程序中较多出现的错误，而在写程序过程中，会出现某个程序中特有的问题，我们想要进行异常处理，但是这些异常却没有被 Java 封装成对象。所以这时候我们就需要自己来完成所要解决的异常处理。创建自定义异常必须要继承 Throwable 或者它的子类 Excepeiton。 class 自定义异常 extends 异常类型（Exception）{ // 在这里重写有参和无参构造方法 }]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC 源码解读]]></title>
    <url>%2F2018%2F11%2F20%2FSpring-IoC-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Spring IoCIoC(Inversion of Control):Spring 框架中重要的一种理念，之前有过这方面的介绍。这篇主要记录 IoC 实现过程，如何完成控制反转。我们在使用 Spring 时，需要一种描述让 IoC 容器知道创建的对象与对象的关系，这个描述就是我们的可配置文件。（xml, properties）。 BeanFactory可以理解为生产 bean 的工厂，负责管理各个 bean 实例。它是 IoC 容器最基本的接口，提供最基本的 IoC 容器的功能，下面是 BeanFactory 源代码。 123456789101112131415161718192021222324252627282930313233343536 public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; // 根据 bean 的名字，获取容器中 bean 实例 Object getBean(String name) throws BeansException; // 根据 bean 的名字和 Class 类型的到 bean 实例，增加类型安全验证机制 &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; // bean 的索引，检查容器中是否有相同名字的 bean boolean containsBean(String name); // 根据 bean 的名字，得到 bean 的实例，并且判断这个 bean 是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; // 查询制定名字的 bean 是否是 prototyoe 类型，属性可以由用户在 BeanDefinition 中制定 boolean isPrototype(String name) throws NoSuchBeanDefinitionException; // 指定 bean 名字的 Class 类型是否是特定 Class 类型 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; // 得到 bean 实例的 Class 类型 Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; // 得到 bean 的别名 String[] getAliases(String name);&#125; BeanFactory想要分析源码，首先对接口，类的继承关系有一个初步的认识，先要对整体有个宏观概念，为接下来细分代码做准备，从大到小的顺序进行分析源码。BeanFactory 是一个接口，与其他接口关系如下图：实现该接口有三个子接口，ListableBeanFactory,HierarchicalBeanFactory,AutowireCapableBeanFactory。上图可以看出最后默认实现类为 DefaultListableBeanFactory，这是 BeanFactory 重要实现类。图中 ApplicationContext 在 IoC 容器扮演者重要的角色，ApplicationContext 启动过程中，负责创建实例 Bean，往各个 Bean 中注入依赖等。 ApplicationContextSpring 提供了许多 IoC 容器的实现，如上图所示: ClassPathXmlApplication, FileSystemXmlApplication, AnnotationConfigApplicationContext.在这三个类中，都有一个重要的方法 refresh() 。该方法作为初始化 IoC 容器的入口，这一方法属于核心方法，重点分析。在这里我们使用 ClassPathXmlApplicationContext 继续解读 Spring IoC 整个过程。 123456789101112131415161718 public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123; private Resource[] configResources; // 如果已经存在 ApplicationContext 需要调用此方法配置成父子关系 public ClassPathXmlApplicationContext(ApplicationContext parent) &#123; super(parent); &#125; ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); // 根据提供路径，解析配置文件 this.setConfigLocations(configLocations); if (refresh) &#123; this.refresh(); // 核心方法 &#125; ... &#125;&#125; IoC 容器初始化过程当执行 refresh(()。标志着 IoC 容器正式启动，会经历三个基本的过程，包括定位，载入，注册。执行 refresh() 方法会将原来的 ApplicationContext 销毁，然后重新执行一次初始化操作。 1234567891011121314151617181920212223242526272829303132333435363738public void refresh() throws BeansException, IllegalStateException &#123; Object var1 = this.startupShutdownMonitor; // 防止 refresh（）还没有结束，又来一个启动或者执行操作 synchronized(this.startupShutdownMonitor) &#123; // 准备工作，记录容器启动时间 this.prepareRefresh(); // 执行完这步后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，但是这步还没有将 Bean 初始化，只是将配置文件中信息解析出来。 ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); // 设置 BeanFactory 类加载器， this.prepareBeanFactory(beanFactory); try &#123; this.postProcessBeanFactory(beanFactory); this.invokeBeanFactoryPostProcessors(beanFactory); this.registerBeanPostProcessors(beanFactory); this.initMessageSource(); this.initApplicationEventMulticaster(); this.onRefresh(); this.registerListeners(); // 初始化所有 singleton beans （lazy-init 的除外） this.finishBeanFactoryInitialization(beanFactory); // ApplicationContext 初始化完成，结束 refresh() 过程 this.finishRefresh(); &#125; catch (BeansException var9) &#123; if (this.logger.isWarnEnabled()) &#123; this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9); &#125; // 销毁已经初始化的 singleton beans ，防止资源占用 this.destroyBeans(); this.cancelRefresh(var9); throw var9; &#125; finally &#123; this.resetCommonCaches(); &#125; &#125; &#125; 看过 refresh() 方法整体内容后，开始逐步分解代码。prepareRefresh() 该方法是穿件 Bean 容器前的准备工作，比如 记录容器启动时间就在该方法里设置。 Resource定位准备工作结束后，代码执行到 obtainFreshBeanFactory() 方法，该方法非常重要，初始化 BeanFactory，加载 Bean， 注册 Bean，都会在该方法内进行完成。（Bean 实例并不在这里完成）。 12345678910protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; this.refreshBeanFactory(); // 返回刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = this.getBeanFactory(); if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Bean factory for " + this.getDisplayName() + ": " + beanFactory); &#125; return beanFactory; &#125; 这里最重要的过程在 refreshBeanFactory() 中，Spring IoC 容器启动从这里开始。该方法是 AbstractApplicationContext 中的抽象方法。具体实现不在这里，而是在它的子类中实现， 1234567891011121314151617181920 protected final void refreshBeanFactory() throws BeansException &#123; // 如果之前加载过 BeanFactory ，销毁所有 Bean ，关闭 BeanFactory,这里不是只全局 BeanFactory ,只是指当前 ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex); &#125;&#125; 先执行refreshBeanfactory()判断完是否有工厂后，开始载入 Bean 的定义，先经过方法customizeBeanFactory(beanFactory);该方法的作用是是否容许 BeanDefinition 覆盖,是否容许循环应用。这里就可以帮助我们解答在刚学习 Spring 时遇到的在配置文件中定义 bean 时使用了相同的 id 或 name 的问题，如果同意配置文件中重复，会抛错，不是同一个配置文件中，会覆盖。 接着是 loadBeanDefinitions(beanFactory)。此方法根据配置，加载各个 Bean ,然后放到 BeanFactory 中。接着我们到 AbstractRefreshableApplicationContext 类下找到 loadBeanDefinitions方法，在 AbstractXmlApplicationContext 类下找到该方法 12345678910111213protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); initBeanDefinitionReader(beanDefinitionReader); // 从这里出发继续分析源码 loadBeanDefinitions(beanDefinitionReader);&#125; 按照 loadBeanDefinitions(beanDefinitionReader) 继续查找，接着来到 AbstractXmlApplicationContext 类下。 12345678910 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; 这里有俩个分支，先选择第一个分支。接着到 BeanDefinitionReader 接口下。找到 loadBeanDefinitions 方法 12345678 public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123; Assert.notNull(resources, "Resource array must not be null"); int counter = 0; for (Resource resource : resources) &#123; counter += loadBeanDefinitions(resource); &#125; return counter;&#125; 来到 BeanDefinitionReader 接口，在 XmlBeanDefinitionReader 类中找到 loadBeanDefinitions 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, "EncodedResource must not be null"); if (logger.isInfoEnabled()) &#123; logger.info("Loading XML bean definitions from " + encodedResource.getResource()); &#125; // 存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( "Detected cyclic loading of " + encodedResource + " - check your import definitions!"); &#125; try &#123; // 将资源文件转换为 IO 输入流 InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 从这里继续查找，这里是具体读取过程的方法 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( "IOException parsing XML document from " + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; // 将 XML 文件转换为 DOM 对象 Document doc = doLoadDocument(inputSource, resource); // 启动时 Bean 定义解析详细过程， return registerBeanDefinitions(doc, resource); &#125; ......&#125; 接着 registerBeanDefinitions 继续分析 1234567891011121314151617181920 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; // 对 XML 格式的 BeanDefinition 解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 获得容器中注册的 Bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // 解析过程入口， documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 统计解析 Bean 数量 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; BeanDefinitionDocumentReader 是一个接口，具体实现类在 DefaultBeanDefinitionDocumentReader public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug("Loading bean definitions"); // 获取根元素 Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; 真正开始解析配置文件里内容是由 doRegisterBeanDefinitions(root); 方法开始解析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 protected void doRegisterBeanDefinitions(Element root) &#123; // 该类负责解析 Bean 定义 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Skipped XML bean definition file due to specified profiles [" + profileSpec + "] not matching: " + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; &#125; `parseBeanDefinitions(root, this.delegate);` 核心方法，负责解析 &lt;bean&gt; 标签 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; // 遍历根元素所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); // 如果节点是 XML 元素节点 if (node instanceof Element) &#123; Element ele = (Element) node; // 如果节点使用的是 Spring 默认 XML 命名空间 if (delegate.isDefaultNamespace(ele)) &#123; // 使用 Spring 的 Bean 规则解析元素节点 parseDefaultElement(ele, delegate); &#125; else &#123; // 如果没有使用 Spring 默认的 Bean 命名空间，使用用户自定义的解析规则解析元素（自定义的 xsd） delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; // 根节点没有使用 Spring 默认命名空间，使用用户自定义规则解析 delegate.parseCustomElement(root); &#125; &#125; 以上方法主要是判断是否为 Spring 默认命名空间，接着我们看使用 Spring 默认命名空间后，执行 parseDefaultElement(ele, delegate); 方法。 123456789101112131415161718 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 如果节点是 import 导入元素，进行解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; // 如果元素节点是 Alias 别名元素，进行别名解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; // 如果是普通 Bean 元素，进行 Spring 的 Bean 规则解析 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // 如果碰到嵌套 beans 标签，需要递归 doRegisterBeanDefinitions(ele); &#125;&#125; 直接来到 Bean 规则解析，这里的 DeanDefinitionHolder 是对 BeanDefinition 的封装，包括 BeanDefinition, beanName, aliases 12345678910111213141516 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 向 Spring IoC 容器注册解析得到的 Bean 定义 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error("Failed to register bean definition with name '" + bdHolder.getBeanName() + "'", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 在进行标签解析之前，先回顾 标签里可以定义的属性 Property - calss 类的全限定名 name 可指定 id, name (用逗号，分号，空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autoworting mode no(默认值),byName,byType,constructor lazy-initialization mode 是否类加载 initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 将 name 属性的定义按照 逗号 分号 空格 切分，形成一个别名列表组 List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; // 如果没有指定 id，那么用别名列表的第一个名字作为 beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug("No XML 'id' specified - using '" + beanName + "' as bean name and " + aliases + " as aliases"); &#125; &#125; // 检查 &lt;bean&gt; id 和 name 的唯一性。 if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; // 从这里对 &lt;bean&gt; 元素详细解析 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; // 如果 &lt;bean&gt; 没有配置 id, name, 或者别名，为解析的 bean 生成一个唯一 beanName 并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); // String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; // beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Neither XML 'id' nor 'name' specified - " + "using generated bean name [" + beanName + "]"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; parseBeanDefinitionElement中放着具体参数配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; // 记录解析 Bean this.parseState.push(new BeanEntry(beanName)); // 读取配置的 class 名字，然后记录到 BeanDefinition 中，并不做实例化 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; // 如果配置了 parent 属性，获取 parent 属性的值 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析 &lt;bean /&gt; 内部的子元素，解析的星系放到 bd 中 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error("Bean class [" + className + "] not found", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error("Class that bean class [" + className + "] depends on not found", ele, err); &#125; catch (Throwable ex) &#123; error("Unexpected failure during bean definition parsing", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 以上的代码内容就可解释在使用 Spring 是，配置文件中 标签中的属性是如何解析到 Bean 中。在上述解析过程中并没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类 BeanDefinition, 将 中配置信息设置到 BeanDefinition 中作为记录。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC]]></title>
    <url>%2F2018%2F10%2F20%2FSpring-IoC%2F</url>
    <content type="text"><![CDATA[认识Spring IoC DI 依赖注入 Dependency Injection IoC 控制反转 Inversion of Control IOC Container 容器 Inversion of Control Container 理解 IoC DIIoC (Inversion of Control) 控制反转，是由软件专家 Michael Mattson 提出的一个理论，用于解决复杂系统中的耦合关系。后来这个理论被逐渐应用到实践中，例如 J2EE 中的 Spring 框架中，IoC 就成为核心功能实现。 IoC(Inversion of Control)Spring IoC(Inversion of Control) 别名 DI(Dependency Injection) 依赖注入，而事实上二者并非相同。IoC(Inversion of Control)是面向对象的一种思想，DI(Dependency Injection)是实现这一思想的方法。 控制反转是目的，依赖注入是实现控制反转的手段。控制反转是将某个类对其内部状态权交给其他机制去完成，为降低类与类之间的耦合度。这个时候就出现了一个新的概念 IoC Container 称为 IoC 容器，在这里面从放着所有类与类依赖关系的方法，这时候 IoC 容器就充当着一个第三方角色，想要解决某个问题直接告诉 IoC 容器，它为我们找到解决问题的方式。 DI(Dependency Injection)DI(Dependency Injection)依赖注入 就是在 IoC 容器运行期间动态的将某种依赖关系注入到对象中，实现 IoC 的方法。利用依赖关系的注入的方式，实现对象之间的结耦。IoC 容器就是一个对象的制造工厂，当你使用某个功能时，你只要调用其方法就可以实现。你的关注点只在如何使用，至于其方法是如何创建，何时销毁等不需要关心，这一切都是由 IoC 容器进行实现。 实例当我们打开机械手表后，会看到上图所示的场景，各个齿轮带动时针，分针，秒针的转动，相互依赖，从而在表盘上产生正确的时间。但是当其中某个齿轮损坏后，整个系统可能将停止运转，之间存在这复杂的耦合关系。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。为了有效的避免出现这样的问题，我们对其引入 IoC(Inversion of Control)来解决。 当我们引入 IoC 容器后，我们可以发现其中 A,B,C,D这四个齿轮不再是相互依赖的关系，而是共同依赖于 IoC 容器这个第三方的，IoC 容器成为整个系统的一个核心，A,B,C,D四个齿轮的转动都依赖于 IoC 容器。 ##文档参考： Dependency Injection Inversion of Control Containers and the Dependency Injection pattern]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC]]></title>
    <url>%2F2018%2F07%2F30%2FSpring-MVC%2F</url>
    <content type="text"><![CDATA[Spring-MVC 认识要学习使用 Sring-MVC 需要了解，掌握一副图，展示了它的工作原理。需要理解并记牢每一步的所要完成的任务。 用户发送一个请求，请求先到达 DispatcherServlet ，它需要知道，应该将请求交给哪一个控制器去处理请求 DispatcherServlet 会去 Hander Mapping （处理器映射）查询下一站应该去何处。Hander Mapping 会将 DispatcherServlet 携带的 URL 进行判断，将结果告诉 DispatcherServlet ，然后将请求送达对应的控制器 控制器进行数据逻辑处理，处理后会产生用户所需要的信息（Model），还需要一个展示模型的页面（JSP）,控制器将处理完的结果进行整理（ModelAndView）,返回给 DispatcherServlet 这时候的虽然得到了 ModelAndView ，但是这里的 View 仅仅是一个逻辑名称，所以接下来需要将信息交给 ViewResolver（视图解析器）进行处理，返回一个相应的页面。 最后将解析完成的 ModelAndView 返回给用户。 到这结束用户的发送的一次请求到响应完成。接下来应该逐步认识需要做的配置 DispatcherServletDispatcherServlet（中央调度器）继承 HttpServlet ,所以我们要对 DispatcherServlet 进行所需要的配置就应该在 web.xml 中进行声明。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 完成一个处理 “.do” 结尾的请求处理。在初始化 DispatcherServlet 得时候，如果不配置 ，Spring-MVC 默认会去 /WEB-INF 寻找 [servlet-name]-serlvet.xml 文件，例如：如果此 DispatcherServlet 不配置 ，它会在 /WEB-INF/springmvc-servlet.xml ,没有找到该配置文件，出异常报错。建议大家在此配置 contextConfigLocation ,如果不在 WEB-INF 目录下，要用 classpath: 指出该配置文件的路径。 上面说到该配置会处理一个 “.do” 结尾的请求处理，是因为我们在 中配置了 *.do 拦截请求方式，我们还可以进行其他的配置，产生不同的作用。 配置 / ：此工程所有的请求全部由 Spring-MVC 解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由 Spring-MVC 解析 配置 .do 或者 .action , 所有请求的 url 扩展名为 .do 或 .action 由 Spring-MVC 解析（建议使用此方法） 不可以配置 / ,如果配置 / ,返回 JSP 也由 Spring-MVC 解析，这是不对的 ViewResoler（视图解析器）当请求到达 ViewResoler ，需要完成一个任务，就是告诉 DispatcherServlet 该请求应该得到哪一个页面。我们需要配置一个视图解析器完成此操作。根据上述 DispatcherServlet 的配置信息，需要找到 spring 文件夹下的 spring-mvc.xml 进行配置。 1234&lt;bean id="resourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 进行该配置后，每次对请求的是图处理都会按照 此方式进行解析。如果我们使用 Spring-MVC 的注解，需要在该配置文件下，引入 mvc 命名空间，用 mvc:annotation-driven/ 进行声明]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring-MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-关键字volatile]]></title>
    <url>%2F2018%2F05%2F09%2FJava-%E5%9F%BA%E7%A1%80-%E5%85%B3%E9%94%AE%E5%AD%97volatile%2F</url>
    <content type="text"><![CDATA[Java 内存模型Java 内存模型定义：屏蔽掉各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下能达到一致的内存访问效果。避免更换平台后在并发问题上出现访问错误。 在 Java 内存模型中规定所有变量存储在主内存中，每一个线程都有自己工作内存，每个线程都有对变量的读取操作都是在自己的工作内存中操作，线程之间不会有通讯，比如线程 A 对一个变量进行修改，此时的线程 B 并不知道线程 A 在对变量进行修改。线程对变量处理完成后到会写到主内存中，主内存内实现线程之间的变量值传递。 下图为线程、工作内存、主内存之间的关系 volatile在 Java 内存模型中每个线程都有自己的工作内存，比如在并发情况下的 （i++），当线程 A 先进行 i++ ，此时是在自己的工作内存中进行运算，还没有写到主内存中，线程 B 也在进行 i++ ，也在对 i 变量做更改，再写入主内存中，就会造成数据不一致。只要让在并发的过程中数据进行同步就可避免问题出现，在 Java 中提供的关键字 volatile 就可以解决此类问题 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 主要用于处理多线程问题，处理指令重排序问题，在 Java 1.5 之后解决指令重排序问题，实现多线程下的单例模式。能保证可见性，有序性，但不保证原子性。 原子性：一个操作不可中断，要么全部执行通过，要么全部执行失败 可见性：一个线程对某一个共享数据的修改，其他线程立即获得更新 有序性：本线程内看指令执行是有序的，另一个线程观察到的是无序的 第二条中说禁止进行指令重排序在多线程的单例模式中发挥重要的作用,指令重排序主要是指在硬件方面，CPU 采用了容许将多条指令不按规定顺序分开发送给各相应电路单元处理，并不是指令任意重排，对于两条指令有依赖，还会按原来顺序处理，只会对没有依赖的指令进行重排，比如在多线程情况下解决以下代码问题 singleton = new Singleton(); 在单线程情况下，该段代码会分成三部 分配内存 实例化对象 将实例化对象给 singleton 赋值 这三个过程是没有依赖，在工作内存中无论怎样排序执行都不会影响最后写入到主内存中的数据，但是在多线程情况下，比如多线程单例模式中的，双重检查锁，如果没有之前的 volatile 修饰变量，会出现线程 A 进入实例化代码块内，进行实例化，此时有可能重排序，先执行第三步，此时的 singleton 还是为空，线程 B 进行判断为空，也会进入执行代码块内，就会出现实例化多个对象，违反了单例模式的定义。 解决此类问题可以使用，关键字 volatile ，它的工作原理是，当多个线程进行处理同一变量，在执行被 volatile 关键字修饰的代码时，会在编译代码后添加一句 lock add1 $0x0, (%esp)，充当一个内存屏障操作，保证线程之间的可见性。 内存屏障（Memory Barrier）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。 加上内存屏障之后，其实实例化代码还是会重排序，但是一旦一个线程进行访问处理，其他线程就不会执行同样的代码块，相当于一但开始对被 volatile 修饰的变量进行处理，改变量的读写操作只容许一个线程访问，其他线程没有权利进行读写操作。 volatile是通过内存屏障来来禁止指令重排的。 参考 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-线程进阶]]></title>
    <url>%2F2018%2F04%2F30%2FJava-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[线程之前的学习我们知道，线程是比进程更轻量级的调度执行单位，线程把进程的资源分配和执行调度分开，线程可共享进程资源(内存地址，问价 I/O 等)，又可独立调度( CPU 是调度的基本单位) 线程调度线程调度是指系统为线程分配的处理器 分为两种 协同式线程调度 抢占式线程调度 Java 语言中使用的是抢占式线程调度，线程的调度不由本身决定，在整个的运行期间线程是可控的，不会发生某个线程的异常从而导致整个进程的阻塞。使用优先级来判断执行顺序，之前介绍过在 Java 中线程优先级分为 10 个等级，优先级越高，越容易被执行。另一种协同式线程调度同样属于多线程调度，与抢占式线程调度的工作方式不同，使用协同式线程调度的系统，线程的执行时间由线程本身来决定，只有当一个线程执行执行完毕，然后通知系统切换另一个线程，与串行概念相同。使用该方式避免了线程同步的概念，只有一个线程执行完毕后，才会执行下一个。但是如果某个线程出现编写问题，一直不告诉系统需要切换下一个线程，那么程序就会一直阻塞在哪里，会导致系统的崩溃。 线程状态转换一个线程有五种状态，创建，运行，等待，阻塞，终止。五种状态之间是如何转换的，下图很清晰的为我们解释清楚他们之间的状态转换切记在任意时间点，一个线程有且只有一种状态。 线程的三大特性原子性 (Atomicity)原子性是指一个操作不可中断，一旦一个操作开始，就不会被其他的线程干扰，比如给 i 进行赋值，线程 A 赋值 1，线程 B 赋值 -1。i 的值要么是 1 ，要么是 -1，线程 A 和 线程 B 之间没有干扰，赋值过程中不可被中断 可见性 (Visibility)当一个线程对某一个共享数据进行修改，其他的线程能否知道这个修改。在 Java 中可见性可以通过关键字 synchronized 和 final 来实现。 有序性 (Ordering)在 Java 语言中提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。Java 内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。 线程安全线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。—《Java Concurrency Inpractice》作者 Brian Goetz。 如何实现线程安全加锁，互斥同步 同步：是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用，保证数据的安全性。 互斥是因，同步是果；互斥是方法，同步是目的。 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，也称为阻塞同步。实现互斥方法需要使用关键字 synchronized 。 使用一个带有 synchronized 和 不带有 synchronized 案例来进行比较编写一个类实现 Runnable 接口 12345678910111213141516class MyThread implements Runnable &#123; private int val = 10; public void run() &#123; while (val &gt; 0) &#123; show(); try &#123; Thread.sleep(100); // 睡眠一秒实现线程交替执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void show()&#123; System.out.println(Thread.currentThread().getName() + " = " + val--); &#125;&#125; 添加测试类 123456789public class Thread_1 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); Thread thread1 = new Thread(myThread); thread.start(); thread1.start(); &#125;&#125; 运行结果 123456789101112Thread-0 = 10Thread-1 = 9Thread-1 = 8Thread-0 = 7Thread-1 = 6Thread-0 = 6Thread-0 = 5Thread-1 = 4Thread-0 = 3Thread-1 = 3Thread-0 = 2Thread-1 = 1 这里我们先不加 synchronized ，从结果可以看出数据没有同步，有错误，对同一个数据进行修改，没有实现线程安全。接下来修改 show() 方法，再词比较结果 12345public void show()&#123; synchronized (MyThread.class)&#123; System.out.println(Thread.currentThread().getName() + " = " + val--); &#125; &#125; 修改后的结果为 12345678910Thread-0 = 10Thread-1 = 9Thread-0 = 8Thread-1 = 7Thread-1 = 6Thread-0 = 5Thread-1 = 4Thread-0 = 3Thread-1 = 2Thread-0 = 1 由运行结果清楚可知论哪一个线程进入，对于数据修改都进行同步，没有出现数据不匹配，实现了线程安全。这里实现线程安全的方式只是加锁，但是遇到问题就给加锁是不可取的对数据进行读写操作需要加锁，如果代码中没有进行变量的交互，线程之间不会造成影响，也称线程安全。互斥同步属于一种悲观的并发策略，只要是不去做正确的同步措施，数据肯定会出现问题。无论共享数据是否真的会出现竞争，都要进行加锁（实际上可以优化掉部分不必要的锁）。这里只是简单使用了 synchronzied ，锁的知识还需要深入挖掘分析，后面会详细写一篇关于锁的学习记录。 不共享状态 无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。 线程关闭： 仅在单线程环境下使用。 不可变对象使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-线程入门]]></title>
    <url>%2F2018%2F04%2F29%2FJava-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[线程(Thread)线程区别于进程 进程：是一个程序的执行过程，是系统中程序的基本单位。运行一个程序即执行一个进程，一个程序对应一个进程，二者创建于销毁等同。 线程：与进程相似，线程比进程的执行单位更小，一个进程中可以创建多个线程，多个线程可以共享同一个内存空间和系统资源。 并发和并行 并行：多个 cpu 实例或者多台机器同时执行一段处理逻辑代码。多核 cpu，每个 cpu 有自己运算器，在多个 cpu 中可以同时运行 并发：多个任务交替执行，多线程单核 cpu 是顺序执行。 线程状态 新生线程 使用操作符 new 例如 new Thread(r) 这里只是创建一个线程，并没有开始运行线程 可运行线程 标志是调用 start() 方法 被阻塞线程 等待线程 被终止线程 被阻塞和等待，当处于这三个状态时，程序不运行任何代码，直到线程调度器重新激活， 线程调度器：会决定哪个线程从等待或者被阻塞状态中挑选出来,何时把某个线程送回等待执行状态.它会决定某个线程运行多久。无法去控制调度，它是不确定。调度不能保证任何执行时间和顺序，不能期待它完全平均分配执行，可以用sleep()来保证时间，向该方法传入的时间单位为毫秒。 线程被终止的两个原因： run 方法的正常退出而自然死亡 一个没有捕获的异常终止了 run 方法而意外死亡 调用 stop 方法也可杀死一个线程，该方法抛出 ThreadDeath 错误对象，不建议使用 stop，该方法已经过时 线程属性 线程优先级守护线程线程组处理未捕获异常处理器 线程优先级默认情况下线程继承它的福线程的优先级，想改变该线程的优先级就需要调用 setPriority(int newPriority) 来设置线程的优先级。newPriority取值范围为 MIN_PRIORITY 到 MAX_PRIORITY 之间（1 ～ 10），通常情况下取值为 NORM_PRIORITY （5） 守护线程为非守护线程提供服务的一个线程，例如一个程序中如果只剩下守护线程时，该程序就该终止运行，守护线程是一个程序结束的最后一步。使用 setDaemon(boolean isDaemon)设置守护线程。 处理未捕获异常处理器线程执行完 run 方法会正常退出。如果该线程中发生了没有捕获的异常，就会造成线程死亡，异常退出。解决方法是在线程死亡之前将异常交给一个用于未捕获异常的处理器。JVM 为我们提供了线程的未捕获异常处理器，通过 Thread 的 setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 来设置，为所有线程添加一个处理器。 线程组如果上述过程没有发生，没有为所有线程添加处理器，那么默认的处理器就是该线程的 ThreadGroup 对象。线程组是一个可以统一管理的线程集合，默认情况下创建的所有线程属于相同的线程组。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-集合框架]]></title>
    <url>%2F2018%2F04%2F24%2FJava-%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
