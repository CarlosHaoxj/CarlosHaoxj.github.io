<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[asd]]></title>
    <url>%2F2018%2F11%2F20%2Fasd%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC]]></title>
    <url>%2F2018%2F10%2F20%2FSpring-IoC%2F</url>
    <content type="text"><![CDATA[认识Spring IoC DI 依赖注入 Dependency Injection IoC 控制反转 Inversion of Control IOC Container 容器 Inversion of Control Container 理解 IoC DIIoC (Inversion of Control) 控制反转，是由软件专家 Michael Mattson 提出的一个理论，用于解决复杂系统中的耦合关系。后来这个理论被逐渐应用到实践中，例如 J2EE 中的 Spring 框架中，IoC 就成为核心功能实现。 IoC(Inversion of Control)Spring IoC(Inversion of Control) 别名 DI(Dependency Injection) 依赖注入，而事实上二者并非相同。IoC(Inversion of Control)是面向对象的一种思想，DI(Dependency Injection)是实现这一思想的方法。 控制反转是目的，依赖注入是实现控制反转的手段。控制反转是将某个类对其内部状态权交给其他机制去完成，为降低类与类之间的耦合度。这个时候就出现了一个新的概念 IoC Container 称为 IoC 容器，在这里面从放着所有类与类依赖关系的方法，这时候 IoC 容器就充当着一个第三方角色，想要解决某个问题直接告诉 IoC 容器，它为我们找到解决问题的方式。 DI(Dependency Injection)DI(Dependency Injection)依赖注入 就是在 IoC 容器运行期间动态的将某种依赖关系注入到对象中，实现 IoC 的方法。利用依赖关系的注入的方式，实现对象之间的结耦。IoC 容器就是一个对象的制造工厂，当你使用某个功能时，你只要调用其方法就可以实现。你的关注点只在如何使用，至于其方法是如何创建，何时销毁等不需要关心，这一切都是由 IoC 容器进行实现。 实例当我们打开机械手表后，会看到上图所示的场景，各个齿轮带动时针，分针，秒针的转动，相互依赖，从而在表盘上产生正确的时间。但是当其中某个齿轮损坏后，整个系统可能将停止运转，之间存在这复杂的耦合关系。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。为了有效的避免出现这样的问题，我们对其引入 IoC(Inversion of Control)来解决。 当我们引入 IoC 容器后，我们可以发现其中 A,B,C,D这四个齿轮不再是相互依赖的关系，而是共同依赖于 IoC 容器这个第三方的，IoC 容器成为整个系统的一个核心，A,B,C,D四个齿轮的转动都依赖于 IoC 容器。 ##文档参考： Dependency Injection Inversion of Control Containers and the Dependency Injection pattern]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 初相识]]></title>
    <url>%2F2018%2F10%2F16%2FMyBatis-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[认识 MyBatiesMyBatist 是 apache 一个开源项目 iBatis, 2010年这个项目由 apache software foundation 迁移到 google code,并改名为 MyBatis。属于 java 持久层框架，它的主要作用就识负责跟数据库进行交互。MyBatis 是对 jdbc 一个封装。 了解 MyBatiesSqlSessiinFactorySqlSessionFactory 是每一个 MyBatis 的实例中心。在一个应用中一个数据库只会对应一个 SqlSessionFactory。通常通过 spring 配置来实现 SqlSessionFactory。SqlSessionFactory 作用是创建 SqlSession。在应用整个运行时期一直存在。 SqlSessionSqlSession 作用是对数据库进行操作，我们直接调用 SqlSession 接口就可以对数据库进行操作。 SqlSession 是不可以被共享，线程不安全的，完成一次请求响应，打开一个 SqlSession,使用完成就将其关闭。当 MyBaties 进行 CRUD 时可以直接利用 SqlSession 访问 Mapper 配置文件里面的映射进行操作。 MapperMyBatis 强大在于它的映射语句。与 JDBC 相比会较少代码量。 常用属性有 id 当前命名空间唯一标识 type 类型别名 property 映射到列结果的字段或属性 column 数据库中的列名 resultType resultMap 返回数据类型 parameterType 传入的参数格式 flushCache 是否清空缓存 默认为 false useCache 是否二级缓存 默认值对 select 元素为 true – select&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt; SELECT * FROM PERSON WHERE ID = #{id} &lt;/select&gt; 基础的 sql 语句，通过 id 到 PERSON 查结果 resultType: 直接表示返回类型 resultMap：是对外部 resultMap 的引用 当我们使用 select 映射的时，返回值类型可以用 resultType 或者 resultMap。但是俩个不可以同时使用。resultMap 示例 &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.carlos.entiy.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt; &lt;/resultMap&gt; resuletMap 还包含其他元素 constructor 实例化类将结果注入到构造方法中。 result 注入到 JavaBean 属性的普通结果，与 id 表示的结果相同，id 是对象的标识属性 association 返回结果为一个对象时使用，不同于 collection collection 返回结果为一个集合时使用]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2018%2F07%2F31%2FJDBC-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[介绍JDBC (java database connectivity):Java数据库连接，就是用Java语言来操作数据库。主要由接口组成， 四大参数 driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql:/localhost:3306/数据库名 username: 用户名 password: 密码 连接数据库配置参数完成后，使用 DriverManager.getConnection() 方法建立连接，加载驱动。加载驱动除了上述方法，还可以使用 DriverManager.registerDriver(new Driver()) 不推荐使用该方法，原因有俩个： 采用此方法会导致驱动程序注册俩次，内存中会有俩个 Driver 对象。 程序依赖 mysql 的 api ,脱离 mysql 的 jar 包，程序无法编译，将来程序切换底层数据库会非常麻烦。 ConnectionDriverManager.getConnection() 该方法通过 Connection 类实现。该类用于数据库的连接操作。常用方法有： createStatement():向数据库发送 sql 的 statement 对象 prepareStatement(sql):向数据库发送预编译 sql 的 PrepareSatement 对象 prepareCall(sql):创建执行存储过程的 callableStatement 对象 setAutoConmmit(boolean autoCommit):设置事务是否提交 commit():在链接上提交事务 rollback():在此链接上回滚事务 数据交互通过 Connection 与数据库建立连接以后，可以通过 Statement PreparedStatement CallableStatement。这三个接口用于与数据库交互的实现。 Statement用于对数据库进行访问，主要用于向数据库发送 sql 语句。常用方法有： executeQuery(String sql):向数据库发送查询语句 executeUpdate(String sql):向数据库发送 insert, update, delete 语句 execute(String sql):向数据库发送任意 sql 语句 addBatch(String sql)：把多条 sql 语句放到一批处理 executeBatch():向数据去发送一批 sql 语句执行 在使用 Statement 执行 sql 语句之前需要使用 Connection 对象的 createSatement() 方法进行建立一个 Statement 对象。 PreparedStatement该接口扩展了 Statement 接口，可以动态提供\接受参数。该接口下有 setXXX() 方法，该方法将值绑定到参数，其中 XXX 表示要绑定到输入参数的值的 Java 数据类型。 例：setString(1, *.getName()); 1 表示索引位置（从 1 开始计数）。代表 JDBC 中第一个占位符 （?）。在 sql 语句中表示一个占位符。 ResultSetResulSet 是一个接口，在 JDBC 中 ResultSet 用于返回一个 sql 执行后的结果集。 关闭资源在完成一次增，删，改，查操作后，每次执行完成都需要调用 .close() 关闭资源。如果数据库连接代码在 try/catch 代码块中完成，关闭操作代码放在 finally 中。需要注意关闭代码顺序：先得到的对象后关，后得到的对象先关。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC 初相识]]></title>
    <url>%2F2018%2F07%2F30%2FSpring-MVC%2F</url>
    <content type="text"><![CDATA[Spring-MVC 认识要学习使用 Sring-MVC 需要了解，掌握一副图，展示了它的工作原理。需要理解并记牢每一步的所要完成的任务。 用户发送一个请求，请求先到达 DispatcherServlet ，它需要知道，应该将请求交给哪一个控制器去处理请求 DispatcherServlet 会去 Hander Mapping （处理器映射）查询下一站应该去何处。Hander Mapping 会将 DispatcherServlet 携带的 URL 进行判断，将结果告诉 DispatcherServlet ，然后将请求送达对应的控制器 控制器进行数据逻辑处理，处理后会产生用户所需要的信息（Model），还需要一个展示模型的页面（JSP）,控制器将处理完的结果进行整理（ModelAndView）,返回给 DispatcherServlet 这时候的虽然得到了 ModelAndView ，但是这里的 View 仅仅是一个逻辑名称，所以接下来需要将信息交给 ViewResolver（视图解析器）进行处理，返回一个相应的页面。 最后将解析完成的 ModelAndView 返回给用户。 到这结束用户的发送的一次请求到响应完成。接下来应该逐步认识需要做的配置 DispatcherServletDispatcherServlet（中央调度器）继承 HttpServlet ,所以我们要对 DispatcherServlet 进行所需要的配置就应该在 web.xml 中进行声明。 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 完成一个处理 “.do” 结尾的请求处理。在初始化 DispatcherServlet 得时候，如果不配置 ，Spring-MVC 默认会去 /WEB-INF 寻找 [servlet-name]-serlvet.xml 文件，例如：如果此 DispatcherServlet 不配置 ，它会在 /WEB-INF/springmvc-servlet.xml ,没有找到该配置文件，出异常报错。建议大家在此配置 contextConfigLocation ,如果不在 WEB-INF 目录下，要用 classpath: 指出该配置文件的路径。 上面说到该配置会处理一个 “.do” 结尾的请求处理，是因为我们在 中配置了 *.do 拦截请求方式，我们还可以进行其他的配置，产生不同的作用。 配置 / ：此工程所有的请求全部由 Spring-MVC 解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由 Spring-MVC 解析 配置 .do 或者 .action , 所有请求的 url 扩展名为 .do 或 .action 由 Spring-MVC 解析（建议使用此方法） 不可以配置 / ,如果配置 / ,返回 JSP 也由 Spring-MVC 解析，这是不对的 ViewResoler（视图解析器）当请求到达 ViewResoler ，需要完成一个任务，就是告诉 DispatcherServlet 该请求应该得到哪一个页面。我们需要配置一个视图解析器完成此操作。根据上述 DispatcherServlet 的配置信息，需要找到 spring 文件夹下的 spring-mvc.xml 进行配置。 &lt;bean id=&quot;resourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 进行该配置后，每次对请求的是图处理都会按照 此方式进行解析。如果我们使用 Spring-MVC 的注解，需要在该配置文件下，引入 mvc 命名空间，用 mvc:annotation-driven/ 进行声明]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring - AOP]]></title>
    <url>%2F2018%2F07%2F20%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[spring - AOPAOP （aspect object programming） 称为面向切面编程。可以理解为一个拦截框架，类似 Servlet 中的 Filter ，思想相同。 AOP基本概念 连接点（Jointpoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为“在哪里干”； 切入点（Pointcut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为“在哪里干的集合”； 通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为“干什么”； 方面/切面（Aspect）：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为“在哪干和干什么集合”； 引入（inter-type declaration）：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为“干什么（引入什么）”； 目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁干”； AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。 织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。 通知分类 前置通知（Before Advice）：在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）； 环绕通知（Around Advices）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。 后置通知（After Advice）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知： 后置返回通知（After returning Advice）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。 后置异常通知（After throwing Advice）: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。 后置最终通知（After finally Advice）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。 AOP 注解使用编写切入点 execution(* 方法所属类.方法(..)) @Aspect 指定一个类为切面类 @Pointcut(“execution(* com.carlos.pointCut(..))”) 指定切入点表达式 @Before(“pointCut()”) 前置通知: 目标方法之前执行 @After(“pointCut()”) 后置通知：目标方法之后执行（始终执行） @AfterReturning(“pointCut()”) 返回后通知： 执行方法结束前执行(异常不执行) @AfterThrowing(“pointCut()”) 异常通知: 出现异常时候执行 @Around(“pointCut()”) 环绕通知： 环绕目标方法执行 executionexecution是使用的最多的一种Pointcut表达式，表示某个方法的执行，其标准语法如下。execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?) modifiers-pattern表示方法的访问类型，public等；（修饰类型，可以不写） ret-type-pattern表示方法的返回值类型，如String表示返回类型是String，“*”表示所有的返回类型；（方法返回值类型，必写） declaring-type-pattern表示方法的声明类，如“com.elim..*”表示com.elim包及其子包下面的所有类型；（方法声明类型，可以不写） name-pattern表示方法的名称，如“add*”表示所有以add开头的方法名；（要匹配的名称，括号里是方法的参数） param-pattern表示方法参数的类型，name-pattern(param-pattern)其实是一起的表示的方法集对应的参数类型，如“add()”表示不带参数的add方法，“add()”表示带一个任意类型的参数的add方法，“add(,String)”则表示带两个参数，且第二个参数是String类型的add方法； throws-pattern表示异常类型；其中以问号结束的部分都是可以省略的。（方法抛出的异常类型，可以不写） “execution(* add())”匹配所有的不带参数的add()方法。 “execution(public com.elim...add*(..))”匹配所有com.elim包及其子包下所有类的以add开头的所有public方法。 “execution( (..) throws Exception)”匹配所有抛出Exception的方法。 AOP XML文件使用 aop:config 大多数 aop:* 元素都需要在aop:config元素内 aop:before 前置通知 aop:after 后置通知（不论被通知方法是否执行） aop:aspect 定义一个切面 aop:pointcut 定义一个切点 aop:after-returning 返回通知 aop:after-throwing 异常通知 aop:around 环绕通知 aop:declare-parents 以透明方式为被通知的对象引入额外的接口 aop:advisor 定义通知器 aop:aspectj-autoproxy 启用@AspectJ注解驱动的切面 以上我们对于 AOP 的使用有一个初步的认识，接下来通过一个实例，实践 AOP 的功能应用。分别使用注解方式与 XML 文件配置方式实现 AOP 使用实例创建实例接口package com.spring; public interface ISomeService { void doFirst(); String doSecond(); void doThird(); } 使用 XML 文件实现 AOPpackage com.spring; public class SomeServiceImpl implements ISomeService { @Override public void doFirst() { // 执行 doFIrst() 方法 System.out.println(&quot;SomeService first&quot;); } @Override public String doSecond() { // 执行 doSecond() 方法 System.out.println(&quot;SomeService second&quot;); return &quot;Second&quot;; } @Override public void doThird() { // 执行 doThird() 方法 System.out.println(&quot;SomeService third&quot;); } } 编写目标类package com.spring; import org.aspectj.lang.ProceedingJoinPoint; public class MyAspect { // 执行前调用 public void before(){ System.out.println(&quot;before&quot;); } // 执行后调用 public void after(){ System.out.println(&quot;after&quot;); } public void around(ProceedingJoinPoint pj) throws Throwable{ System.out.println(&quot;around before&quot;); pj.proceed(); System.out.println(&quot;around after&quot;); } } 注意：使用环绕通知必须要使用 ProceedingJoinPoint 。使用它来调用被通知的方法，需要调用 proceed() 方法来实现功能。如果忘记调用此方法，会阻塞对被通知的方法的调用。 创建 XML 文件 ApplicationContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.spring.SomeServiceImpl&quot; /&gt; &lt;!-- 注册切面 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.MyAspect&quot;/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 定义切点 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doFirst(..))&quot; id=&quot;first&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doSecond(..))&quot; id=&quot;second&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doThird(..))&quot; id=&quot;third&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;first&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;second&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;third&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 使用注解方法完成 AOP&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt; &lt;!-- 注册切面 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.MyAspect&quot;&gt;&lt;/bean&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.spring.SomeServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 注册Aspect --&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 使用注解方式，必须在 ApplicationContext.xml 文件中添加 &lt;aop:aspectj-autoproxy/&gt; 用于启用 AspectJ 自动代理 编写目标类@Aspect // 表示该类为切面 public class MyAspect { // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doFirst(..))&quot;) public void first(){} // 通知前 @Before(&quot;first()&quot;) private void before(){ System.out.println(&quot;before&quot;); } // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doSecond(..))&quot;) public void second(){} // 通知后 @After(&quot;second()&quot;) public void after(){ System.out.println(&quot;执行 doSecond() after&quot;); } // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doThird(..))&quot;) public void third(){} // 环绕通知 @Around(&quot;third()&quot;) public void around(ProceedingJoinPoint pj) throws Throwable{ System.out.println(&quot;third 执行之前&quot;); pj.proceed(); System.out.println(&quot;third 执行之后&quot;); } } 编写测试类public class MyTest { // 使用注解 调用 Test 测试方法 @Test public void test1(){ String s = &quot;com/spring/ApplicationContext.xml&quot;; ApplicationContext ac = new ClassPathXmlApplicationContext(s); ISomeService service = (ISomeService) ac.getBean(&quot;someService&quot;); service.doFirst(); System.out.println(&quot;=============&quot;); service.doSecond(); System.out.println(&quot;==============&quot;); service.doThird(); } } 以上内容通过一个小实例完成对 AOP 的应用实现，简单的做一个认识了解。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 初相识]]></title>
    <url>%2F2018%2F06%2F20%2FSpring%20%E5%88%9D%E7%9B%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spring 介绍Spring是一个轻量级框架。不依赖于容器就可以运行。Struts，Hibernate 同属于轻量级。Spring以IOC，AOP为主要思想 IOC：Inversion of Control， 控制反转。 AOP：Aspect Oriented Programming， 面向切面编程。通俗意思就是在执行某些代码前执行另一些代码，可以做出添加，删除某些功能。类似于Servlet中的Filter，思想相同。 Spring 属于非侵入式 侵入式：通常需要通过实现特定的接口，继承特定的类才能增强功能 非侵入式：对现有类的结构没有影响，就可以增强 JavaBean 的功能 Spring 三层构架 表现层(Web): Spring MVC 业务逻辑层（Service）：Spring的IOC 数据访问层（DAO）：Spring的jdbc 使用Spring重要的jar包四个必须包 spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-expression：spring表达式语言 aop部分包含4个模块 spring-aop：面向切面编程 spring-aspects：集成AspectJ spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 test部分只有一个模块，我将spring-context-support也放在这吧 spring-test：spring测试，提供junit与mock测试功能 spring-context-support：spring额外支持包，比如邮件服务、视图解析等 commons-logging: 日志（必须包） Spring Bean 三种不同配置方式基于 XML 配置方式导入 jar 包 commons-logging spring-aop spring-beans spring-context spring-core spring-expression spring-test 创建 Bean package com.carlos.spring; public class helloword { private String title; private String name; public helloword(String title, String name){ this.title = title; this.name = name; } public void show(){ System.out.print(title + &quot;:&quot; + name); } } 创建测试类package com.carlos.spring; public class test { public static void main(String[] args) { ApplicationContext hw = new ClassPathXmlApplicationCont(&quot;ApplicationContext.xml&quot;); helloword h = (helloword) hw.getBean(&quot;hello&quot;); h.show(); } } 创建 XML 文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.carlos.spring.helloword&quot;&gt; &lt;constructor-arg name=&quot;title&quot; value=&quot;hello word&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;carlos&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 使用构造器注入 添加xmlns:c=&quot;http://www.springframework.org/schema/c&quot; &lt;constructor-arg name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt; Spring c- 命名空间`&lt;bean id=”hello” class=”com.carlos.spring.helloword”c:name=&quot;carlos&quot; c:title=&quot;hello word!&quot;&gt; ` XML 不容许数字作为属性的第一个字符，想要使用需要加一个 _ 前缀 使用 Set 方法注入 添加xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;property name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt; Spring p- 命名空间`&lt;bean id=”hello” class=”com.carlos.spring.helloword”p:name=&quot;carlos&quot; p:title=&quot;hello word!&quot;&gt; ` 装配集合使用 List 元素申明一个列表 &lt;property name=&quot;num&quot;&gt; &lt;list&gt; &lt;value&gt;第一&lt;/value&gt; &lt;value&gt;第二&lt;/value&gt; &lt;value&gt;第三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 与 性质相同，都可使用。不同的是，set 不可存放重复数据，存放顺序同样不可保证。推荐使用 。不论在哪种情况下俩种集合都可使用。 基于注解的配置方式注解 @Component : 表明该类会作为组件类。 @ComponentScan : 能够在Spring中启用组件扫描。如果没有其他的配置，默认会扫描与配置类相同的包。 @Controller : 用于对 Controller 实现类进行标注，功能与 Component 相同。 @Repository : 用于对 DAO 实现类进行标注。 @Service : 用于对 Service 实现类进行标注，功能与 Component 相同。 创建 BeanDAO 层使用注解 @Repository @Repository public class UserDao { public void save(){ System.out.println(&quot;数据库&quot;); } } 等效于 XML 中 &lt;bean id=&quot;userDao&quot; class=&quot; ... &quot;/&gt; ID 为 userDao 而不是 UserDao,将类名第一个字母变为小写。 Service 层使用注解 @Service @Service public class UserService { public void save(){ System.out.println(&quot;service&quot;); } } Servlet 层使用注解 @Controller @Controller public class UserServlet { public void save(){ System.out.println(&quot;servlet&quot;); } } 创建 XML 启动组件扫描&lt;beans ...&gt; &lt;context:component-scan base-package=&quot; 包名 &quot;&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 创建测试类public class Test { public static void main(String[] args) { ApplicationContext act = new ClassPathXmlApplicationContext (&quot;ApplicationContext.xml&quot;); UserDao ud = (UserDao) act.getBean(&quot;userDao&quot;); ud.save(); UserService user = (UserService) act.getBean(&quot;userService&quot;); user.save(); UserServlet us = (UserServlet) act.getBean(&quot;userServlet&quot;); us.save(); } } 基于 Java 类的配置方式 Bean ： 声明 Bean创建配置类 @Configuration public class User { @Bean public String show(){ return &quot;hello word!&quot;; } } @Configuration public class Student { @Bean public String show1(){ return &quot;student&quot;; } } 创建测试类public class Test { public static void main(String[] args) { AnnotationConfigApplicationContext at = new AnnotationConfigApplicationContext(User.class); System.out.println(at.getBean(&quot;show&quot;)); AnnotationConfigApplicationContext stu = new AnnotationConfigApplicationContext(Student.class); System.out.println(stu.getBean(&quot;show1&quot;)); } }]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web 过滤器]]></title>
    <url>%2F2018%2F06%2F06%2FJava-Web-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器 Filter过滤器是 Java Web 三大组件之一。它的作用是，当客户端向服务器发出请求，经过过滤器。过滤器进行拦截，也可以拦截响应。可以对拦截的内容进行添加修改。在对访问者权限判断时可以使用到过滤器。 注册 Filter需要在 web.xml 下进行 Filter 的注册，添加以下代码 &lt;filter-mapping&gt; &lt;filter-name&gt;&lt;filter-name&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 生命周期四个阶段实例化初始化执行 init() 方法。与 Servlet 相同，web 启动时进行实例化。创建 Filter 实例对象，调用 init() 方法进行初始化。Filter 只会创建一次，init() 方法也只会执行一次。 doFilter在每一次的拦截都会执行。需要在这里填写 chain.doFilter(request, response) 将请求放到下一个资源 FilterCofing getFilterName() 获取配置名称 getINitParameter() 获取初始化参数 getInitParameterNames() 获取所有初始化参数 getServletContext() 获取全局域销毁destory() 。 只有应用停止才会执行 destory() 方法进行销毁 四种拦截方式在注册 Filter 时添加 &lt;dipatcher&gt;&lt;/dipatcher&gt; 可以添加拦截方式，只会拦截指定类型。 FORWARD如果请求通过 RequestDispatcher 的 forward() 方法转发。将会被 Filter 拦截。即只会拦截由 RequestDispatcher 的 forward() 方法转发的请求，其他的不会被拦截 INCLUDE通过 RequestDispatcher 的 include() 方法，将会被拦截，其他的不会被拦截 REQUEST不写 dispatcher 默认是REQUEST 拦截普通请求，但对于 forward() 和 include() 跳转不进行拦截 ERRORERROR 只有跳转错误页面处理时 会进行拦截 多个 Filter 执行顺序根据在 web.xml 中的注册顺序进行执行。 中文乱码解决方案POST 中文乱码解决方案 请求 request.getCharacterEncoding(“UTF-8”);放入到 Filter 中 只要做拦截就修改编码但是这个方法对于 GET 提交不适用（无效） 响应 response.setContentType(“text/html;charset=UTF-8”); 都写在chain.doFilter(request,response); 之前 GET 中文乱码解决方案使用装饰者设计模式解决这个问题。定义一个类继承 HttpServletResponseWrapper 。子类必须要有带参构造器 需要重写四个方法getParmameterMap()getParameterNames()getParameterValues(String name)getParameter(String name) 自定义一个 Map ,原始 Map 中数据是乱码，自定义 Map 中数据来自于原始 Map public Maop&lt;String, String[]&gt; getParameterMap(){ Map&lt;String, String[]&gt; newMap = new HashMap&lt;&gt;(); Map&lt;String, String[]&gt; originalMap = super.getParameterMap(); //获取原始 Map //遍历原始 Map for(String key : originalMap.keySet()){ String[] values = originalMap.get(key); //获取当前遍历 key 所有值 for(int i=0; i&lt;values.length; i++){ byte[] bytes = values[i].getByte(“ISO8859-1”); //打散 values[i] = new String(bytes,”UTF-8”); //组装 } //将解决乱码问题数据放入新 Map newMap.put(key, values); } return newMap; } public Enumweationg getParameterNames(){ Map&lt;String, String[]&gt; map = this.getParameterMap(); //将 Set 装换为 Vector Set&lt;String&gt; keySet = map.keySet(); Vector keVector = (Vector) keySet; return keyVector.elements(); } public String[] getparmeterValues(String name){ Map&lt;String, String[]&gt; map = this.getParameterMap(); return map.get(name); } public String getParameter(String name){ return this.getParameterValues(name)[0]; } 创建一个自定义请求对象 request = new 自定义解决乱码名称的类((HttpServletRequest)request);]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Java Web 过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F05%2Ffrist-blog%2F</url>
    <content type="text"><![CDATA[Hello World学习遇到不解问题，在网上查找答案的过程中，偶然间点到一个链接，点进去是个人博客，去寻找答案。解决问题后，第一次接触个人博客，带着好奇心开始了解认识个人博客，浏览过一些后。发现博客内容参差不齐，学习，工作，生活。太多吸引到我的内容，这也算是开始个人博客的原因之一。浏览他人的博客后，着手准备做一个关于自己的，丰富它的内容。刚开始比较从基础知识开始学习，写的都是基础内容，菜鸟一个。随着时间的增加，知识的累积。会更多地分享自己的理解和总结，也供他人日后参考。记录这个成长路上的点点滴滴。 链接 Weibo: weibo@CarlosHaoxj Zhihu: Zhihu@CarlosHaoxj]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>CarlosHaoxj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web 监听器]]></title>
    <url>%2F2018%2F06%2F05%2FJava-Web-%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[监听器监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。监听器其实就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。 使用监听器需要在 web.xml 里配置监听器 全名 监听器分类在Servlet规范中定义了多种类型的监听器(一共8个监听器)，它们用于监听的事件源分别为ServletContext，HttpSession和ServletRequest这三个域对象。 事件源 三个域属性 中的 增 删 改 对事件对象 创建与销毁 域对象监生命周期ServletRequestListener 生命周期public class RequestListener implements ServletRequestListener { public void requestInitialized(ServletRequestEvent sre) { //创建 } public void requestDestroyed(ServletRequestEvent sre) { //销毁 } } HttpSessionListener 生命周期public class SessionListener implements HttpSessionListener { public void sessionCreated(HttpSessionEvent se) { //session 创建时触发 } public void sessionDestroyed(HttpSessionEvent se) { //session 销毁时触发 } } ServletContexListener 生命周期public class ContextListener implements ServletContextListener { public void contextInitialized(ServletContextEvent sce) { //ServletContext 初始化触发 } public void contextDestroyed(ServletContextEvent sce) { //ServletContext 销毁时触发 } } 域对象的属性监听ServletRequestListener 属性监听public class AttributeListener implements ServletRequestAttributeListener { public void attributeAdded(ServletRequestAttributeEvent srae) { //向request 添加属性触发 } public void attributeRemoved(ServletRequestAttributeEvent srae) { //从request 删除属性触发 } public void attributeReplaced(ServletRequestAttributeEvent srae) { //从request 重置属性触发 } } HttpSessionListener 属性监听public class SessionAttributeListener implements HttpSessionAttributeListener { public void attributeAdded(HttpSessionBindingEvent se) { //向 Session 添加属性触发 } public void attributeRemoved(HttpSessionBindingEvent se) { //从 Session 删除属性触发 } public void attributeReplaced(HttpSessionBindingEvent se) { //向从Session 重置属性触发 } } ServletContextListener 属性监听public class ContextAttributeListener implements ServletContextAttributeListener { public void attributeAdded(ServletContextAttributeEvent scae) { //向 ServletContext 添加属性触发 } public void attributeRemoved(ServletContextAttributeEvent scae) { //从 ServletContext 删除属性触发 } public void attributeReplaced(ServletContextAttributeEvent scae) { //从 ServletContext 重置属性触发 } } HttpSeesionBindingListener 作用： 实体类实现这个借口对象，从 Session 删除对象都会触发这个接口该监听器不需要注册 public void valueBound(HttpSessionBindingEvent event) { //当前类的对象放入到Session时 触发执行 } public void valueUnbound(HttpSessionBindingEvent event) { //当前类的对象从Session删除时 触发执行 } HttpSessionActivationListener该监听器在 Session 中存放的指定类型对象的钝化与活化 同时需要实现 Seralizable 接口 钝化： 将数据写入到硬盘 sessionWilPassivate(HttpSessionEvent se)活化： 将数据写入到内存 sessionDidActivate(HttpSessionEvent se)]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Java Web 监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 基础语法]]></title>
    <url>%2F2018%2F06%2F02%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQL 模式数据定义语言(Schema Data Definition Language)DDL 代表指令CREATE,DROP,ALTER 数据操纵语言(Data Manipulation Language)DML 代表指令INSERT,UPDATE,DELETE 数据查询语言(Data Query Language)DQL 代表指令SELECT 数据控制语言(Data Control Language)DCL 代表指令CRANT,REVOKE SQL 语法详解关键字大写,使用 ； 号表示结束。 DDL 数据定义语法对数据库和表的结构操作 对数据库操作 定义数据库：CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8] 显示数据库: SHOW DATABASES 使用数据库: USE 数据库名 修改数据库： ALTER DATABASE 数据库名 CHARACTER SET UTF-8 删除数据库: DROP DATABASE 数据库名 对表操作创建表 CREATE TABLE &lt;表名&gt;( &lt;列名&gt;&lt;数据类型&gt;[列级完整约束条件] &lt;列名&gt;&lt;数据类型&gt;[列级完整约束条件] [,&lt;表级完整约束条件&gt;] ); 删除表 DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; RESTRICT 删除表有限制 若存在约束条件 此表不可被删除 CASCADE 删除表没有限制 所有条件一并被删除 建立索引，索引为加快查询速度 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON&lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]); 次序: ASC(升序) DESC(降序) 默认是升序 修改索引 ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 删除索引 DROP INDEX&lt;索引名&gt;;DML 数据操作语法做更新数据，做增，删，改插入数据 INSERT INTO &lt;表名&gt;(属性列1，属性列2，…) VALUES(常量1，常量2，…)； 属性列可以省略，但是在表定义 NOT NULL 的属性列不可取空值。在写程序时不建议省略。字符串必须使用单引号括起来。 修改数据 UPDATE&lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; WHERE &lt;条件&gt;; 如果省略 WHERE 表示修改表中所有元祖 可以使用 IN(…); 嵌套子查询 删除数据 DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;; 如果省略 WHERE 表示删除表中全部元组，删除是表中的数据，而不是表的定义。使用 IN(…) 嵌套子查询删除数据 DQL 数据查询语法使用 SELECT 语句做查询。只做查询，不做修改。一般格式： SELECT [ALL | DISTINCT] &lt;目标列查询&gt; FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; GROUP BY &lt;列名&gt; HAVING &lt;条件表达式&gt; OPDER BY &lt;列名&gt; [ASC | DESC]; 查询所有列 SELECT * FROM &lt;表名&gt; 查询指定列 SELECT 列1，列2，... FROM &lt;表名&gt; 条件查询 SELECT * FROM &lt;表名&gt; WHERE 列名=指定值 模糊查询 SELECT * FROM 表名 WHERE 列名 LIKE ‘张_’;(_代表匹配任意一个字符，％代表匹配0～n个任意字符)。 ORDER BY: 根据某个字段进行升序或者降序排列 ASC 升序 DESC 降序 OPDER BY: 根据表中的某个字段进行分组，即将含有相同字段值的记录放在一组，不同的放在不同组。 WHERE 与 HAVING 区别：作用对象不同，WHERE作用于基本表或试图,不可使用聚集函数。HAVING作用于组。聚集函数 COUNT(*) 统计元祖个数 COUNT([DISTINCT | ALL] &lt;列名&gt;) 统计一列 值的个数 SUM([DISTINCT | ALL] &lt;列名&gt;) 总和 AVG([DISTINCT | ALL] &lt;列名&gt;) 平均值 MAX([DISTINCT | ALL] &lt;列名&gt;) 最大值 MIN([DISTINCT | ALL] &lt;列名&gt;) 最小值 DCL 数据控制语法该语言用来定义访问权限，理解即可，以后不会多用。需要记住的是，一个项目创建一个用户，一个项目对应的数据库只有一个。这个用户只能对这个数据库有权限，其它数据库该用户就操作不了。 创建用户 CREATE USER [WITH][DBA | RESOURCE | CONNECT]默认权限：CONNECT,该权限不能创建新用户，不能创建模式，不能创建表，只能登陆数据库RESOURCT: 可以创建基本表和视图DBA: 拥有对所有数据库对象的存取权限 给用户授权语法:GRANT 权限1，…，权限n ON 数据库.* TO 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。 撤销授权语法:REVOKE 权限1，…，权限n ON 数据库.* FROM 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1.* form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。 查看权限查看指定用户的权限:SHOW GRANTS FOR 用户名@ip地址； 删除用户DROP USER 用户名@ip地址；]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Web-JSP EL JSTL]]></title>
    <url>%2F2018%2F05%2F22%2FJava-Web-JSP%20EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JSPJSP,即 Java Server Pages。Java服务器页面，运行在服务端的页面。后缀名为 .jsp 。JSP文件本质是Servl，不同的是JSP用于进行数据展示的Servl。普通的Servlet是用于完成业务逻辑处理。结合html。 JSP中的Java代码块JSP中的Java代码块也称为JSP小脚本，用 &lt;% %&gt; 括起来的部分。 &lt;% %&gt; 不能加权限访问 private，不能定义方法，不能定义静态语句块 &lt;%! %&gt; 可以加权限访问，可以定义方法，可以定义静态语句块 &lt;%= %&gt; 表达式块，将数据显示到客户端浏览器 &lt;%@ page import=” “ %&gt; 导入包，多个包用 ， 隔开 JSP指令作用：为当前页面做一些基本的属性设置。 page: 页面指令 include: 包含指令 taglib: 标签库指令 格式： &lt;%@ 指令名称 属性名=属性值 ……%&gt; page指令一个JSP文件可包含多个page指令，设置当前页面的相关信息。 pageEncoding 用于设置当前页面的的字符编码格式 import 在JSP中导入指定的类，多个类用 ， 隔开 contentType 设置JSP页面呈现于用户流浪器中的内容类型 “text/html” errorPage 当运行发生异常时跳转的页面 “/error.jsp” isErrorPage 当一个页面的 page 指令中设置 isErrorPage 的值为 true 时，表明当前页面为一个“错误处理页面”。默认 isErrorPage 的值为 false session 判断是否可以直接使用内置对象session，默认是 trueinclude指令该指令只有一个属性 file ，指定要包含的文件。为了减少页面定义的重复性工作。 &lt;%@ include file=”/***.jsp” %&gt; JSP动作JSP动作： 使用系统定义好的标签来完成本应由Java代码来完成的功能。 &lt;jsp:动作名称 属性名=属性值 ……&gt;&lt;/jsp:动作名称&gt; &lt;jsp:动作名称 属性名=属性值 ……/&gt; forward动作从当前JSP转到另一个JSP，servlet或者Web应用中的任何其他资源， inlcude动作被包含的页面要出现在发送请求的页面。比如一个页面的页眉，它会出现在每一个页面，使用include动作可以实现。不同于include指令，include指令在运行时发生，jsp:include动作在运行时发生。include指令的属性是file，inlcude动作的属性是page. ELExpression Lang，表达式语言。在JSP页面任何静态部分可用 ${expression}获取指定表达式的值。只能从四大域中获取数据。 pageContext pageScope （从指定域中查找对象） request requestScope session sessionScope application applicationScope 如果访问对象为 null, EL不会抛出空指针异常，会显示为空。 内置对象 param 获取请求参数指定参数值 paramValues 获取请求参数的所有值 initParam 获取初始化参数 pageContext 获取路径访问路径 ${ pageContext.request.contextPath }/ 自定义函数因为EL不支持字符串的操作，使用自定义函数完成。 定义一个静态方法类package com; public class ELFuntions { public static String LowerToUpper(String s) { return s.toUpperCase(); } } 注册函数，配置 .tld注册函数，在 Web 项目的/WEB-INF 目录下，新建一个扩展名为.tld 的 XML 文件，例如 myfn.tld。tld，即 Tag Library Definition，标签库定义。将定义好的函数，在这个文件中进行注册。XML文件需要约束，需要配置文件头暗转Tomcat安装目录下：tomcat-9\webapps\examples\WEB-INF\jsp2 找到 jsp2-example-taglib.tld在 .tld 中添加 &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot; version=&quot;2.0&quot;&gt; //添加子标签 &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;test&lt;/short-name&gt; //最好与文件名相同,在JSP页面中要使用 &lt;uri&gt;http://www.carloshaoxj.cn/jsp/el/funtions&lt;/uri&gt;//指定该函数所对应的URI //注册函数 &lt;function&gt; &lt;name&gt;LowerToUpper&lt;/name&gt; //与指定函数的名称相同 &lt;function-class&gt;com.ELFuntions&lt;/function-class&gt; //类的名称 &lt;function-signature&gt;java.lang.String LowerToUpper( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt; 使用自定义函数&lt;%@ taglib uri=&quot;http://www.carloshaoxj.cn/jsp/el/funtions&quot; prefix=&quot;text&quot;%&gt; ... &lt;body&gt; &lt;% request.setAttribute(&quot;name&quot;,&quot;zhangsan&quot;); //必须存入四大域中 %&gt; ${text:LowerToUpper(name)} &lt;/body&gt; ... 定制标记使用EL和标准动作是有限制的，有些功能不可完成，比如数组处理功能。所以引入了定制标记来完成不可完成的功能。 安装 JSTL使用 JSTL 之前需要将 jstl.jar 和 stadard.jar 导入到 Web 应用的 WEB-INF/lib 目录下。 JSTL 标记语法在 jsp 头部加入 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 使用 JSTL 核心标记：out, set, remove, catch 条件标记：if, choose, when, otherwise 循环标记：forEach, URL标记：url 核心标记c:out用来输出表达结果，使用 &lt;c:out value=&quot;string&quot; default=&quot;string&quot; escapeXml=&quot;true | false&quot;/c:out&gt; value: 要输出的内容 default: 输出默认值 escapeXml: 是否忽略XML特殊字符 默认 true c:set 用来设置变量值和对象属性。假设存在一个集合 Map ，想在该集合创建新的内容使用 &lt;c:set&gt; 来完成。 &lt;c:set var=&quot;user&quot; scope=&quot;string&quot; value=&quot;string&quot;/&gt; &lt;c:set target=&quot;string&quot; propety=&quot;string&quot; value=&quot;string&quot;/&gt; var:如果有一个名为 user 的域属性，创建一个的属性，value 不能为空 value:要存储的值，如果为空，则会删除该变量 scope:var属性作用域 proprty:要修改的属性 target:要修改的属性所属的对象 不能同时拥有 var 和 targetc:remove用于移除一个变量 &lt;c:remove var=&quot;&quot; scope=&quot;&quot;/&gt; var:要移除的变量名称，必须是一个String直接量，不能是表达式 scope:变量所属作用域c:catch处理产生错误的异常状况，并且将错误信息储存起来 &lt;c:catch&gt; var=&quot;&quot;&gt; ... &lt;/c:catch&gt; var:储存错误信息的变量 条件标记c:if判断表达式值 &lt;c:if test=&quot;boolean&quot; var=&quot;string&quot; scope=&quot;&quot;&gt; ... &lt;/c:if&gt; test:条件 var:用来存储条件结果的变量 scope:var属性的作用域c:choose与 switch 功能一样。 &lt;c:choose&gt;&lt;c:when test=&quot;boolean&quot;&gt; ... &lt;/c:when&gt; &lt;c:otherwise&gt; ... &lt;/c:otherwise&gt; &lt;/c:choose&gt; test:条件判断c:whenc:choose 的子标签，判断是否成立c:otherwisec:choose 的子标签，接在 c:when 标签后。当 c:when 判断为 false 时执行 循环标记c:foreach迭代集合对象 &lt;c:foreach var=&quot;&quot; items=&quot;&quot;&gt; var:当前变量名称 items：要被循环的信息URL标记URL 格式化为一个字符串， &lt;c:url var=&quot;&quot; value=&quot;&quot;&gt; var:URL变量名 value:路径]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JSP EL JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web Cookie Session]]></title>
    <url>%2F2018%2F05%2F16%2FJava-Web-Cookie%20Session%2F</url>
    <content type="text"><![CDATA[Cookie简介是一种网络回话状态跟踪的技术。由服务器生成，保存在客户端的一种信息载体。存放着该用户访问该站点的回话状态信息。只要Cookie没有被清空，那么，保存在其中的会话状态就有效。用户第一次请求后，服务器生成Cookie，并将其封装到响应头中，以响应形式发送给客户端。Cookie由若干键值对构成，name,value。均为字符串。 作用 服务器使用Cookie来跟踪客户端状态显示上次登录用户名并记住密码保存购物车 JavaEE 中的Cookie在JavaEE中的javax.servlet.http包中在一个类Cookie。 Cookie cookie = new Cookie(“name”,”value”); //创建Cookie respone.addCookie(cookie); //将Cookie 添加到响应中 Cookie保存到硬盘Cookie的maxAge：指Cookie的最大生命 maxAge&gt;0:浏览器会把Cookie保存到客户端硬盘上，有效时长为maxAge的值决定，例如:cookie.setMaxAge(60)表示这个Cookie会被浏览器保存到硬盘上60秒。 maxAge&lt;0:Cookie只会在浏览器内存中存在，当用户关闭浏览器时浏览器进程结束，同时Cookie也就死亡了。 maxAge=0:浏览器会马上删除这个Cookie。 cookie.setMaxAge(60 * 60) //单位是秒 绑定Cookie路径 必须加上项目名称cookie.addPath(request.getContextPath()+”/ “); Session简介Session,即会话，是Web开发中的一种会话状态跟踪技术。与Cookie不同是Cookie是将会话状态保存在客户端，而Session是将会话保存到了服务器端。Session是以javax.servlet.http.HttpSeesion的接口对象的形式出现。 Session对象创建request.getSession()true 有旧的用旧的，没有就创建新的flase 没有旧的不创建 对Session域属性空间的操作 public void setAttribute(String name, Object value)该方法用于向 Session 的域属性空间中放入指定名称、指定值的域属性。 public Object getAttribute(String name)该方法用于从 Session 的域属性空间中读取指定名称为域属性值。 public void removeAttribute(String name)该方法用于从 Session 的域属性空间中删除指定名称的域属性 //获取Session HttpSession session = request.getSession(); //向Session的域属性空间中存放域属性username session.setAttribute(“username”,pname); //读取域属性 session.getAttribute(“username”); //将Session中的username属性删除 session.removeAttribute(“username”); Session 工作原理写入Session 列表服务器对当前应用中的 Session 是以 Map 的形式进行管理的，这个 Map 称为 Session 列表。该 Map 的 key 为一个 32 位长度的随机串，这个随机串称为 JSESSIONID，value 则为 Session对象的引用。当用户第一次提交请求时，服务端 Servlet 中执行到 request.getSession()方法后，会自动生成一个 Map.Entry 对象，key 为一个根据某种算法新生成的 JSESSIONID，value 则为新创建的 HttpSession 对象。 在将 Session 信息写入 Session 列表后，系统还会自动将“JSESSIONID”作为 name，这个 32 位长度的随机串作为 value，以 Cookie 的形式存放到响应报头中，并随着响应，将该Cookie 发送到客户端。 客户端接收到这个 Cookie 后会将其存放到浏览器的缓存中。即，只要客户端浏览器不关闭，浏览器缓存中的 Cookie 就不会消失。当用户提交第二次请求时，会将缓存中的这个 Cookie，伴随着请求的头部信息，一块发送到服务端。 服务端从请求中读取到客户端发送来的 Cookie，并根据 Cookie 的 JSSESSIONID 的值，从Map 中查找相应 key 所对应的 value，即 Session 对象。然后，对该 Session 对象的域属性进行读写操作。 Session失效Session 在指定时间范围内没有被访问将超时，即将失效。在web.xml 中可以通过设置 &lt;session-timeout&gt;120&lt;/session-timeout&gt; 单位是分钟，默认30分钟。这个时间属于最后一次访问开始计时，长时间之内未被访问。并不是第一次访问开始计时。可以使用HttpSession中的方法invalidate(),使Session 提前失效。 HttpSession session = request.getSession(false); if(session != null) { session.invalidate } 浏览器禁掉Cookie后对Session处理浏览器禁掉 Cookie 后，用户每一次刷新页面发送提交时，都会生成一个新的 Session，服务器接收到客户端发送来的请求后，会从请求中读取 Cookie。如果没有找到 JSESSIONID 的Cookie，服务器就会成生成一个新的Session，将新的 JSESSIONID 保存到 Cookie 发送到客户端。 解决方案：url重写。 response.encodeRedirectURL(java.lang.String url); //用于对sendRedirect方法后的url地址进行重写。 response.encodeURL(java.lang.String url); //用于对表单action和超链接的url地址进行重写。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Cookie Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet 初相识]]></title>
    <url>%2F2018%2F04%2F30%2FServlet%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[域名解析域名解析服务DNS，将IP与域名进行映射服务，提供服务的服务器，称DNS服务器。 HTTP协议 超文本传输协议，请求与响应模式，无状态的网络协议。 浏览器 → 服务器 请求：Request服务器 → 浏览器 响应：Response 版本 HTTP 1.0 只能连接一次 HTTP 1.1 持久连接请求协议 URL 统一资源定位符，唯一确定一个资源。Web上每一个资源都有唯一的地址，就采用URL格式。 URI 统一资源标志符常用方法 GET：携带量小，只能字符串，安全系数低。但是它能够使用浏览器缓存，减轻服务器压力。 构成：请求行 请求头部信息 请求正文 GET请求会把表单信息追加到URL的最后。 POST：数据类型为任意类型，携带大量数据，安全性高，不会使用浏览器缓存。 构成：响应行 响应头部信息 响应正文 其他方法：HEAD，TRACE，PUT，DELETE，OPTIONS，CONNECT。这些方法不常用。 Servlet简介Servlet 是连接Web服务器服务端JAVA程序的协议，接口形式体现。三大组件之一。Servlets 属于单例，多线程。 注册 &lt;servlet-name&gt;someServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.renai.SomeServlet&lt;/servlet-class&gt; &lt;servlet-name&gt;someServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/some&lt;/url-pattern&gt; 一个Servlet可以有多个与之对应。 路径 精确路径： /abc/a 通配符路径： /abc/* 拦截： /和/ 拦截所有请求 区别：/ 拦截所有请求，无论是静态还是动态。/ 只会拦截静态资源请求。 后缀名模式：.后缀，只拦截后缀名。一般是(.do *.action) 限制：不能与通配符模式一起用 匹配原则路径优先后缀精确路径优先最长路径优先 生命周期 Servlet类加载 Servlet实例化 调用init()方法 调用service()方法 调用destroy()方法 只会执行一次无参构造器和init()，第一次访问执行。提交一次Servlet请求，执行一次service().只会执行一次destroy().服务器停用时执行因为是多线程，不添加可修改变量，存在线程安全默认情况下，Servlet在Web容器启动时不会被实例化 域属性存放请求属性的区域，域属性是全局性的。存放数据方式是Map. 设置域属性： setAttribute(); 获取域属性： getAttribute(); 删除域属性： removeAttribute(); 定义域属性 &lt;param&gt;&lt;/param&gt; &lt;param-value&gt;&lt;/param-value&gt; 实现Servlet方法 实现javax.servlet.Servlet接口。 继承javax.servlet.GenericServlet类。 继承javax.servlet.http.HttpServlet类。接口Servlet 方法 service(ServletRequest,ServletResonse) init(ServletConfig) destroy() getServletConfig(); getServletInfo(); 只会执行一次无参构造器和init(),第一次访问执行。提交一次Servlet请求，执行一次service()。只会执行一次destory()，服务器停用时执行。因为是线程，不添加可修改变量，存在线程安全问题。默认情况下，Servlet在Web容器启动时不会被实例化。 类GenericServlet一个抽象类，Servlet里有五个方法，常用只有一个，简化方法，只实现service。重写init，必须留super.init(config);否则空指针异常。 类HttpServlet重写doGet(); doPost(); 必须覆盖其一。HttpServletRequest是一个接口，将HTTP请求协议完整发送到request，收到响应，请求立马终止。一次请求对应一个对象。两次请求相互独立、HttpServletRequest中携带的参数以Map的形式接收，并且该Map的key为String value 为String数组。 获取请求参数： getParmater(); 获取全部请求参数名称： getParamterNames(); 获取全部请求参数值： getParamterValue(); 请求中获取服务端相关信息 获取请求的URL： getRequestURL(); URL去掉请求协议及主机: getRequestURL(); 项目根路径： getContextPath(); 获取客户端IP： getRemoteAddr(); 精确路径： getSrtvletPath(); 通配路径： getPathInfo(); 解决中文乱码问题GET Tomcat-9解决了GET的中文乱码问题。POST：添加getCharaterEncding(“UTF-8”);该方法设置解决了请求正文中字符编码，只适用于POST。GET： byte[] bytes = name.getByte(“ISO8859-1”);name = new String(bytes,”UTF-8”);这个方法对于GET POST 都适用，不建议POST。 response解决中文乱码 setContentType(String type) 设置内容类型 text/html;charset=UTF-8 setCharacterEncoding(“UTF-8”) 使用前提，之前必须使用setContentType() 用于修改setContentType(“text/html;charset=UTF-8”) 请求转发与重定向 请求转发，称为服务器内跳转重定向，称为服务器外跳转 请求转发: request.getRequestDispatcher(“/“).forward(request,response); 重定向： resonse.sendRedirect(“”) 重定向传递数据： response.sendRedirect(“other?pname=zs&amp;page=23”) 使用问好连接。 解决中文乱码，只适用重定向中文乱码 编码:打散 URLEcoder.encode(name,”UTF-8”) 解码：组装 URLDecoder.decode(name,”UTF-8”) new String(name.getBytes(“ISO8859-1”),”UTF-8”) 路径 绝对路径 = 参照路径 + 相对路径 以斜杠开头 前台路径：前台路径的参照路径是web服务器的根路径 http://127.0.0.1:8080 后台路径：后台路径是web应用的根路径 http://127.0.0.0:8080/primary 以路径名开头 以路径名称开头的相对路径，无论是出现在前台页面，还是出现在后台 Java 代码或配置文件中，其参照路径都是当前访问路径的资源路径。即使是 response 的 sendRedirect()方法的参数路径，若不以斜杠开头，其也属于“以路径名称开头的相对路径”类，参照路径为当前访问路径的资源路径]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F04%2F29%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程(Thread) 独立的线程，独立的执行空间，在JAVA中属于类。操作系统中每一个进程至少存在一个进程，当JAVA程序启动时，就会产生一个进程，该进程默认建立一个线程。线程就是进程中的一个单一的顺序控制流， Runnable接口 Runnable是一个接口，只有一个方法 public void run()。 代码实现public class MyRunnable implements Runnable { public void run() { System.out.println(&quot;MyThread!&quot;); } } class Threadstart { public static void main(String[] args) { MyRunnable thread = new MyRunnable(); Thread myThread = new Thread(thread); myThread.start(); System.out.println(&quot;Back!&quot;); } } 一旦线程进入可执行状态，它会在可执行与执行中两种状态中来来去去，也有另一种状态：暂时不可执行（堵塞状态）。 线程启动 要实现Runnable 接口，把Runnable传给Thread的构造函数才能启动新线程，线程初始化后没有调用start()之前一直处于建立状态，有时候线程会因为某些原因被堵塞。 线程调度器 会决定哪个线程从等待状态挑选出来,何时把某个线程送回等待执行状态.它会决定某个线程运行多久。无法去控制调度，它是不确定，不同的JAVA虚拟机上面做法不同。调度不能保证任何执行时间和顺序，不能期待它完全平均分配执行，可以用sleep()来保证时间。 sleep() 确保线程能够有机会执行的最好方式让它周期性去睡一下，调用sleep()这个方法，传入时间单位是毫秒 Thread.sleep(2000);休息两秒醒来进入可执行状态。这个方法可能抛出异常InterruptedException异常，所有对它的调用必须在try/catch块中。 代码实现try { Thread.sleep(2000); }catch(InterruptedException e) { e.printStackTrace(); } 但是线程也不一定在醒来后马上变成执行状态，只能确定它会回到执行状态，何时执行取决于调用器。 线程名字Thread th1 = new Thread(); Thread th2 = new Thread(); th1.setName(&quot;thread1&quot;); th2.setName(&quot;thread2&quot;); Thread.currentThread().getName() //读当前线程名字 线程缺点线程会产生并发性，并发性问题会引发竞争状态，竞争状态会引发数据的损毁。来自可能发生的一种状况：两个或者两个以上线程存取一个对象的数据。两个或者两个以上不同执行空间上的方法对同一个对象进行存取。解决此问题方法是需要给线程上锁。synchronized关键字代表线程需要一个钥匙来存取被同步化的线程。锁的不是数据，是存取数据的方法。一个锁只有一把钥匙，没有完成同步化方法不会释放钥匙，其他线程也进不去。但是在上锁的状态下也会引发其他问题，比如死锁。 死锁 同步化的方法会让你的程序因为要同步并行的问题而慢下来,导致死锁状态。死锁： 线程 A 进入 one 对象同步化方法，线程 A 睡， B 进入 two 对象同步化方法，线程 B 要进入 one 对象，此时正在执行 A ,拿不到钥匙，线程 B 等待，线程 A 醒来要进入 tow 对象，线程 B 正在执行，拿不到钥匙，线程 A 等待。线程 A 等待线程 B 的钥匙，线程 B 等待线程 A 的钥匙，拿着对方的钥匙，死锁。 死锁原因 互斥条件：资源不能被共享，只有一个线程执行。 请求与保持：一个线程持有一个资源并且正在等待获取一个当前正在执行的线程持有的资源。 资源任务不能被抢占：一个线程获取到一个资源，系统不强行收回，只能等线程自己释放。 循环等待：线程形成一个环链，每个都想先得到上一个的任务资源。 四个原因同时存在就会产生死锁，只要破坏其一就会避免死锁。死锁产生前三个是必要条件，解决死锁问题最容易的方法是破坏第四个条件。添加判断条件。 如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程。 如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类]]></title>
    <url>%2F2018%2F04%2F24%2F%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[泛型 jdk1.5出现的安全机制，避免强制转换。&lt;&gt;当操作应用类型不确定时应用，确定应用类型传入即可。确保类型安全（它的出现不单单确保类型安全）。运行时会将泛型去掉生成class文件不带泛型，为兼容运行类的加载器。 集合概述 集合按照其存储方式可分为两大类，单集合Collection，双集合Map. Cokkection: 单列集合用于存储一系列符合某种规则的元素，两个重要子接口，List 和 Set。List特点是元素有序，元素可重复。Set特点是元素无序且不可重复。List 实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet 和 TreeSet。Map： 双列集合用于存储具有键（Key）和值（Value）映射关系元素，每个元素都包含一对键值对。使用时可用一个Key找出其对应的Value。Map主要实现类有HashMap 和 TreeMap。 List 接口 List 接口继承自Collection接口，是单列集合重要分支。容许存储元素重复，通过索引访问集合中指定元素。存储元素有序，元素存入顺序和取出顺序一致。常用方法 void add（int index，Object element） 将元素element插入在集合的index处 boolean addAll（int index，Collection c) 将集合c所包含的元素插入到List集合的index处 Object get(int index) 返回集合索引index处的元素 Object remove(int index) 删除index索引处元素 Object set(int index,Object element) 将索引indext处元素换成element对象，并将替换后的元素返回 int indexOf(Object o) 返回对象o在List集合中出现的位置索引 int lastIndexO(Object o) 返回对象o在List集合中最后一次出现的位置索引 List subList(int fromIndex,int toIndex) 返回从索引fromINdex(包括)到toIndex(不包括)处所有元素集合组成的子集合asList() List asList(数组) 将数组转到集合，可以使用集合方法操作数组，数组长度时固定的，集合的增删方法不可用。ArrayList ArrayList是List接口实现类，内部封装了一个长度可变的数组对象，存入元素超出数组长度时，会在内存中分配一个更大的数组存储这些元素。ArrayList可看做一个长度可变的数组对象。底层是使用数组来保存元素，在进行增加删除时，会导致创建新数组，效率比较低，不适合做大量的增删操作。但是索引做查找元素很便捷。存取操作 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); System.out.println(&quot;长度&quot;+it.size()); System.out.println(&quot;第2个元素&quot;+it.get(1)); it.remove(1); it.set(0,&quot;e&quot;); System.out.println(it.subList(0,2)); }LinkedList 为了解决ArrayList增删的效率低问题，提供了LinkedList实现类，该集合内部维护了一个双向循环链表。可以实现栈的所有功能和方法，可以把LinkedList作为栈使用。常用方法 void add(int index,E element) 在指定位置加入指定元素 void addFirst（Object o) 将指定元素插入到开头 void addLast(Object o) 将指定元素插入到结尾 Object getFirst() 返回此列表的第一个元素 Object getLast() 返回此列表的最后一个元素 Object removeFrist() 移除并返回此列表第一个元素 Object removeLast() 移除并返回此列表最后一个元素方法使用 public static void main(String[] args) {LinkedList it = new LinkedList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); it.add(1,&quot;dd&quot;); it.addFirst(&quot;ee&quot;); it.removeFirst(); }迭代器 接口Iterator与Collection，Map不同，Collection与Map用于存储元素，Iterator主要用于迭代访问（遍历）Collection中元素，迭代器。Iterator代码实现 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); Iterator i = it.Iterator(); //获取Iterator对象 while(i.hasNext) //判断ArrayList是否存在下一个元苏 { Object obj = it.next(); //取ArrayList集合中元素 System.out.println(obj); } } 迭代器获取ArrayList集合中元素，都会将这些元素当做Object类型来看待，如果想得到特定类型，需要进行强制类型转换。使用迭代器进行迭代时， 如果用集合对象调用remove()方法去删除元素，会出现异常。 集合对象remove()解决方法 第一种：添加break,找到删除，跳出循环停止迭代。 if(“aa”.equals(obj)) { it.remove(); break; } 第二种：用迭代器remove()方法，对于迭代器本身是可预知的。 if(&quot;aa&quot;.equals(obj)) { i.remove(); } 调用remove()必须先调用next()。ListIterator 继承于Iterator类，在父类基础上添加逆向迭代，ListIterator迭代器只能用于List集合中。常用方法 void add(Object o) 将元素插入列表 booleadn hasPrevious() 逆向遍历列表，列表有多个元素，返回true Object previous() 返回列表前一个元素 void remove() 从列表中移除由next或previous返回的最后一个元素逆向迭代代码实现 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); ListIterator i = it.listIterator(it.size());//获取Iterator对象 while(i.hasPrevious) //判断ArrayList是否存在下一个元苏 { Object obj = it.previous(); //取ArrayList集合中元素 System.out.println(obj); } }foreach循环代码实现 foreach(容器中元素类型 临时变量 : 容器容量) {...... } jdk5.0新特性，主要应用于数组。相比Iterator遍历，它的写法简单。foreach循环的次数由容器中个数决定。局限是进行foreach循环只能访问元素，不可以对元素进行修改。 Enumeration接口 在JDK1.2以前还没有Iterator接口时候，遍历集合需要使用Enumeration接口，于Iterator方法类似。集合Vector是List接口的一个实现类，用法与ArrayList完全相同。Vector集合是线程安全的，ArrayList是线程不安全的。在Vector提供一个elements()方法用于返回Enumeration对象，通过Enumeration对象来遍历集合中的元素。代码实现 public static void main(String[] args) {Vertor v = new Vector(); v.add(&quot;aa&quot;); v.add(&quot;bb&quot;); Enumeration en = v.elements(); whoile(en.hasMoreElements) { Object obj - en.nextElement(); System.out.println(obj); } }Set 接口 继承于Collection。Set接口存入元素是无序，不可存入重复元素。主要有俩个实现类HashSet和TreeSet。HashSet是根据哈希值确定元素在集合中的存储位置，具有良好的存取和查找功能。TreeSet是根据二叉树的方式来存储元素，可以对元素集合进行排序。HashSet集合 存储元素无序并且不可重复。存元素是先调用hashCode()确定元素位置，再调用equals()来完成对象的唯一性。如果hashCode()值不同，不用判断，直接存到哈希表。如果hashCode()值相同，判断equals(),true视为相同元素，不存。false视为不同元素，存。必须覆盖hashCode()和equals()HashSet代码实现 public static void main(String[] args) {HashSet h = new HashSet(); h.add(&quot;aa&quot;); h.add(&quot;bb&quot;); Iterator it = h.iterator; while(it.hasNext()) { Object obj = it.next(); System.out.println(obj); } }重写覆盖hashCode()和equals() public int hashCode() //重写hashCode {return x.hasCode(); } public boolean equals(Object obj) //重写equals {if(this == obj) //判断是否为同一对象 { return true; } if(!(obj instanceof S)) //判断是否为S类型 { return false; } S s = (S)obj; //将对象强转S boolean b = this.x.equals(s.x); return b; } TreeSet 利用二叉树存储元素，可以排序，保证没有重复元素。TreeSet利用的是自平衡的排序二叉树。 集合中元素进行排序比较时，会调用compareTo()方法，该方法在Comparable接口中定义。要对集合元素排序就必须实现Comparable接口。Student(name,age)类型对象排序比较需要重写compareTo() public int compareTo(Object obj) //重写compareTo() {Student stu = (Student)obj; if(this.age-stu.age&gt;age) //判断年龄 { return 1; //1存 -1不存 } if(this.age-stu.age==0) { return this.name.compareTo(stu.name); //年龄相同再对名字比较 } return -1; }Map 接口 双列集合，存储每个对象都是一个键值对，一个键(key)和一个值(value),存在的关系是映射。访问时只要找到键(key),就可以找到对应的值(value)。必须保持键(key)的唯一性。常用方法 void put(Object key,Object value) 将值与映射关系中的指定键关联（存） Object get(Object key) 返回映射关系的值，如果不包含返回null（取） boolean containsKey(Object key) 判断指定键(key)关系的映射值（判断） boolean containsValue(Object value) 此映射将一个或多个键映射到指定值（判断） Set keySet() 返回此映射中包含键的Set视图 Collectionvalues 返回此映射中包含值得Collection视图 Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet 返回此映射中包含的映射关系的Set视图HashMap Map接口一个实现类，基于哈希表。如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，那么它必须在外部进行同步。如果存入相同的键(key),后存储的值将覆盖原有的值。键相同，值覆盖。最快的查找技术。常用方法TreeMap Map接口一个实现类，基于二叉树。TreeMap所有键是按照某种顺序排列。常用方法 int size() 返回集合中键(key)映射值的数量 void clear() 删除所有键的映射关系 void comparator() 比较器TreeSet迭代 public static void main(Stringp[] args) {TreeSet tm = new TreeSet(); tm.put(&quot;1&quot;,&quot;aa&quot;); tm.put(&quot;2&quot;,&quot;bb&quot;); Set keySet = tm.keySet(); Iterator it = it.iterator(); while(it.hasNext()) { Object key = it.next(); Object value = it.get(key); System.out.println(key+&quot;,&quot;+value); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
