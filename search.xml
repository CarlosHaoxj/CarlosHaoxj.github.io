<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java-基础-反射]]></title>
    <url>%2F2019%2F01%2F04%2FJava-%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射 定义：反射机制能够动态的操纵 Java 代码的程序，能够分析类能力的程序。 通过编译之后的字节码文件获取类中对象，可以得到类中的所有属性，方法，并且可以动态的操作该类。反射的关键源于 Class 类发挥的作用，该类在 java.lang.Class包下。 Class 类java.lang.Class 类的实例对象，任何一个类都是 Classs 实例对象，获取 Class 对象的三种方式 我们先定义一个 Student 类，在该类中定义变量和方法 class Student{ private String name; public void show(){ System.out.println(&quot;show&quot;); } } 然后编写一个测试类，分别测试三种获取 Class 对象的方式 第一种方式 Class c_0 = Student.class;，我们知道当运行一段代码第一步是进行编译，Java 程序文件后缀在编译之前 .java 文件，编译之后为 .class 文件，只要编译通过就会生成，第一种方式直接调用 Student 类的字节码文件，获取所需要的对象 第二种方式 Class c_1 = student.getClass();，当我已经实例化一个 Student 对象，学习 Object 类知道所有类默认继承 Object 类，在 Object 类下有一个方法可以获取类信息，直接调用即可。 第三种方式 Class c_2 = null; c_2 = Class.forName(&quot;这里写类的全称&quot;);// 比如 demo.Student 测试程序主要代码 public class test { public static void main(String[] args) throws ClassNotFoundException { Student student = new Student(); Class c_0 = Student.class; Class c_1 = student.getClass(); Class c_2 = null; c_2 = Class.forName(&quot;demo.Student&quot;); System.out.println(c_0); System.out.println(c_1); System.out.println(c_2); System.out.println(c_0 == c_1); System.out.println(c_0 == c_2); } } 打印结果为 class demo.Student class demo.Student class demo.Student true true 先查看 Class 类的三个对象，然后进行比较发现不论属于哪一种方式创建 Class 类创建的对象，他们都属于同一个对象，并没有重新编译生成。 获取程序在运行时刻的内部结构只是第一步，我们可以继续挖掘内部结构信息，比如声明定义的方法，变量等，常用的 Class 类下的方法主要有 getConstructor, getField 和 getMethod 分别获取构造方法，获取域还有方法，这里三个方法除了会获取 public 的函数对象，还会获取继承父类的所有元素。相比对应的 getDeclaredConstructor, getDeclaredField, getDeclareMethod这三个方法同样回去构造方法，域还有方法，但是这三个方法只会获取对象本身的方法，不问访问权限。每个方法都有自己的所属类。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式及案例]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[单例模式 单例模式：用来创建独一无二的，只能有一个实例对象，确保一个类只有一个实例，并提供一个全局访问点。 通俗说单例模式只将对象 new 一次，与工厂模式区别，工厂模式像是与单例模式相同，其实差距很大，工厂模式并不是实现将对象只 new 一次，它是主要避免对象的紧耦合，实现最终的解耦，或者是说单例模式是类的设计者要考虑的问题，工厂模式是类的使用者需要考虑的问题，不要混淆两个设计模式者 单例模式实现public class Singleton{ // 记录唯一实例对象 private static Singleton uniqueInstance; private Singleton(){} // 线程非安全 返回 uniqueInstance 对象 public static Singleton getInstance(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 编写测试类 class Test{ public static void main(String[] args){ Singleton singleton = new Singleton(); singleton.getInstance(); System.out.println(singleton.getInstance()); System.out.println(singleton.getInstance()); System.out.println(singleton.getInstance()); } } 显示打印结果 Thread.Singleton@610455d6 Thread.Singleton@610455d6 Thread.Singleton@610455d6 可以看出只创建一次对象每次调用返回同一个对象 此方法在单线程环境下可行，没有任何问题。但是如果两个线程，访问这段代码就会出现问题，当开启线程 A 和线程 B 。线程 A 第一次执行判断 uniqueInstace 为空，进入实例化一个对象，这时候线程 B 在判断 uniqueInstance 同样为空，同样实例化一个对象，这时候就不符合单例模式的定义，会出现两个或多个实例化对象，在 Java 中解决此类问题方式是添加关键字 synchroized 加锁 多线程单例模式我们先测试不加锁情况下会发生什么，单例模式类不改变，改动测试类的代码加入线程 class Test extends Thread{ public static void main(String[] args){ Thread thread_1 = new Test(); Thread thread_2 = new Test(); thread_1.start(); thread_2.start(); } @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;=&quot; + Singleton.getInstance()); } } 显示打印结果 Thread-1=Thread.Singleton@470bc213 Thread-0=Thread.Singleton@5eca2b42 明显发现，两个线程会去实例化俩个不同的对象（有时会返回相同对象，这是电脑本身计算问题，不妨多运行几次，会发现不同），如果这样的话我们的单例模式就没有存在的意义，不符合单例模式的定义：用来创建独一无二的，只能有一个实例对象，确保一个类只有一个实例，并提供一个全局访问点。需要做出更改，给 getInstance() 方法加锁看会不会有所改变，能否解决此类问题 更改单例模式类 public class Singleton { private static Singleton uniqueInstance; Singleton() { } // 加入关键字 synchronized 上锁 public synchronized static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 显示打印结果 Thread-0=Thread.Singleton@79d62897 Thread-1=Thread.Singleton@79d62897 经过多组测试，发现每次都只是返回同一个对象，感兴趣不妨可以自己测试，多添加几个线程。可以解决在多线程情况下的单例模式问题。 但是仔细想这样是会很好解决问题吗？其实并不是，学习线程我们知道，加锁代价高，如果是单纯的读操作是不需要加锁的，涉及写操作才需要加锁，使用 synchronized 需要仔细考虑，优化锁。仔细看一下代码，这段代码我们将 synchronized 关键字放在了方法上。这样的话不论哪个一个线程访问都会进行上锁解锁，其实这一步只有第一次访问时需要，其他时候访问已经有了实例化对象，就不需要再加锁，这时候的锁就造成浪费，优势变成了累赘。 更改多线程解决方式，为其添加双重锁 public class Singleton { private volatile static Singleton uniqueInstance; Singleton() { } public static Singleton getInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } 分析双重锁之前，会发现增加了新的关键字 volatile ，这方面知识需要我们恶补 JVM 的知识，我有关于该关键字介绍，附链接方式 更改 getInstance() 方法，判断 uniqueInstance 是否为空，改为锁前判断一次，锁后判断一次。不要以为锁前锁后都进行判断空是多余的操作，每一步都有存在的必要性。 首先锁前检查，如果需要的对象为空，进行加锁，去实例化一个对象，相反如果不为空，检查到已经存在一个需要的对象，就不要再进行加锁了，直接返回需要的对象。省掉了代价过高的加锁操作。锁前检查为了判断读写操作。 锁后检查，很多小伙伴会这想之前已经为空了，再加锁判断为空是否多余。并不是你们想的那样，这两次的判断存在的性质不同，第一次判断读写，第二次是检查线程问题。可以编写一个测试类查看运行结果是不是自己想要的。 不使用第二个判断的运行结果 Thread-1=Thread.Singleton@352ebfc0 Thread-2=Thread.Singleton@352ebfc0 Thread-0=Thread.Singleton@3c03e5f5 Thread-3=Thread.Singleton@352ebfc0 开启四个线程，发现其中一个线程实例化了一个新对象，这时不符合单例模式的定义。当我们调整代码，加上第二次判断执行多次后，每次执行结果，不论哪个线程都是使用的同一个对象，这时才是真正的实现多线程的单例模式 总结单例模式的实现相比之前学习的工厂模式较为简单，在学习之前我们先要对线程知识有一定了解，从而解决多线程中的单例问题。在单线程环境下我们不用考虑是否会创建多个对象，只有一个住线程，第一次执行方法为空，实例化一个对象，在整个代码运行期间，多次执行实例化方法时，第一次执行已经实例化一个对象，所以在之后调用该方法直接返回一个对象，不需要实例化一个新对象，从而实现单例模式。在多线程环境下，我们需要加锁来实现多线程环境下的单例模式，使用双重检查加锁来实现，避免直接在方法上加锁，造成资源浪费。第一次判断读写操作，第二次判断解决线程问题。 需要注意的是在 Java 语言中双重检查加锁不适用于 1.4 及更早版本，原因是关键字 volatile 发挥的作用，我有学习关键字 volatile 相关的记录，会附链接方式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一年，想法指向行动]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%BF%99%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%83%B3%E6%B3%95%E6%8C%87%E5%90%91%E8%A1%8C%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[16年，17年2018年12月31日，天津，一个人，心情很复杂，负能量爆棚。又是一年末尾，新的一年开始，这是在上大学过的第三个元旦，前俩年到元旦都会非常的兴奋，朋友相聚，新环境的感触。可是今年的我却怎样也开心不起来，变得焦虑，急躁。 16年上大学开始，每年这时候总会控制不住自己，总想出去看一看。当时自己还想着每年元旦假期换地过（天津，北京，上海…），16年，17年很顺利，没有任何阻碍，完成了计划，每个地方都有收获，同样也有好友相伴。 16年在天津，三个人的聚会（文盲，旺旺），话题总是离不开这半年换一个城市生活的感受，毕竟都是第一次长时间的在一个陌生的城市生活。17年北京，这次的北京之旅，由16年的三位，变成了两位（旺旺）。这次的相聚，了解到我的准备18年去当兵，去磨练自己。老实说我之前的我也有当兵的想法，但是没有去实现，比较佩服他，支持他。而当时的我对自己也有新的要求，经过一年的时间，所立要求完成了90%，带来更大困惑，未知。（18年9月份他正式参军入伍，知道消息后，准备去火车站送他上车（不容许），只能在入伍前几天见一次，期待两年后的再聚，有成长，有改变） 在成长的路上，每一年意义非凡。未来是未知的，任何事都是不确定的，也许现在做的事会对以后产生影响，也许不值一提。希望在若干年后回想现在每天完成的事，会是有意义的。 快乐，焦虑，丧气。这三个词可以概括我在敲这些字时候对这一年中经历的总结。有时候我也在问自己，这样的状态是怎样造成的，并没有好的答案，反而更加严重。或许转移这方面的注意力，能够使这些负能量减少。 18年元旦假期结束，与好友乘坐高铁回天津，等车过程中看着北京南站的人来来往往，下次来北京是否还会像当时一样有着轻松的状态。 这一年，想法指向行动​做事付出行动，没有这个其他的都是扯淡。开启新的进程，第一步就是去找学习资源，当时身边很少认识学长，老师，只能是自己去查找。比较幸运的是现在网络的发展，资源的获取非常方便，只要肯去查找，筛选。之前也有关注一些大牛的公众号，没事时就去看看他们之前分享的文章，也有学习路径推荐，最先关注的是公众号码农翻身，逐步的学习过程中，也有关注许多大牛（Hollis, 纯洁的微笑，zhisheng等等）,里面有刚参加工作的，也有从业几年的技术大佬，总结的经验值得我去学习，找到介绍 Java 主要后端编程，网站开发 刚开始就从语言出发,Java 开始学习，18年的上半年，也就是大二的下学期，开始看视频学习，找到的是毕向东 Java 的视频，只要是没课，就开始看视频学习，也有书做参考，有些内容需要书的辅助。 一套系列结束后，那时候大概是四月份。打开各种招聘网站还有牛客网（这个我之前我不认识，公众号里文章看到，或许上面的面经有些帮助吧），并不是去找工作了，再说了就这破水平，也没地方需要。上去看的目的就是了解一下，这方面工作需要掌握什么样的技术，才能够参加工作。打开 Java 搜索，大多都是属于网站，后端方面，当时看好多技术，不认识。接着学习，先得认识它，会使用它。开始找方法，看书，刷大牛的博客。开始先看书是怎样一个过程，然后去创建工程去实现它。最后学习完成后，自己还写了一个小项目，把学习到技术合在一起。差不多到放假七月份时候，暑假得做些事，利用暑假学习了框架的知识（Spring,Spring MVC,MyBatis），总算假期做些事，没有荒废掉。使用框架完善了之前的那个小项目，算是一个简单的实践。 假期将要结束时，五个人组织了一次自驾游（司机：铭），第一次和小伙伴自驾游，不知道以后还能不能有像现在一样说走就走的旅行。这次去的地方有高中同学，解决了我们住的地方，非常感谢沙沙安排。就是他家的那个锁，是真的差。 九月份来学校后，开始了学校的实训，我觉着没有一点含金量，不值得参加，没办法这都是之前不认真学习的结果，得认。没有参加学校安排的校外，选择校内，跟着老师。那三个星期是最颓废的时候，使用了 c# 来编写，这次的实训让我彻底认识到语言是相通的，编程是思想。国庆小长假和大多数同学都一样，利用假期去一些之前没有去过地方，七天三地，天津—大同-呼和浩特，（三哥，沙沙，胖妹妹）。 假期结束，热闹过后的安静，会有一些孤独感。调整状态，心静下来做自己的事。每年在这时候有很多参加完面试的大佬在牛客网上分享他们的经历与建议，空闲时间会上去刷一些面经。受到了很大打击，发现之前的学习积累的知识太片面，基本是停留在会用这个基础上，没有自己对一个知识点的理解与分析，太多的漏洞需要弥补。同时也为明年的实习有所担忧，只想着早点出去参加工作（没有考研准备），积累经验，觉着学校里没有很好的技术提升，需要做一些对自己有挑战性的项目，用实际项目来积累经验。目前的能力还不够应对工作岗位，只有不断的学习，关注行业动态。 我会有这样的一种状态，每天都在按着计划进行。感觉自己会一点技术，更多的是不会，开始认识 Java，网站后端，始学习 JavaSE, JavaEE，开始网站搭建，进行增删改查。这些刚刚达到入门级别，自己的不足越发明显，需要不断武装自己，时间在一天天过去。各种负能量造成焦虑，丧气状态，一切都源于目前的自己技能过于薄弱。 2019“好记性不如烂笔头” 多写，多做，少说话，说重点，争取在上半年能够找到实习公司。在日常生活中希望自己可以拿起相机，记录生活有意义的事情。 零散的记录。时间不等人，接下来继续努力，加油，共勉！ 2018/12/31 天津]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式及案例]]></title>
    <url>%2F2018%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[工厂模式学习工厂设计模式之前需要掌握两种设计原则： 依赖倒置原则：依赖抽象，不依赖具体类 开闭原则：两个主要特征，对于扩展是开放的和对于修改是关闭的。对于扩展是开放的：模块的行为是可扩展的，当应用需求改变时，可对模块进行扩展，使其具有新行为，可以改变模块的功能。对于修改是关闭的：当模块进行扩展时，不必改动源代码或二进制代码，不破坏原有系统结构。 工厂模式定义为：把可能会有所改变的代码（创建新对象的代码）放到另一个新对象中。称这个新对象为 “工厂”，处理创建对象的细节，用来封装对象的创建，让类决定创建的对象时什么。通过创建模式绕开 “new” ，避免对象创建过程中所导致的紧耦合（依赖具体类）. 工厂模式主要分为三大模式： 简单工厂模式（Simple Factory） 工厂方法模式 (Factory Method) 抽象工厂模式 (Abstract Factory) 以上三种模式从上到一逐步抽象 简单工厂模式（Simple Factory）简单工厂模式定义简单工厂模式又称静态工厂模式，简单工厂模式是一个工厂对象决定创建出哪一种产品类的实例，根据参数不同，返回不同的实例对象。属于创建型模式，不属于23种GOF设计模式之一。 案例创建抽象产品类 public abstract class MakeCar { public abstract void produce(); } 创建具体类，实现抽象产品类中方法 public class SaloonCar extends MakeCar { @Override public void produce() { System.out.println(&quot;创造轿车&quot;); } } public class Truck extends MakeCar { @Override public void produce() { System.out.println(&quot;创造卡车&quot;); } } 创建工厂类，使用 if-else 逻辑判断实例化对象 public class CarFactory { public MakeCar createCar(String type){ if (type.equals(&quot;轿车&quot;)){ return new SaloonCar(); } else if (type.equals(&quot;卡车&quot;)) { return new Truck(); }else { return null; } } } 编写测试类 public class Test { public static void main(String[] args){ CarFactory carFactory = new CarFactory(); MakeCar makeCar = carFactory.createCar(&quot;卡车&quot;); if (makeCar == null) { System.out.println(&quot;不在业务范围&quot;); return; } makeCar.produce(); } } 优点和缺点优点：用户无需写实例化类名，只需要传入相应参数即可，通过参数进行逻辑判断可以找到需要实例化的对象缺点：当添加新类时，需要对工厂整体进行改动，不利于系统的维护和扩展。例如：当我们想要在以上工厂中添加一个公交车，我们先需要定义一个类继承 MakeCar 类，然后再去 CarPactory 中修改逻辑代码，添加我们的公交车信息。这样操作是违反了开闭原则，不适用。 工厂方法模式 (Factory Method)工厂方法模式定义定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类实例化延迟（目的：解耦）到子类。核心共产个类不再负责所有产品的创建，将具体创建交给子类。核心工厂类成为一个抽象工厂角色，仅负责给出子类实现的接口。 角色 Product (抽象产品): 所有产品必须实现的公共接口 ConcreteFactory (具体产品): 实现抽象产品的接口，具体工厂和具体产品一一对应 Factory (抽象工厂): 声明工厂方法 ConcreteFactory (具体工厂): 实现抽象工厂中定义的工厂方法，返回一个具体产品类的实例 案例创建抽象产品类 public abstract class Car { public abstract void creat(); } 创建具体产品类，继承 Car 类 public class SaloonCar extends Car { @Override public void creat() { System.out.println(&quot;轿车&quot;); } } public class Truck extends Car { @Override public void creat() { System.out.println(&quot;卡车&quot;); } } 创建抽象工厂类 public abstract class CarFactory { public abstract Car CreatCar(); } 创建具体工厂类 public class SaloonFactory extends CarFactory { @Override public Car CreatCar() { return new SaloonCar(); } } public class TruckFactory extends CarFactory { @Override public Car CreatCar() { return new Truck(); } } 编写测试代码 public class Test { public static void main(String[] args){ SaloonFactory saloonFactory = new SaloonFactory(); TruckFactory truckFactory = new TruckFactory(); Car car = saloonFactory.CreatCar(); car.creat(); Car car_1 = truckFactory.CreatCar(); car_1.creat(); } } 优点和缺点优点：工厂方法用来创建用户所需要的产品，同时向用户隐藏实例化细节，用户只需要关心产品对应的工厂，无须关注创建细节，当需要添加新类时，不需要改变逻辑判断，只需要添加工厂类即可，符合开闭原则，缺点：在添加新类时，需要编写新的具体产品类和对应的具体工厂，在一定程度上增加了系统的复杂度， 抽象工厂模式 (Abstract Factory)抽象工厂模式定义提供一个接口，创建相关或依赖对象的家族，不需要明确指定具体类，在抽象工厂模式中，每一个具体工厂提供多个工厂方法用于生产多种不同类型的产品。 角色 AbstractFactory (抽象工厂): 声明抽象产品的方法，每一个方法对应一个产品 ConcreteFactory (具体工厂): 实现在抽象工厂中声明创建产品的方法，生产一组具体的产品 AbstractProduct (抽象产品): 为每种产品声明接口，在抽象产品中声明业务方法 ConcreteProduct (具体产品): 定义具体工厂生产的具体产品的对象，实现抽象产品的接口中声明的业务方法 案例定义抽象产品 public abstract class Glass { public abstract void creat(); } public abstract class Tire { public abstract void creat(); } 定义具体产品 public class SaloonGlass extends Glass { @Override public void creat() { System.out.println(&quot;轿车的玻璃&quot;); } } public class TruckGlass extends Glass{ @Override public void creat() { System.out.println(&quot;卡车的玻璃&quot;); } } public class SaloonTire extends Tire { @Override public void creat() { System.out.println(&quot;轿车的轮胎&quot;); } } public class TruckTire extends Tire{ @Override public void creat() { System.out.println(&quot;卡车的轮胎&quot;); } } 定义抽象工厂 public interface CarFactory { Glass creatGlass(); Tire creatTire(); } 定义具体工厂 public class SaloonFactory implements CarFactory { @Override public Glass creatGlass() { return new SaloonGlass(); } @Override public Tire creatTire() { return new SaloonTire(); } } public class TruckFactory implements CarFactory{ @Override public Glass creatGlass() { return new TruckGlass(); } @Override public Tire creatTire() { return new TruckTire(); } } 编写测试方法 public class Test { public static void main(String[] args){ CarFactory carFactory = new SaloonFactory(); Glass glass = carFactory.creatGlass(); Tire tire = carFactory.creatTire(); glass.creat(); tire.creat(); } } 优点与缺点在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以是一个类，或者一个接口。具体工厂类实现了抽象工厂每一个方法，返回一个对象，同一个具体工厂所创建的产品对象构成一个产品族。 优点：可以通过具体工厂类创建一个产品族中的多个对象缺点：需要加入产品族时，几乎要对所有类尽心修改，扩展性差，在创建系统时，对产品的等级结构划分非常重要 总结不论是简单工厂，工厂方法，还是抽象工厂，这些都属于工厂设计模式，实现该模式最终的目的就是在于解耦。例如我们创建汽车，开始不考虑轮胎和玻璃，使用简单工厂完全可以实现我们需求。但是当我们需求增加，增加玻璃和轮胎的适配，这时候就需要添加不同的产品，构成最终的产品族来实现需求，简单工厂模式这时候就改变为抽象工厂模式，来应对需求。当我们设计的产品减去某些方法，不再构成产品族时，这时候的抽象工厂模式就更改为工厂方法模式。三者根据不同的需求可做更改，切记不论使用哪种模式，必须达到解耦的目的，才属于工厂设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(-):基础搭建、整合应用]]></title>
    <url>%2F2018%2F12%2F21%2FSpring%20Boot-%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E3%80%81%E6%95%B4%E5%90%88%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring BootSpring Boot 是由 Pivotal 团队开发的全新框架，简化 Spring 初始搭建以及开发过程。易上手，开箱即用，推荐使用 Maven 构建，访问 http://start.spring.io/, 选择 Maven Project 下载 demo 项目，开启 Spring Boot 学习之旅。 目录结构为 程序开发及主程序入口：/src/main/java/ 配置文件：/src/main/resources 测试程序：/src/test/java application.java 该文件存放根目录下：/src/java/com/example/application.java 实体类：/src/java/com/example/domain/ 业务代码：/src/java/com/example/service/ 控制代码：/src/java/com/example/controller/ Maven 资源目录：/src/java/resources/ Spring Boot 项目静态文件目录：/src/main/resources/static Spring Boot 项目模版文件目录：/src/main/resources/templates Spring Boot 项目配置文件目录：/src/main/resources/application.properties Spring Boot MyBatis 映射目录：/src/main/resources/application.priperties applicarion.java: 带有 main() 方法的类，用于启动程序，程序的入口以上是使用官方示例，整合 Spring Boot + Mybatis + Thymeleaf 基础目录结构。相比 SSM 框架整合，Spring Boot 配置简单，不需要先配置 web.xml ，Spring, Mybatis，然后进行整合，简化我们的配置过程。 特性 能够快速创建基于Spring的应用程序 能够直接使用 Java 的 main 方法启动内嵌的Tomcat，Jetty服务器运行Spring Boot程序，不需要部署war包文件 提供约定的 starter POM 来简化来简化 Maven 配置，让 Maven 配置变得简单 根据项目的maven依赖配置，Spring boot自动配置 Spring, SpringMVC 等其它开源框架 提供程序的健康检查等功能。（检查内部的运行状态等） 基本可以完全不使用xml配置文件，采用注解配置 Spring Boot 整合 MyBatisSpring Boot 整合 MyBatis 与 SSM 整合类似，Spring Boot 配置简单，在 pom.xml 中引入依赖，还需要在 application.properties 文件中添加一下代码就可使用 // mapper 映射文件目录 mybatis.mapper-locations=classpath:mapper/*.xml // 实体类文件目录 mybatis.type-aliases-package=com.example.domain ThymeleafThymeleaf 事一款用于渲染 XML/XHTML/HTML 内容的模版引擎。类似 JSP， Velocity, FreeMaker等（目前只接触过 JSP），可以与 Spring MVC 等 Web 框架集成作为 Web 应用的模版你引擎。Thymeleaf 特点是能够直接在浏览器中打开并正确显示模版页面，不需要启动整个 Web 应用。 模版引擎：用于 Web 开发的模版引擎，为了使用户界面业务数据分离而产生，可以生成特定格式的文档，用于网站的模版引擎就会生成一个标准的 HTML 文档。 Spring MVC 中 @Controller 中的方法可以直接返回模版名称，接下来 Thymeleaf 模版引擎会自动进行渲染 模版中的表达式支持 Spring 表达式语言（Spring EL） Spring Boot 中使用，在 maven 中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 还需要在 application.properties 中进行 thymeleaf 配置 # thymeleaf 配置 spring.thymeleaf.prefix=classpath:/templates/ // 模版加载位置 spring.thymeleaf.suffix=.html // 指定后缀 spring.thymeleaf.mode=HTML spring.thymeleaf.encoding=UTF-8 // 指定编码 # 热部署文件，页面不产生缓存，及时更新 spring.thymeleaf.cache=false spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** 初识 Thymeleaf 通过 HTML 的标签属性渲染标签内容 &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;#{home.welcome}&quot;&gt;Welcome to our grocery store!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 语法使用表达式支持语法字面 文本文字（Text literals）:one text, Another one!,... 数字文本 (Number Literals) :0, 34 ,0.4... 布尔文本 (Boolean Literals) : true false 空 (Null Literal): null 文字标记 (Literal Tolers): one, sometext, main... #####文本操作 字符串连接 (String Concatenation): + 文本替换 (Literal Substitutions): |The name is ${name}| 算术运算 二元运算符 (Binary Operators): +, -, *, /, % 减号（单目运算符）Minus sign (Unary Operator): - 布尔操作 二元运算符 (Binary Operators): and, or 布尔否定（一元运算符）Boolean Negation(Unary Operator): !, not 比较和等价 比较 (Comparators): &gt;, &lt;, &gt;=, &lt;=, (gt, lt, ge, le) 等值运算符 (Equality Operators): ==, !=, (eq, ne) 条件运算符 if-then: (if) ? (then) if-then-else: (if) ? (then) : (else) Default:(value)?: defaultvalue 以上所有特征可以被组合，嵌套使用 th: 常用标签 关键字 功能介绍 案例 th:id 替换 id &lt;input th:id=&#39;xxx&#39; + ${collect.id}/&gt; th:text 文本替换 &lt;p th:text=&quot;${user.id}&quot;&gt;id&lt;/p&gt; th:utext 支持 html 的文本替换 &lt;p th:utext=${user.id}&gt;id&lt;/p&gt; th:object 替换对象 &lt;div th:object=&quot;${session.user}&quot;&gt; th:value 属性赋值 &lt;input th:value=&quot;${user.id}&quot;&gt; th:with 变量赋值 &lt;div th:with=&quot;isEven=${user.count}%2==0&quot;&gt;&lt;/div&gt; th:style 设置样式 th:style=&quot;&#39;display:&#39; + @{(${sitrue} ? &#39;none&#39; : &#39;inline-block&#39;)} + &#39;&#39;&quot; th:onclick 点击事件 th:onclick=&quot;&#39;getCollect()&#39;&quot; th:each 属性赋值 tr th:each=&quot;user,userStat:${users}&quot;&gt; th:if 判断条件 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:unless 与 if 判断相反 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:href 链接地址 &lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt; th:switch 多路选择，配合 th:case 使用 &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case th:switch 的一个分支 &lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt; th:fragment 布局标签，定义一个代码段，方便其他地方引用 &lt;div th:fragment=&quot;alert&quot;&gt; th:include 布局标签，替换内容到引入的文件 &lt;headth:include=&quot;layout ::htmlhead&quot;th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt; th:replace 布局标签，替换整个标签到引入的文件 &lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt; th:selected selected 选择框 th:selected=&quot;(${xxx.id} == ${configObj.dd})&quot; th:src 图片类地址引入 &lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:inline 定义 js 脚本可以使用变量 &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; th:action 表单提交地址 &lt;form action=&quot;subscribe.html&quot; th:action=&quot;@{/subscribe}&quot;&gt; th:remove 删除某个属性 &lt;tr th:remove=&quot;all&quot;&gt; th:attr 设置标签属性，多个属性可以用逗号分隔 比如 th:attr=&quot;src=@{/image/aa.jpg},title=#{logo}&quot;，此标签不太优雅，一般用的比较少。 变量&lt;p&gt;Hello World! &lt;span th:text=&quot;${today}&quot;&gt;&lt;/span&gt;&lt;/p&gt; 假设 today 是变量，使用 ${...} 来表示获取变量的值 URLThymeleaf 对 URL 的处理语法是通过 @{URL} 进行处理。使用 th:href , th:src 等属性进行 URL 渲染。 循环使用较多的对 &lt;table&gt; 进行渲染，可以使用 th:each ，相当于 Java 中 foreach 循环。 条件求值th:if 和 th:unless 属性进行条件判断， th:unless 于 th:if 恰好相反，只有表达式不成立才会执行Swith 结构使用 th:swich，默认属性 default 使用 * 来表示 Utilties为了提高可用性，Thymeleaf 提供了一系列的 Utilty 对象（内置于 Context 中），通过 # 直接访问常用有： #dates, #strings, #lists 等]]></content>
      <categories>
        <category>后端生态</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-异常处理机制]]></title>
    <url>%2F2018%2F11%2F22%2FJava-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[异常处理每个程序在运行时，都会出现不被期望的事，它的出现组织了程序正常执行，这种情况被称为异常。在 Java 语言中提供了解决方法：异常处理机制。 异常处理机制Java 中异常可以是函数运行时引发的，也可是通过 throw 语句抛出。Throwable 类是异常处理的顶级父类。一个对象只有一个 Throable 类，或者说一个对象只有是 Throwable 类的直接或间接实例，他才是一个异常对象，才能被异常处理识别。 Throwable 图中可以可以认识到异常处理类之间关系。Error 和 Exception 继承自 Throwable 类，这俩个类又在对不同的异常做处理， Error: JVM 本身的错误,编译时系统错误Exception: 程序运行时发生的异常 Exception 又被分为 RuntiomeException （运行时异常）和 IOException （IO异常）。 异常处理在 Java 中还被分为检查异常和非检查异常 检查异常 除去 Error 和 RuntiomeException 与其子类，其他的都是检查异常； 什么是检查异常？在代码编译运行之前，编译器要求你对某段代码必须加 try…catch，或者 throws exception。出现这类情况的异常就属于检查异常。解决方式： throws exception ，一直抛出，一直抛到虚拟机处理。2. 使用 try…catch 捕获非检查异常与检查异常相反，编译器不强制处理的异常，包括 Errow 和 RuntimeException 及其子类。处理方式：1. 捕获 2. 继续抛出 3. 不处理Error多数由 Java 虚拟机生成并抛出，大多数错误与代码编写者无关。当错误发生在这里，程序是无法控制和处理，所以程序中无法对异常进行捕获。Exception程序自身可以进行控制和处理。在编写程序过程中，最常见的错误都在这里，比如 RuntimeException 及其子类异常，这些属于非检查异常，一般不需要处理，通常出现错误是程序逻辑错误引发异常。异常处理异常处理关键字 关键字 作用 try 用于监听，将要监听的代码放在 try 语句块之内，当该语句块发生异常，异常抛出 catch 用于捕获异常，捕获 try 语句块之内的异常 finally 不论异常是否发生，该语句块都会被执行，通常用来做资源释放，关闭文件，关闭数据库连接等，不做异常处理。如果在该语句块内使用 return 或 throw 等种植方法语句，直接结束，不会执行 try 或 catch 语句块 throw 用于抛出异常 throws 用在方法签名中，用于声明该方法可能抛出异常 抛出异常定义：一个方法不处理该异常，向上传递。谁调用该方法，谁来处理。关键字 throw 和 throws 区别：throw: 用于方法体内。throw 后接的是异常对象，或者异常对象的引用。throws: 用于方法名后，多个异常使用逗号分隔，检查异常处理时使用该关键字。异常不一定发生。注意：如果在 main 方法使用该关键字，会导致程序终断。 捕获异常使用 try…catch 来捕获异常，try 后可以有多个 catch 可以针对不同的异常进行处理。需要注意的是捕获异常的大小区分，当进行捕获异常时，先要捕获小的异常，再捕获大的异常。 自定义异常已经被封装好的异常处理是通常在写程序中较多出现的错误，而在写程序过程中，会出现某个程序中特有的问题，我们想要进行异常处理，但是这些异常却没有被 Java 封装成对象。所以这时候我们就需要自己来完成所要解决的异常处理。创建自定义异常必须要继承 Throwable 或者它的子类 Excepeiton。 class 自定义异常 extends 异常类型（Exception）{ // 在这里重写有参和无参构造方法 }]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC 源码解读]]></title>
    <url>%2F2018%2F11%2F20%2FSpring-IoC-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Spring IoCIoC(Inversion of Control):Spring 框架中重要的一种理念，之前有过这方面的介绍。这篇主要记录 IoC 实现过程，如何完成控制反转。我们在使用 Spring 时，需要一种描述让 IoC 容器知道创建的对象与对象的关系，这个描述就是我们的可配置文件。（xml, properties）。 BeanFactory可以理解为生产 bean 的工厂，负责管理各个 bean 实例。它是 IoC 容器最基本的接口，提供最基本的 IoC 容器的功能，下面是 BeanFactory 源代码。 public interface BeanFactory { String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; // 根据 bean 的名字，获取容器中 bean 实例 Object getBean(String name) throws BeansException; // 根据 bean 的名字和 Class 类型的到 bean 实例，增加类型安全验证机制 &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; // bean 的索引，检查容器中是否有相同名字的 bean boolean containsBean(String name); // 根据 bean 的名字，得到 bean 的实例，并且判断这个 bean 是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; // 查询制定名字的 bean 是否是 prototyoe 类型，属性可以由用户在 BeanDefinition 中制定 boolean isPrototype(String name) throws NoSuchBeanDefinitionException; // 指定 bean 名字的 Class 类型是否是特定 Class 类型 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; // 得到 bean 实例的 Class 类型 Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; // 得到 bean 的别名 String[] getAliases(String name); } BeanFactory想要分析源码，首先对接口，类的继承关系有一个初步的认识，先要对整体有个宏观概念，为接下来细分代码做准备，从大到小的顺序进行分析源码。BeanFactory 是一个接口，与其他接口关系如下图：实现该接口有三个子接口，ListableBeanFactory,HierarchicalBeanFactory,AutowireCapableBeanFactory。上图可以看出最后默认实现类为 DefaultListableBeanFactory，这是 BeanFactory 重要实现类。图中 ApplicationContext 在 IoC 容器扮演者重要的角色，ApplicationContext 启动过程中，负责创建实例 Bean，往各个 Bean 中注入依赖等。 ApplicationContextSpring 提供了许多 IoC 容器的实现，如上图所示: ClassPathXmlApplication, FileSystemXmlApplication, AnnotationConfigApplicationContext.在这三个类中，都有一个重要的方法 refresh() 。该方法作为初始化 IoC 容器的入口，这一方法属于核心方法，重点分析。在这里我们使用 ClassPathXmlApplicationContext 继续解读 Spring IoC 整个过程。 public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext { private Resource[] configResources; // 如果已经存在 ApplicationContext 需要调用此方法配置成父子关系 public ClassPathXmlApplicationContext(ApplicationContext parent) { super(parent); } ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException { super(parent); // 根据提供路径，解析配置文件 this.setConfigLocations(configLocations); if (refresh) { this.refresh(); // 核心方法 } ... } } IoC 容器初始化过程当执行 refresh(()。标志着 IoC 容器正式启动，会经历三个基本的过程，包括定位，载入，注册。执行 refresh() 方法会将原来的 ApplicationContext 销毁，然后重新执行一次初始化操作。 public void refresh() throws BeansException, IllegalStateException { Object var1 = this.startupShutdownMonitor; // 防止 refresh（）还没有结束，又来一个启动或者执行操作 synchronized(this.startupShutdownMonitor) { // 准备工作，记录容器启动时间 this.prepareRefresh(); // 执行完这步后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，但是这步还没有将 Bean 初始化，只是将配置文件中信息解析出来。 ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); // 设置 BeanFactory 类加载器， this.prepareBeanFactory(beanFactory); try { this.postProcessBeanFactory(beanFactory); this.invokeBeanFactoryPostProcessors(beanFactory); this.registerBeanPostProcessors(beanFactory); this.initMessageSource(); this.initApplicationEventMulticaster(); this.onRefresh(); this.registerListeners(); // 初始化所有 singleton beans （lazy-init 的除外） this.finishBeanFactoryInitialization(beanFactory); // ApplicationContext 初始化完成，结束 refresh() 过程 this.finishRefresh(); } catch (BeansException var9) { if (this.logger.isWarnEnabled()) { this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9); } // 销毁已经初始化的 singleton beans ，防止资源占用 this.destroyBeans(); this.cancelRefresh(var9); throw var9; } finally { this.resetCommonCaches(); } } } 看过 refresh() 方法整体内容后，开始逐步分解代码。prepareRefresh() 该方法是穿件 Bean 容器前的准备工作，比如 记录容器启动时间就在该方法里设置。 Resource定位准备工作结束后，代码执行到 obtainFreshBeanFactory() 方法，该方法非常重要，初始化 BeanFactory，加载 Bean， 注册 Bean，都会在该方法内进行完成。（Bean 实例并不在这里完成）。 protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { this.refreshBeanFactory(); // 返回刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = this.getBeanFactory(); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Bean factory for &quot; + this.getDisplayName() + &quot;: &quot; + beanFactory); } return beanFactory; } 这里最重要的过程在 refreshBeanFactory() 中，Spring IoC 容器启动从这里开始。该方法是 AbstractApplicationContext 中的抽象方法。具体实现不在这里，而是在它的子类中实现， protected final void refreshBeanFactory() throws BeansException { // 如果之前加载过 BeanFactory ，销毁所有 Bean ，关闭 BeanFactory,这里不是只全局 BeanFactory ,只是指当前 ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); } } 先执行refreshBeanfactory()判断完是否有工厂后，开始载入 Bean 的定义，先经过方法customizeBeanFactory(beanFactory);该方法的作用是是否容许 BeanDefinition 覆盖,是否容许循环应用。这里就可以帮助我们解答在刚学习 Spring 时遇到的在配置文件中定义 bean 时使用了相同的 id 或 name 的问题，如果同意配置文件中重复，会抛错，不是同一个配置文件中，会覆盖。 接着是 loadBeanDefinitions(beanFactory)。此方法根据配置，加载各个 Bean ,然后放到 BeanFactory 中。接着我们到 AbstractRefreshableApplicationContext 类下找到 loadBeanDefinitions方法，在 AbstractXmlApplicationContext 类下找到该方法 protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); initBeanDefinitionReader(beanDefinitionReader); // 从这里出发继续分析源码 loadBeanDefinitions(beanDefinitionReader); } 按照 loadBeanDefinitions(beanDefinitionReader) 继续查找，接着来到 AbstractXmlApplicationContext 类下。 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); } } 这里有俩个分支，先选择第一个分支。接着到 BeanDefinitionReader 接口下。找到 loadBeanDefinitions 方法 public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, &quot;Resource array must not be null&quot;); int counter = 0; for (Resource resource : resources) { counter += loadBeanDefinitions(resource); } return counter; } 来到 BeanDefinitionReader 接口，在 XmlBeanDefinitionReader 类中找到 loadBeanDefinitions 方法 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) { logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); } // 存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { // 将资源文件转换为 IO 输入流 InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } // 从这里继续查找，这里是具体读取过程的方法 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 将 XML 文件转换为 DOM 对象 Document doc = doLoadDocument(inputSource, resource); // 启动时 Bean 定义解析详细过程， return registerBeanDefinitions(doc, resource); } ...... } 接着 registerBeanDefinitions 继续分析 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 对 XML 格式的 BeanDefinition 解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 获得容器中注册的 Bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // 解析过程入口， documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 统计解析 Bean 数量 return getRegistry().getBeanDefinitionCount() - countBefore; } BeanDefinitionDocumentReader 是一个接口，具体实现类在 DefaultBeanDefinitionDocumentReader public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); // 获取根元素 Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root); } 真正开始解析配置文件里内容是由 doRegisterBeanDefinitions(root); 方法开始解析 protected void doRegisterBeanDefinitions(Element root) { // 该类负责解析 Bean 定义 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; } parseBeanDefinitions(root, this.delegate); 核心方法，负责解析 标签 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { // 遍历根元素所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); // 如果节点是 XML 元素节点 if (node instanceof Element) { Element ele = (Element) node; // 如果节点使用的是 Spring 默认 XML 命名空间 if (delegate.isDefaultNamespace(ele)) { // 使用 Spring 的 Bean 规则解析元素节点 parseDefaultElement(ele, delegate); } else { // 如果没有使用 Spring 默认的 Bean 命名空间，使用用户自定义的解析规则解析元素（自定义的 xsd） delegate.parseCustomElement(ele); } } } } else { // 根节点没有使用 Spring 默认命名空间，使用用户自定义规则解析 delegate.parseCustomElement(root); } } 以上方法主要是判断是否为 Spring 默认命名空间，接着我们看使用 Spring 默认命名空间后，执行 parseDefaultElement(ele, delegate); 方法。 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // 如果节点是 import 导入元素，进行解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // 如果元素节点是 Alias 别名元素，进行别名解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // 如果是普通 Bean 元素，进行 Spring 的 Bean 规则解析 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 如果碰到嵌套 beans 标签，需要递归 doRegisterBeanDefinitions(ele); } } 直接来到 Bean 规则解析，这里的 DeanDefinitionHolder 是对 BeanDefinition 的封装，包括 BeanDefinition, beanName, aliases protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // 向 Spring IoC 容器注册解析得到的 Bean 定义 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 在进行标签解析之前，先回顾 标签里可以定义的属性 Property - calss 类的全限定名 name 可指定 id, name (用逗号，分号，空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autoworting mode no(默认值),byName,byType,constructor lazy-initialization mode 是否类加载 initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 将 name 属性的定义按照 逗号 分号 空格 切分，形成一个别名列表组 List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; // 如果没有指定 id，那么用别名列表的第一个名字作为 beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;); } } // 检查 &lt;bean&gt; id 和 name 的唯一性。 if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } // 从这里对 &lt;bean&gt; 元素详细解析 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { // 如果 &lt;bean&gt; 没有配置 id, name, 或者别名，为解析的 bean 生成一个唯一 beanName 并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { // beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } parseBeanDefinitionElement中放着具体参数配置 public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) { // 记录解析 Bean this.parseState.push(new BeanEntry(beanName)); // 读取配置的 class 名字，然后记录到 BeanDefinition 中，并不做实例化 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { // 如果配置了 parent 属性，获取 parent 属性的值 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析 &lt;bean /&gt; 内部的子元素，解析的星系放到 bd 中 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null; } 以上的代码内容就可解释在使用 Spring 是，配置文件中 标签中的属性是如何解析到 Bean 中。在上述解析过程中并没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类 BeanDefinition, 将 中配置信息设置到 BeanDefinition 中作为记录。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC]]></title>
    <url>%2F2018%2F10%2F20%2FSpring-IoC%2F</url>
    <content type="text"><![CDATA[认识Spring IoC DI 依赖注入 Dependency Injection IoC 控制反转 Inversion of Control IOC Container 容器 Inversion of Control Container 理解 IoC DIIoC (Inversion of Control) 控制反转，是由软件专家 Michael Mattson 提出的一个理论，用于解决复杂系统中的耦合关系。后来这个理论被逐渐应用到实践中，例如 J2EE 中的 Spring 框架中，IoC 就成为核心功能实现。 IoC(Inversion of Control)Spring IoC(Inversion of Control) 别名 DI(Dependency Injection) 依赖注入，而事实上二者并非相同。IoC(Inversion of Control)是面向对象的一种思想，DI(Dependency Injection)是实现这一思想的方法。 控制反转是目的，依赖注入是实现控制反转的手段。控制反转是将某个类对其内部状态权交给其他机制去完成，为降低类与类之间的耦合度。这个时候就出现了一个新的概念 IoC Container 称为 IoC 容器，在这里面从放着所有类与类依赖关系的方法，这时候 IoC 容器就充当着一个第三方角色，想要解决某个问题直接告诉 IoC 容器，它为我们找到解决问题的方式。 DI(Dependency Injection)DI(Dependency Injection)依赖注入 就是在 IoC 容器运行期间动态的将某种依赖关系注入到对象中，实现 IoC 的方法。利用依赖关系的注入的方式，实现对象之间的结耦。IoC 容器就是一个对象的制造工厂，当你使用某个功能时，你只要调用其方法就可以实现。你的关注点只在如何使用，至于其方法是如何创建，何时销毁等不需要关心，这一切都是由 IoC 容器进行实现。 实例当我们打开机械手表后，会看到上图所示的场景，各个齿轮带动时针，分针，秒针的转动，相互依赖，从而在表盘上产生正确的时间。但是当其中某个齿轮损坏后，整个系统可能将停止运转，之间存在这复杂的耦合关系。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。为了有效的避免出现这样的问题，我们对其引入 IoC(Inversion of Control)来解决。 当我们引入 IoC 容器后，我们可以发现其中 A,B,C,D这四个齿轮不再是相互依赖的关系，而是共同依赖于 IoC 容器这个第三方的，IoC 容器成为整个系统的一个核心，A,B,C,D四个齿轮的转动都依赖于 IoC 容器。 ##文档参考： Dependency Injection Inversion of Control Containers and the Dependency Injection pattern]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC 初相识]]></title>
    <url>%2F2018%2F07%2F30%2FSpring-MVC%2F</url>
    <content type="text"><![CDATA[Spring-MVC 认识要学习使用 Sring-MVC 需要了解，掌握一副图，展示了它的工作原理。需要理解并记牢每一步的所要完成的任务。 用户发送一个请求，请求先到达 DispatcherServlet ，它需要知道，应该将请求交给哪一个控制器去处理请求 DispatcherServlet 会去 Hander Mapping （处理器映射）查询下一站应该去何处。Hander Mapping 会将 DispatcherServlet 携带的 URL 进行判断，将结果告诉 DispatcherServlet ，然后将请求送达对应的控制器 控制器进行数据逻辑处理，处理后会产生用户所需要的信息（Model），还需要一个展示模型的页面（JSP）,控制器将处理完的结果进行整理（ModelAndView）,返回给 DispatcherServlet 这时候的虽然得到了 ModelAndView ，但是这里的 View 仅仅是一个逻辑名称，所以接下来需要将信息交给 ViewResolver（视图解析器）进行处理，返回一个相应的页面。 最后将解析完成的 ModelAndView 返回给用户。 到这结束用户的发送的一次请求到响应完成。接下来应该逐步认识需要做的配置 DispatcherServletDispatcherServlet（中央调度器）继承 HttpServlet ,所以我们要对 DispatcherServlet 进行所需要的配置就应该在 web.xml 中进行声明。 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 完成一个处理 “.do” 结尾的请求处理。在初始化 DispatcherServlet 得时候，如果不配置 ，Spring-MVC 默认会去 /WEB-INF 寻找 [servlet-name]-serlvet.xml 文件，例如：如果此 DispatcherServlet 不配置 ，它会在 /WEB-INF/springmvc-servlet.xml ,没有找到该配置文件，出异常报错。建议大家在此配置 contextConfigLocation ,如果不在 WEB-INF 目录下，要用 classpath: 指出该配置文件的路径。 上面说到该配置会处理一个 “.do” 结尾的请求处理，是因为我们在 中配置了 *.do 拦截请求方式，我们还可以进行其他的配置，产生不同的作用。 配置 / ：此工程所有的请求全部由 Spring-MVC 解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由 Spring-MVC 解析 配置 .do 或者 .action , 所有请求的 url 扩展名为 .do 或 .action 由 Spring-MVC 解析（建议使用此方法） 不可以配置 / ,如果配置 / ,返回 JSP 也由 Spring-MVC 解析，这是不对的 ViewResoler（视图解析器）当请求到达 ViewResoler ，需要完成一个任务，就是告诉 DispatcherServlet 该请求应该得到哪一个页面。我们需要配置一个视图解析器完成此操作。根据上述 DispatcherServlet 的配置信息，需要找到 spring 文件夹下的 spring-mvc.xml 进行配置。 &lt;bean id=&quot;resourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 进行该配置后，每次对请求的是图处理都会按照 此方式进行解析。如果我们使用 Spring-MVC 的注解，需要在该配置文件下，引入 mvc 命名空间，用 mvc:annotation-driven/ 进行声明]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring-MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring - AOP]]></title>
    <url>%2F2018%2F07%2F20%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[spring - AOPAOP （aspect object programming） 称为面向切面编程。可以理解为一个拦截框架，类似 Servlet 中的 Filter ，思想相同。 AOP基本概念 连接点（Jointpoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为“在哪里干”； 切入点（Pointcut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为“在哪里干的集合”； 通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为“干什么”； 方面/切面（Aspect）：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为“在哪干和干什么集合”； 引入（inter-type declaration）：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为“干什么（引入什么）”； 目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁干”； AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。 织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。 通知分类 前置通知（Before Advice）：在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）； 环绕通知（Around Advices）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。 后置通知（After Advice）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知： 后置返回通知（After returning Advice）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。 后置异常通知（After throwing Advice）: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。 后置最终通知（After finally Advice）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。 AOP 注解使用编写切入点 execution(* 方法所属类.方法(..)) @Aspect 指定一个类为切面类 @Pointcut(“execution(* com.carlos.pointCut(..))”) 指定切入点表达式 @Before(“pointCut()”) 前置通知: 目标方法之前执行 @After(“pointCut()”) 后置通知：目标方法之后执行（始终执行） @AfterReturning(“pointCut()”) 返回后通知： 执行方法结束前执行(异常不执行) @AfterThrowing(“pointCut()”) 异常通知: 出现异常时候执行 @Around(“pointCut()”) 环绕通知： 环绕目标方法执行 executionexecution是使用的最多的一种Pointcut表达式，表示某个方法的执行，其标准语法如下。execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?) modifiers-pattern表示方法的访问类型，public等；（修饰类型，可以不写） ret-type-pattern表示方法的返回值类型，如String表示返回类型是String，“*”表示所有的返回类型；（方法返回值类型，必写） declaring-type-pattern表示方法的声明类，如“com.elim..*”表示com.elim包及其子包下面的所有类型；（方法声明类型，可以不写） name-pattern表示方法的名称，如“add*”表示所有以add开头的方法名；（要匹配的名称，括号里是方法的参数） param-pattern表示方法参数的类型，name-pattern(param-pattern)其实是一起的表示的方法集对应的参数类型，如“add()”表示不带参数的add方法，“add()”表示带一个任意类型的参数的add方法，“add(,String)”则表示带两个参数，且第二个参数是String类型的add方法； throws-pattern表示异常类型；其中以问号结束的部分都是可以省略的。（方法抛出的异常类型，可以不写） “execution(* add())”匹配所有的不带参数的add()方法。 “execution(public com.elim...add*(..))”匹配所有com.elim包及其子包下所有类的以add开头的所有public方法。 “execution( (..) throws Exception)”匹配所有抛出Exception的方法。 AOP XML文件使用 aop:config 大多数 aop:* 元素都需要在aop:config元素内 aop:before 前置通知 aop:after 后置通知（不论被通知方法是否执行） aop:aspect 定义一个切面 aop:pointcut 定义一个切点 aop:after-returning 返回通知 aop:after-throwing 异常通知 aop:around 环绕通知 aop:declare-parents 以透明方式为被通知的对象引入额外的接口 aop:advisor 定义通知器 aop:aspectj-autoproxy 启用@AspectJ注解驱动的切面 以上我们对于 AOP 的使用有一个初步的认识，接下来通过一个实例，实践 AOP 的功能应用。分别使用注解方式与 XML 文件配置方式实现 AOP 使用实例创建实例接口package com.spring; public interface ISomeService { void doFirst(); String doSecond(); void doThird(); } 使用 XML 文件实现 AOPpackage com.spring; public class SomeServiceImpl implements ISomeService { @Override public void doFirst() { // 执行 doFIrst() 方法 System.out.println(&quot;SomeService first&quot;); } @Override public String doSecond() { // 执行 doSecond() 方法 System.out.println(&quot;SomeService second&quot;); return &quot;Second&quot;; } @Override public void doThird() { // 执行 doThird() 方法 System.out.println(&quot;SomeService third&quot;); } } 编写目标类package com.spring; import org.aspectj.lang.ProceedingJoinPoint; public class MyAspect { // 执行前调用 public void before(){ System.out.println(&quot;before&quot;); } // 执行后调用 public void after(){ System.out.println(&quot;after&quot;); } public void around(ProceedingJoinPoint pj) throws Throwable{ System.out.println(&quot;around before&quot;); pj.proceed(); System.out.println(&quot;around after&quot;); } } 注意：使用环绕通知必须要使用 ProceedingJoinPoint 。使用它来调用被通知的方法，需要调用 proceed() 方法来实现功能。如果忘记调用此方法，会阻塞对被通知的方法的调用。 创建 XML 文件 ApplicationContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.spring.SomeServiceImpl&quot; /&gt; &lt;!-- 注册切面 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.MyAspect&quot;/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 定义切点 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doFirst(..))&quot; id=&quot;first&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doSecond(..))&quot; id=&quot;second&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(* com.spring.ISomeService.doThird(..))&quot; id=&quot;third&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;first&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;second&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;third&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 使用注解方法完成 AOP&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt; &lt;!-- 注册切面 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.MyAspect&quot;&gt;&lt;/bean&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.spring.SomeServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 注册Aspect --&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 使用注解方式，必须在 ApplicationContext.xml 文件中添加 &lt;aop:aspectj-autoproxy/&gt; 用于启用 AspectJ 自动代理 编写目标类@Aspect // 表示该类为切面 public class MyAspect { // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doFirst(..))&quot;) public void first(){} // 通知前 @Before(&quot;first()&quot;) private void before(){ System.out.println(&quot;before&quot;); } // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doSecond(..))&quot;) public void second(){} // 通知后 @After(&quot;second()&quot;) public void after(){ System.out.println(&quot;执行 doSecond() after&quot;); } // 切面点 @Pointcut(&quot;execution(* com.spring.ISomeService.doThird(..))&quot;) public void third(){} // 环绕通知 @Around(&quot;third()&quot;) public void around(ProceedingJoinPoint pj) throws Throwable{ System.out.println(&quot;third 执行之前&quot;); pj.proceed(); System.out.println(&quot;third 执行之后&quot;); } } 编写测试类public class MyTest { // 使用注解 调用 Test 测试方法 @Test public void test1(){ String s = &quot;com/spring/ApplicationContext.xml&quot;; ApplicationContext ac = new ClassPathXmlApplicationContext(s); ISomeService service = (ISomeService) ac.getBean(&quot;someService&quot;); service.doFirst(); System.out.println(&quot;=============&quot;); service.doSecond(); System.out.println(&quot;==============&quot;); service.doThird(); } } 以上内容通过一个小实例完成对 AOP 的应用实现，简单的做一个认识了解。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-关键字volatile]]></title>
    <url>%2F2018%2F05%2F09%2FJava-%E5%9F%BA%E7%A1%80-%E5%85%B3%E9%94%AE%E5%AD%97volstile%2F</url>
    <content type="text"><![CDATA[Java 内存模型Java 内存模型定义：屏蔽掉各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下能达到一致的内存访问效果。避免更换平台后在并发问题上出现访问错误。在 Java 内存模型中规定所有变量存储在主内存中，每一个线程都有自己工作内存，每个线程都有对变量的读取操作都是在自己的工作内存中操作，线程之间不会有通讯，比如线程 A 对一个变量进行修改，此时的线程 B 并不知道线程 A 在对变量进行修改。线程对变量处理完成后到会写到主内存中，主内存内实现线程之间的变量值传递。 下图为线程、工作内存、主内存之间的关系 volatile在 Java 内存模型中每个线程都有自己的工作内存，比如在并发情况下的 （i++），当线程 A 先进行 i++ ，此时是在自己的工作内存中进行运算，还没有写到主内存中，线程 B 也在进行 i++ ，也在对 i 变量做更改，再写入主内存中，就会造成数据不一致。只要让在并发的过程中数据进行同步就可避免问题出现，在 Java 中提供的关键字 volatile 就可以解决此类问题 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 主要用于处理多线程问题，处理指令重排序问题，在 Java 1.5 之后解决指令重排序问题，实现多线程下的单例模式。能保证可见性，有序性，但不保证原子性。 第二条中说禁止进行指令重排序在多线程的单例模式中发挥重要的作用,指令重排序主要是指在硬件方面，CPU 采用了容许将多条指令不按规定顺序分开发送给各相应电路单元处理，并不是指令任意重排，对于两条指令有依赖，还会按原来顺序处理，只会对没有依赖的指令进行重排，比如在多线程情况下解决以下代码问题 singleton = new Singleton(); 在单线程情况下，该段代码会分成三部 分配内存 实例化对象 将实例化对象给 singleton 赋值 这三个过程是没有依赖，在工作内存中无论怎样排序执行都不会影响最后写入到主内存中的数据，但是在多线程情况下，比如多线程单例模式中的，双重检查锁，如果没有之前的 volatile 修饰变量，会出现线程 A 进入实例化代码块内，进行实例化，此时有可能重排序，先执行第三步，此时的 singleton 还是为空，线程 B 进行判断为空，也会进入执行代码块内，就会出现实例化多个对象，违反了单例模式的定义。 解决此类问题可以使用，关键字 volatile ，它的工作原理是，当多个线程进行处理同一变量，在执行被 volatile 关键字修饰的代码时，会在编译代码后添加一句 lock add1 $0x0, (%esp)，充当一个内存屏障操作，保证线程之间的可见性。 内存屏障（Memory Barrier）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。 加上内存屏障之后，其实实例化代码还是会重排序，但是一旦一个线程进行访问处理，其他线程就不会执行同样的代码块，相当于一但开始对被 volatile 修饰的变量进行处理，改变量的读写操作只容许一个线程访问，其他线程没有权利进行读写操作。 volatile是通过内存屏障来来禁止指令重排的。 参考 《深入理解 Java 虚拟机》]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-线程进阶]]></title>
    <url>%2F2018%2F04%2F30%2FJava-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[线程之前的学习我们知道，线程是比进程更轻量级的调度执行单位，线程把进程的资源分配和执行调度分开，线程可共享进程资源(内存地址，问价 I/O 等)，又可独立调度( CPU 是调度的基本单位) 线程调度线程调度是指系统为线程分配的处理器 分为两种 协同式线程调度 抢占式线程调度 Java 语言中使用的是抢占式线程调度，线程的调度不由本身决定，在整个的运行期间线程是可控的，不会发生某个线程的异常从而导致整个进程的阻塞。使用优先级来判断执行顺序，之前介绍过在 Java 中线程优先级分为 10 个等级，优先级越高，越容易被执行。另一种协同式线程调度同样属于多线程调度，与抢占式线程调度的工作方式不同，使用协同式线程调度的系统，线程的执行时间由线程本身来决定，只有当一个线程执行执行完毕，然后通知系统切换另一个线程，与串行概念相同。使用该方式避免了线程同步的概念，只有一个线程执行完毕后，才会执行下一个。但是如果某个线程出现编写问题，一直不告诉系统需要切换下一个线程，那么程序就会一直阻塞在哪里，会导致系统的崩溃。 线程状态转换一个线程有五种状态，创建，运行，等待，阻塞，终止。五种状态之间是如何转换的，下图很清晰的为我们解释清楚他们之间的状态转换切记在任意时间点，一个线程有且只有一种状态。 线程的三大特性原子性 (Atomicity)原子性是指一个操作不可中断，一旦一个操作开始，就不会被其他的线程干扰，比如给 i 进行赋值，线程 A 赋值 1，线程 B 赋值 -1。i 的值要么是 1 ，要么是 -1，线程 A 和 线程 B 之间没有干扰，赋值过程中不可被中断 可见性 (Visibility)当一个线程对某一个共享数据进行修改，其他的线程能否知道这个修改。在 Java 中可见性可以通过关键字 synchronized 和 final 来实现。 有序性 (Ordering)在 Java 语言中提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。Java 内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。 线程安全线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。—《Java Concurrency Inpractice》作者 Brian Goetz。 如何实现线程安全加锁，互斥同步 同步：是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用，保证数据的安全性。 互斥是因，同步是果；互斥是方法，同步是目的。 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，也称为阻塞同步。实现互斥方法需要使用关键字 synchronized 。 使用一个带有 synchronized 和 不带有 synchronized 案例来进行比较编写一个类实现 Runnable 接口 class MyThread implements Runnable { private int val = 10; public void run() { while (val &gt; 0) { show(); try { Thread.sleep(100); // 睡眠一秒实现线程交替执行 } catch (InterruptedException e) { e.printStackTrace(); } } } public void show(){ System.out.println(Thread.currentThread().getName() + &quot; = &quot; + val--); } } 添加测试类 public class Thread_1 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); Thread thread1 = new Thread(myThread); thread.start(); thread1.start(); } } 运行结果 Thread-0 = 10 Thread-1 = 9 Thread-1 = 8 Thread-0 = 7 Thread-1 = 6 Thread-0 = 6 Thread-0 = 5 Thread-1 = 4 Thread-0 = 3 Thread-1 = 3 Thread-0 = 2 Thread-1 = 1 这里我们先不加 synchronized ，从结果可以看出数据没有同步，有错误，对同一个数据进行修改，没有实现线程安全。接下来修改 show() 方法，再词比较结果 public void show(){ synchronized (MyThread.class){ System.out.println(Thread.currentThread().getName() + &quot; = &quot; + val--); } } 修改后的结果为 Thread-0 = 10 Thread-1 = 9 Thread-0 = 8 Thread-1 = 7 Thread-1 = 6 Thread-0 = 5 Thread-1 = 4 Thread-0 = 3 Thread-1 = 2 Thread-0 = 1 由运行结果清楚可知论哪一个线程进入，对于数据修改都进行同步，没有出现数据不匹配，实现了线程安全。这里实现线程安全的方式只是加锁，但是遇到问题就给加锁是不可取的对数据进行读写操作需要加锁，如果代码中没有进行变量的交互，线程之间不会造成影响，也称线程安全。互斥同步属于一种悲观的并发策略，只要是不去做正确的同步措施，数据肯定会出现问题。无论共享数据是否真的会出现竞争，都要进行加锁（实际上可以优化掉部分不必要的锁）。这里只是简单使用了 synchronzied ，锁的知识还需要深入挖掘分析，后面会详细写一篇关于锁的学习记录。 不共享状态 无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。 线程关闭： 仅在单线程环境下使用。 不可变对象使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-线程入门]]></title>
    <url>%2F2018%2F04%2F29%2FJava-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[线程(Thread)线程区别于进程 进程：是一个程序的执行过程，是系统中程序的基本单位。运行一个程序即执行一个进程，一个程序对应一个进程，二者创建于销毁等同。 线程：与进程相似，线程比进程的执行单位更小，一个进程中可以创建多个线程，多个线程可以共享同一个内存空间和系统资源。 并发和并行 并行：多个 cpu 实例或者多台机器同时执行一段处理逻辑代码。多核 cpu，每个 cpu 有自己运算器，在多个 cpu 中可以同时运行 并发：多个任务交替执行，多线程单核 cpu 是顺序执行。 线程状态 新生线程 使用操作符 new 例如 new Thread(r) 这里只是创建一个线程，并没有开始运行线程 可运行线程 标志是调用 start() 方法 被阻塞线程 等待线程 被终止线程 被阻塞和等待，当处于这三个状态时，程序不运行任何代码，直到线程调度器重新激活， 线程调度器：会决定哪个线程从等待或者被阻塞状态中挑选出来,何时把某个线程送回等待执行状态.它会决定某个线程运行多久。无法去控制调度，它是不确定。调度不能保证任何执行时间和顺序，不能期待它完全平均分配执行，可以用sleep()来保证时间，向该方法传入的时间单位为毫秒。 线程被终止的两个原因： run 方法的正常退出而自然死亡 一个没有捕获的异常终止了 run 方法而意外死亡 调用 stop 方法也可杀死一个线程，该方法抛出 ThreadDeath 错误对象，不建议使用 stop，该方法已经过时 线程属性 线程优先级守护线程线程组处理未捕获异常处理器 线程优先级默认情况下线程继承它的福线程的优先级，想改变该线程的优先级就需要调用 setPriority(int newPriority) 来设置线程的优先级。newPriority取值范围为 MIN_PRIORITY 到 MAX_PRIORITY 之间（1 ～ 10），通常情况下取值为 NORM_PRIORITY （5） 守护线程为非守护线程提供服务的一个线程，例如一个程序中如果只剩下守护线程时，该程序就该终止运行，守护线程是一个程序结束的最后一步。使用 setDaemon(boolean isDaemon)设置守护线程。 处理未捕获异常处理器线程执行完 run 方法会正常退出。如果该线程中发生了没有捕获的异常，就会造成线程死亡，异常退出。解决方法是在线程死亡之前将异常交给一个用于未捕获异常的处理器。JVM 为我们提供了线程的未捕获异常处理器，通过 Thread 的 setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 来设置，为所有线程添加一个处理器。 线程组如果上述过程没有发生，没有为所有线程添加处理器，那么默认的处理器就是该线程的 ThreadGroup 对象。线程组是一个可以统一管理的线程集合，默认情况下创建的所有线程属于相同的线程组。]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础-集合框架]]></title>
    <url>%2F2018%2F04%2F24%2FJava-%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[泛型 jdk1.5出现的安全机制，避免强制转换。&lt;&gt;当操作应用类型不确定时应用，确定应用类型传入即可。确保类型安全（它的出现不单单确保类型安全）。运行时会将泛型去掉生成class文件不带泛型，为兼容运行类的加载器。 集合概述 集合按照其存储方式可分为两大类，单集合Collection，双集合Map. Cokkection: 单列集合用于存储一系列符合某种规则的元素，两个重要子接口，List 和 Set。List特点是元素有序，元素可重复。Set特点是元素无序且不可重复。List 实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet 和 TreeSet。Map： 双列集合用于存储具有键（Key）和值（Value）映射关系元素，每个元素都包含一对键值对。使用时可用一个Key找出其对应的Value。Map主要实现类有HashMap 和 TreeMap。 List 接口 List 接口继承自Collection接口，是单列集合重要分支。容许存储元素重复，通过索引访问集合中指定元素。存储元素有序，元素存入顺序和取出顺序一致。常用方法 void add（int index，Object element） 将元素element插入在集合的index处 boolean addAll（int index，Collection c) 将集合c所包含的元素插入到List集合的index处 Object get(int index) 返回集合索引index处的元素 Object remove(int index) 删除index索引处元素 Object set(int index,Object element) 将索引indext处元素换成element对象，并将替换后的元素返回 int indexOf(Object o) 返回对象o在List集合中出现的位置索引 int lastIndexO(Object o) 返回对象o在List集合中最后一次出现的位置索引 List subList(int fromIndex,int toIndex) 返回从索引fromINdex(包括)到toIndex(不包括)处所有元素集合组成的子集合asList() List asList(数组) 将数组转到集合，可以使用集合方法操作数组，数组长度时固定的，集合的增删方法不可用。ArrayList ArrayList是List接口实现类，内部封装了一个长度可变的数组对象，存入元素超出数组长度时，会在内存中分配一个更大的数组存储这些元素。ArrayList可看做一个长度可变的数组对象。底层是使用数组来保存元素，在进行增加删除时，会导致创建新数组，效率比较低，不适合做大量的增删操作。但是索引做查找元素很便捷。存取操作 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); System.out.println(&quot;长度&quot;+it.size()); System.out.println(&quot;第2个元素&quot;+it.get(1)); it.remove(1); it.set(0,&quot;e&quot;); System.out.println(it.subList(0,2)); }LinkedList 为了解决ArrayList增删的效率低问题，提供了LinkedList实现类，该集合内部维护了一个双向循环链表。可以实现栈的所有功能和方法，可以把LinkedList作为栈使用。常用方法 void add(int index,E element) 在指定位置加入指定元素 void addFirst（Object o) 将指定元素插入到开头 void addLast(Object o) 将指定元素插入到结尾 Object getFirst() 返回此列表的第一个元素 Object getLast() 返回此列表的最后一个元素 Object removeFrist() 移除并返回此列表第一个元素 Object removeLast() 移除并返回此列表最后一个元素方法使用 public static void main(String[] args) {LinkedList it = new LinkedList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); it.add(1,&quot;dd&quot;); it.addFirst(&quot;ee&quot;); it.removeFirst(); }迭代器 接口Iterator与Collection，Map不同，Collection与Map用于存储元素，Iterator主要用于迭代访问（遍历）Collection中元素，迭代器。Iterator代码实现 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); Iterator i = it.Iterator(); //获取Iterator对象 while(i.hasNext) //判断ArrayList是否存在下一个元苏 { Object obj = it.next(); //取ArrayList集合中元素 System.out.println(obj); } } 迭代器获取ArrayList集合中元素，都会将这些元素当做Object类型来看待，如果想得到特定类型，需要进行强制类型转换。使用迭代器进行迭代时， 如果用集合对象调用remove()方法去删除元素，会出现异常。 集合对象remove()解决方法 第一种：添加break,找到删除，跳出循环停止迭代。 if(“aa”.equals(obj)) { it.remove(); break; } 第二种：用迭代器remove()方法，对于迭代器本身是可预知的。 if(&quot;aa&quot;.equals(obj)) { i.remove(); } 调用remove()必须先调用next()。ListIterator 继承于Iterator类，在父类基础上添加逆向迭代，ListIterator迭代器只能用于List集合中。常用方法 void add(Object o) 将元素插入列表 booleadn hasPrevious() 逆向遍历列表，列表有多个元素，返回true Object previous() 返回列表前一个元素 void remove() 从列表中移除由next或previous返回的最后一个元素逆向迭代代码实现 public static void main(String[] args) {ArrayList it = new ArrayList(); it.add(&quot;aa&quot;); it.add(&quot;bb&quot;); it.add(&quot;cc&quot;); ListIterator i = it.listIterator(it.size());//获取Iterator对象 while(i.hasPrevious) //判断ArrayList是否存在下一个元苏 { Object obj = it.previous(); //取ArrayList集合中元素 System.out.println(obj); } }foreach循环代码实现 foreach(容器中元素类型 临时变量 : 容器容量) {...... } jdk5.0新特性，主要应用于数组。相比Iterator遍历，它的写法简单。foreach循环的次数由容器中个数决定。局限是进行foreach循环只能访问元素，不可以对元素进行修改。 Enumeration接口 在JDK1.2以前还没有Iterator接口时候，遍历集合需要使用Enumeration接口，于Iterator方法类似。集合Vector是List接口的一个实现类，用法与ArrayList完全相同。Vector集合是线程安全的，ArrayList是线程不安全的。在Vector提供一个elements()方法用于返回Enumeration对象，通过Enumeration对象来遍历集合中的元素。代码实现 public static void main(String[] args) {Vertor v = new Vector(); v.add(&quot;aa&quot;); v.add(&quot;bb&quot;); Enumeration en = v.elements(); whoile(en.hasMoreElements) { Object obj - en.nextElement(); System.out.println(obj); } }Set 接口 继承于Collection。Set接口存入元素是无序，不可存入重复元素。主要有俩个实现类HashSet和TreeSet。HashSet是根据哈希值确定元素在集合中的存储位置，具有良好的存取和查找功能。TreeSet是根据二叉树的方式来存储元素，可以对元素集合进行排序。HashSet集合 存储元素无序并且不可重复。存元素是先调用hashCode()确定元素位置，再调用equals()来完成对象的唯一性。如果hashCode()值不同，不用判断，直接存到哈希表。如果hashCode()值相同，判断equals(),true视为相同元素，不存。false视为不同元素，存。必须覆盖hashCode()和equals()HashSet代码实现 public static void main(String[] args) {HashSet h = new HashSet(); h.add(&quot;aa&quot;); h.add(&quot;bb&quot;); Iterator it = h.iterator; while(it.hasNext()) { Object obj = it.next(); System.out.println(obj); } }重写覆盖hashCode()和equals() public int hashCode() //重写hashCode {return x.hasCode(); } public boolean equals(Object obj) //重写equals {if(this == obj) //判断是否为同一对象 { return true; } if(!(obj instanceof S)) //判断是否为S类型 { return false; } S s = (S)obj; //将对象强转S boolean b = this.x.equals(s.x); return b; } TreeSet 利用二叉树存储元素，可以排序，保证没有重复元素。TreeSet利用的是自平衡的排序二叉树。 集合中元素进行排序比较时，会调用compareTo()方法，该方法在Comparable接口中定义。要对集合元素排序就必须实现Comparable接口。Student(name,age)类型对象排序比较需要重写compareTo() public int compareTo(Object obj) //重写compareTo() {Student stu = (Student)obj; if(this.age-stu.age&gt;age) //判断年龄 { return 1; //1存 -1不存 } if(this.age-stu.age==0) { return this.name.compareTo(stu.name); //年龄相同再对名字比较 } return -1; }Map 接口 双列集合，存储每个对象都是一个键值对，一个键(key)和一个值(value),存在的关系是映射。访问时只要找到键(key),就可以找到对应的值(value)。必须保持键(key)的唯一性。常用方法 void put(Object key,Object value) 将值与映射关系中的指定键关联（存） Object get(Object key) 返回映射关系的值，如果不包含返回null（取） boolean containsKey(Object key) 判断指定键(key)关系的映射值（判断） boolean containsValue(Object value) 此映射将一个或多个键映射到指定值（判断） Set keySet() 返回此映射中包含键的Set视图 Collectionvalues 返回此映射中包含值得Collection视图 Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet 返回此映射中包含的映射关系的Set视图HashMap Map接口一个实现类，基于哈希表。如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，那么它必须在外部进行同步。如果存入相同的键(key),后存储的值将覆盖原有的值。键相同，值覆盖。最快的查找技术。常用方法TreeMap Map接口一个实现类，基于二叉树。TreeMap所有键是按照某种顺序排列。常用方法 int size() 返回集合中键(key)映射值的数量 void clear() 删除所有键的映射关系 void comparator() 比较器TreeSet迭代 public static void main(Stringp[] args) {TreeSet tm = new TreeSet(); tm.put(&quot;1&quot;,&quot;aa&quot;); tm.put(&quot;2&quot;,&quot;bb&quot;); Set keySet = tm.keySet(); Iterator it = it.iterator(); while(it.hasNext()) { Object key = it.next(); Object value = it.get(key); System.out.println(key+&quot;,&quot;+value); } }]]></content>
      <categories>
        <category>后端生态</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
